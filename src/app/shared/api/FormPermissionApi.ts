/* tslint:disable */
/**
 * API documentation
 * To use this api you need an access token.  To get the token, send a post request with your email address to api-users resource and one will be send to your. Each endpoint bellow has more information on how to use this API. If you have any questions you can contact us at helpdesk@laji.fi.  You can find more documentation here: [in Finnish](https://beta.laji.fi/about/806), in English (todo). Please refer to [schema.laji.fi](http://schema.laji.fi/) for information about the used vocabulary.  Endpoints Observations and collections * Warehouse - Warehouse API * Collection - Collection metadata * Source - Informatin sources (IT systems) * Annotation - Quality control   Taxonomy * Taxa - Taxonomy API * InformalTaxonGroup - Informal taxon groups are used in taxa and warehouse endpoints * Publication - Scientific publications * Checklist - Mainly you only work with one checklits: the FinBIF master checklist. There are others.   Other master data * Metadata - Variable descriptions * Area - Countries, Finnish municipalities, biogeographical provinces, etc. * Person - Information about people.   Helpers * APIUser - Register as an API user * Autocomplete - For making an autocomplete filed for taxa, collections or persons (friends) * PersonToken - Information about an authorized person   Vihko observation system * Form - Form definition * Document - Document instance of a form * Image - Image of a document   Laji.fi portal * Feedback - Feedback form API * Information - CMS content of information pages * Logger - Error logging from user's browsers to FinBIF * News - News   
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Injectable }                                        from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response }                                          from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class FormPermissionApi {
    protected basePath = '/api';
    public defaultHeaders: Headers = new Headers();

    constructor(protected http: Http) {
    }

    /**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1, T2>(objA: T1, objB: T2) {
        for (let key in objB){
            if(objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * Accept access to form
     * 
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to accept requests
     */
    public acceptRequest(collectionID: string, personID: string, personToken: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.acceptRequestWithHttpInfo(collectionID, personID, personToken, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Find form permission
     * 
     * @param collectionID collection id
     * @param personToken person token
     */
    public findByCollectionID(collectionID: string, personToken?: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.findByCollectionIDWithHttpInfo(collectionID, personToken, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Request access to form
     * 
     * @param collectionID collection id
     * @param personToken person token for the one who is requesting access
     */
    public requestAccess(collectionID: string, personToken: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.requestAccessWithHttpInfo(collectionID, personToken, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Revoke access to form
     * 
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to revoke access to form
     */
    public revokeAccess(collectionID: string, personID: string, personToken: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.revokeAccessWithHttpInfo(collectionID, personID, personToken, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Accept access to form
     * 
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to accept requests
     */
    public acceptRequestWithHttpInfo(collectionID: string, personID: string, personToken: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/formPermissions/${collectionID}/${personID}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionAcceptRequest.');
        }
        // verify required parameter 'personID' is not null or undefined
        if (personID === null || personID === undefined) {
            throw new Error('Required parameter personID was null or undefined when calling formPermissionAcceptRequest.');
        }
        // verify required parameter 'personToken' is not null or undefined
        if (personToken === null || personToken === undefined) {
            throw new Error('Required parameter personToken was null or undefined when calling formPermissionAcceptRequest.');
        }
        if (personToken !== undefined) {
            queryParameters.set('personToken', <any>personToken);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'application/xml', 
            'text/xml'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'application/xml', 
            'text/xml', 
            'application/javascript', 
            'text/javascript'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find form permission
     * 
     * @param collectionID collection id
     * @param personToken person token
     */
    public findByCollectionIDWithHttpInfo(collectionID: string, personToken?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/formPermissions/${collectionID}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionFindByCollectionID.');
        }
        if (personToken !== undefined) {
            queryParameters.set('personToken', <any>personToken);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'application/xml', 
            'text/xml'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'application/xml', 
            'text/xml', 
            'application/javascript', 
            'text/javascript'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Request access to form
     * 
     * @param collectionID collection id
     * @param personToken person token for the one who is requesting access
     */
    public requestAccessWithHttpInfo(collectionID: string, personToken: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/formPermissions/${collectionID}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionRequestAccess.');
        }
        // verify required parameter 'personToken' is not null or undefined
        if (personToken === null || personToken === undefined) {
            throw new Error('Required parameter personToken was null or undefined when calling formPermissionRequestAccess.');
        }
        if (personToken !== undefined) {
            queryParameters.set('personToken', <any>personToken);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'application/xml', 
            'text/xml'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'application/xml', 
            'text/xml', 
            'application/javascript', 
            'text/javascript'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Revoke access to form
     * 
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to revoke access to form
     */
    public revokeAccessWithHttpInfo(collectionID: string, personID: string, personToken: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/formPermissions/${collectionID}/${personID}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionRevokeAccess.');
        }
        // verify required parameter 'personID' is not null or undefined
        if (personID === null || personID === undefined) {
            throw new Error('Required parameter personID was null or undefined when calling formPermissionRevokeAccess.');
        }
        // verify required parameter 'personToken' is not null or undefined
        if (personToken === null || personToken === undefined) {
            throw new Error('Required parameter personToken was null or undefined when calling formPermissionRevokeAccess.');
        }
        if (personToken !== undefined) {
            queryParameters.set('personToken', <any>personToken);
        }


        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json', 
            'application/x-www-form-urlencoded', 
            'application/xml', 
            'text/xml'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json', 
            'application/xml', 
            'text/xml', 
            'application/javascript', 
            'text/javascript'
        ];
        
            



        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });
        
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = this.extendObj(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
