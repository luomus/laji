/* tslint:disable:no-unused-variable member-ordering max-line-length */

/**
 * API documentation
 * To use this api you need an access token.  To getList the token, send a post request with your email address to api-users resource and one will be send to your. Each endpoint bellow has more information on how to use this API. If you have any questions you can contact us at helpdesk@laji.fi.  You can find more documentation here: [in Finnish](https://beta.laji.fi/about/806), in English (todo). Please refer to [schema.laji.fi](http://schema.laji.fi/) for information about the used vocabulary.  Endpoints Observations and collections * Warehouse - Warehouse API * Collection - Collection metadata * Source - Informatin sources (IT systems) * Annotation - Quality control   Taxonomy * Taxa - Taxonomy API * InformalTaxonGroup - Informal taxon groups are used in taxa and warehouse endpoints * Publication - Scientific publications * Checklist - Mainly you only work with one checklits: the FinBIF master checklist. There are others.   Other master data * Metadata - Variable descriptions * Area - Countries, Finnish municipalities, biogeographical provinces, etc. * Person - Information about people.   Helpers * APIUser - Register as an API user * Autocomplete - For making an autocomplete filed for taxa, collections or persons (friends) * PersonToken - Information about an authorized person   Vihko observation system * Form - Form definition * Document - Document instance of a form * Image - Image of a document   Laji.fi portal * Feedback - Feedback form API * Information - CMS content of information pages * Logger - Error logging from user's browsers to FinBIF * News - News
 *
 * OpenAPI spec version: 0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Injectable } from '@angular/core';

import { Observable } from 'rxjs/Observable';

import * as models from '../model';
import { FormPermission } from '../model/FormPermission';
import { HttpClient, HttpResponse } from '@angular/common/http';



@Injectable()
export class FormPermissionApi {
    protected basePath = '/api';

    constructor(protected http: HttpClient) {
    }

    /**
     * Accept access to form
     *
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to accept requests
     */
    public acceptRequest(collectionID: string, personID: string, personToken: string, type?: FormPermission.Type, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.acceptRequestWithHttpInfo(collectionID, personID, personToken, type, extraHttpRequestParams)
            .map((response: HttpResponse) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Find form permission
     *
     * @param collectionID collection id
     * @param personToken person token
     */
    public findByCollectionID(collectionID: string, personToken?: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.findByCollectionIDWithHttpInfo(collectionID, personToken, extraHttpRequestParams)
            .map((response: HttpResponse) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Request access to form
     *
     * @param collectionID collection id
     * @param personToken person token for the one who is requesting access
     */
    public requestAccess(collectionID: string, personToken: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.requestAccessWithHttpInfo(collectionID, personToken, extraHttpRequestParams)
            .map((response: HttpResponse) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Revoke access to form
     *
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to revoke access to form
     */
    public revokeAccess(collectionID: string, personID: string, personToken: string, extraHttpRequestParams?: any): Observable<models.FormPermission> {
        return this.revokeAccessWithHttpInfo(collectionID, personID, personToken, extraHttpRequestParams)
            .map((response: HttpResponse) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Accept access to form
     *
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to accept requests
     * @param type type of permission granted
     */
    public acceptRequestWithHttpInfo(collectionID: string, personID: string, personToken: string, type?: FormPermission.Type, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/formPermissions/${collectionID}/${personID}`;

        const queryParameters = {...extraHttpRequestParams};
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionAcceptRequest.');
        }
        // verify required parameter 'personID' is not null or undefined
        if (personID === null || personID === undefined) {
            throw new Error('Required parameter personID was null or undefined when calling formPermissionAcceptRequest.');
        }
        // verify required parameter 'personToken' is not null or undefined
        if (personToken === null || personToken === undefined) {
            throw new Error('Required parameter personToken was null or undefined when calling formPermissionAcceptRequest.');
        }
        if (personToken !== undefined) {
            queryParameters['personToken'] = personToken;
        }
        if (type !== undefined) {
            queryParameters['type'] = type;
        }

        return this.http.put(path, undefined, {params: queryParameters});
    }

    /**
     * Find form permission
     *
     * @param collectionID collection id
     * @param personToken person token
     */
    public findByCollectionIDWithHttpInfo(collectionID: string, personToken?: string, extraHttpRequestParams?: any): Observable<HttpResponse> {
        const path = this.basePath + `/formPermissions/${collectionID}`;

        const queryParameters = {...extraHttpRequestParams};
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionFindByCollectionID.');
        }
        if (personToken !== undefined) {
            queryParameters['personToken'] = personToken;
        }

        return this.http.get(path, {params: queryParameters});
    }

    /**
     * Request access to form
     *
     * @param collectionID collection id
     * @param personToken person token for the one who is requesting access
     */
    public requestAccessWithHttpInfo(collectionID: string, personToken: string, extraHttpRequestParams?: any): Observable<HttpResponse> {
        const path = this.basePath + `/formPermissions/${collectionID}`;

        const queryParameters = {...extraHttpRequestParams};
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionRequestAccess.');
        }
        // verify required parameter 'personToken' is not null or undefined
        if (personToken === null || personToken === undefined) {
            throw new Error('Required parameter personToken was null or undefined when calling formPermissionRequestAccess.');
        }
        if (personToken !== undefined) {
            queryParameters['personToken'] = personToken;
        }

        return this.http.post(path, undefined, {params: queryParameters});
    }

    /**
     * Revoke access to form
     *
     * @param collectionID collection id
     * @param personID Person id
     * @param personToken person token who is authorised to revoke access to form
     */
    public revokeAccessWithHttpInfo(collectionID: string, personID: string, personToken: string, extraHttpRequestParams?: any): Observable<HttpResponse> {
        const path = this.basePath + `/formPermissions/${collectionID}/${personID}`;

        const queryParameters = {...extraHttpRequestParams};
        // verify required parameter 'collectionID' is not null or undefined
        if (collectionID === null || collectionID === undefined) {
            throw new Error('Required parameter collectionID was null or undefined when calling formPermissionRevokeAccess.');
        }
        // verify required parameter 'personID' is not null or undefined
        if (personID === null || personID === undefined) {
            throw new Error('Required parameter personID was null or undefined when calling formPermissionRevokeAccess.');
        }
        // verify required parameter 'personToken' is not null or undefined
        if (personToken === null || personToken === undefined) {
            throw new Error('Required parameter personToken was null or undefined when calling formPermissionRevokeAccess.');
        }
        if (personToken !== undefined) {
            queryParameters['personToken'] = personToken;
        }

        return this.http.delete(path, {params: queryParameters, observe: 'response'});
    }

}
