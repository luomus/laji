/**
 * This is a custom Luomus cache solution, while the `./server.ts` is generated by Angular SSR.
 * The default exported middleware must be connected to the server's endpoint doing the rendering.
 *
 * !! This solution hijacks the Express response object's `render` method, so
 * !! if the Angular changes their SSR server to work some other way than calling
 * !! `render()`, or Express API changes, this must be updated accordingly.
 */
import * as redis from 'redis';
import { RequestHandler, Request, Response } from 'express';

const CACHE_TIME = 60 * 30; // Secs how long will the content be stored in cache.
const CACHE_UPDATE = 30;    // Secs when the content will be updated even if there is already one in the cache.
const redisClient = redis.createClient({host: process.env.REDIS_HOST || 'localhost'});

const shouldCache = (req: Request) => {
  const skipPaths = [
    '/user',
    '/taxon',
    '/view'
  ];
  return redisClient.connected && skipPaths.every(p => !req.path.match(new RegExp(`^(|/en|/fi|/sv)${p}(\/|$)`)));
};

const getQueryStr = (req: Request) => {
  const queryObj = req.query;
  return Object.keys(queryObj).sort().reduce((str, k) => {
    if (['token', 'personToken'].includes(k)) {
      return str;
    }
    return str += `${str.length ? '&' : ''}${k}=${queryObj[k]}`;
  }, '');
};

const getCacheKey = (req: Request) => {
  const queryStr = getQueryStr(req);
  return `page:${req.path}?${queryStr}`;
};

const cacheSet = function(req: Request, res: Response, html: string) {
  const cacheKey = getCacheKey(req);
  if (res.statusCode === 200 || res.statusCode === 304) {
    redisClient.setex(cacheKey, CACHE_TIME, html);
  }
};

/**
 * An optimistic cache implementation ran on Redis.
 *
 * !! Assumes that it's used before a middleware that renders the html with
 * !! `req.render()` (like `./server.ts` does).
 */
const cacheMiddleware: RequestHandler = (req, res, next) => {
  if (!shouldCache(req)) {
    return next();
  }

  const cacheKey = getCacheKey(req);
  redisClient.get(cacheKey, (errRedis: any, resultRedis: string | null) => {
    const isCached = !errRedis && resultRedis;

    if (!isCached) {
      res.header('x-cache', 'miss');
    } else {
      res.header('x-cache', 'hit');
      res.header('Cache-Control', `public, max-age=${CACHE_UPDATE}`);
      res.send(resultRedis);
    }

    // We hijack the `res.render()`, because:
    // 1. We want to send a cached result, and prevent the `next()` from trying to send it again.
    // 2. We want to call `next()` even though we've already sent a response (in Express we really shouldn't call next()
    //    that sends a response if we've sent the response), because we need to get the rendered HTML so we can cache it
    //    on TTL bust.
    const resRender = res.render.bind(res);
    res.render = (view: string, options?: object, callback?: (err: Error, html: string) => void) => {
      resRender(view, options, (err, html) => {
        if (err) {
          if (callback) {
            callback(err, html);
          } else {
            res.status(500)
              .send('Something went wrong in SSR server!');
          }
          return;
        }
        if (!isCached) {
          cacheSet(req, res, html);
          res.send(html);
        } else {
          redisClient.TTL(cacheKey, (error, ttl) => {
            if (CACHE_TIME - ttl > CACHE_UPDATE || ttl < 0 || error) {
              cacheSet(req, res, html);
            }
          });
        }
        if (callback) {
          callback(err, html);
        }
      });
    };

    next();
  });
};

export default cacheMiddleware;
