/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/forms/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get form permissions for a person */
        get: operations["FormsController_getPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/forms/permissions/{collectionID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get form permissions for a person, and the form information about whether is has MHL.restrictAccess and MHL.hasAdmins */
        get: operations["FormsController_getPermissionsByCollectionID"];
        put?: never;
        /** @description Request access to form */
        post: operations["FormsController_requestAccess"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/forms/permissions/{collectionID}/{personID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Accept access to form */
        put: operations["FormsController_acceptAccess"];
        post?: never;
        /** @description Remove access to form */
        delete: operations["FormsController_revokeAccess"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/forms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of forms */
        get: operations["FormsController_getPage"];
        put?: never;
        /** @description Create a new form */
        post: operations["FormsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/forms/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a form by id */
        get: operations["FormsController_getOne"];
        /** @description Update an existing form */
        put: operations["FormsController_update"];
        post?: never;
        /** @description Delete a form */
        delete: operations["FormsController_remove"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/forms/transform": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Get preview of form transformed from json format to schema format */
        post: operations["FormsController_transform"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/person/{personToken}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Find person by person token */
        get: operations["PersonsController_findPersonByToken"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/person/{personToken}/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["PersonsController_findProfileByPersonToken"];
        /** @description Update profile */
        put: operations["PersonsController_updateProfile"];
        /** @description Create profile */
        post: operations["PersonsController_createProfile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/person/by-id/{personId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Find person by user id (this will not include email) */
        get: operations["PersonsController_findPersonByPersonId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/person/by-id/{personId}/profile": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Find profile by user id (this will only return small subset of the full profile) */
        get: operations["PersonsController_getProfileByPersonId"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/person/{personToken}/friends/{friendPersonID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Accept friend request */
        put: operations["PersonsController_acceptFriendRequest"];
        /** @description Request person to be your friend */
        post: operations["PersonsController_addFriendRequest"];
        /** @description Remove a friend request or a friend */
        delete: operations["PersonsController_removeFriend"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/person-token/{personToken}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns information about the token */
        get: operations["PersonTokenController_getInfo"];
        put?: never;
        post?: never;
        /** @description Deletes the token */
        delete: operations["PersonTokenController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications/{personToken}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get notifications */
        get: operations["NotificationsController_getAll"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/notifications/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Update notification */
        put: operations["NotificationsController_update"];
        post?: never;
        /** @description Delete notification */
        delete: operations["NotificationsController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collections": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get all collections */
        get: operations["CollectionsController_getPage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collections/roots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get all root collections */
        get: operations["CollectionsController_findRoots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collections/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get collection by id */
        get: operations["CollectionsController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/collections/{id}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get child collections */
        get: operations["CollectionsController_findChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api-users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns info about user based on the access token */
        get: operations["ApiUsersController_getInfo"];
        put?: never;
        /** @description Register as an api user (access token will be sent to your email) */
        post: operations["ApiUsersController_register"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api-users/renew": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Requests new access token (will be sent to your email). Please note that this will not delete any existing tokens. */
        post: operations["ApiUsersController_renew"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Upload image and get temporary id */
        post: operations["ImagesController_upload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get image by id */
        get: operations["ImagesController_get"];
        /** @description Update image metadata */
        put: operations["ImagesController_updateMetadata"];
        post?: never;
        /** @description Delete image */
        delete: operations["ImagesController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images/{id}/large.jpg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch large image by id */
        get: operations["ImagesController_findLarge"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images/{id}/square.jpg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch square thumbnail by id */
        get: operations["ImagesController_findSquare"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images/{id}/thumbnail.jpg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch thumbnail by id */
        get: operations["ImagesController_findThumbnail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/images/{tempId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Upload image metadata */
        post: operations["ImagesController_uploadMetadata"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Upload audio and get temporary id */
        post: operations["AudioController_upload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get audio by id */
        get: operations["AudioController_get"];
        /** @description Update audio metadata */
        put: operations["AudioController_updateMetadata"];
        post?: never;
        /** @description Delete audio */
        delete: operations["AudioController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/{id}/mp3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch mp3 by id */
        get: operations["AudioController_getMp3"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/{id}/thumbnail.jpg": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch thumbnail by id */
        get: operations["AudioController_getThumbnail"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/{id}/wav": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch wav by id */
        get: operations["AudioController_getWav"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/{id}/flac": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch flac by id */
        get: operations["AudioController_findFlac"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/audio/{tempId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Upload audio metadata */
        post: operations["AudioController_uploadMetadata"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/named-places/{id}/reservation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Reserve an existing named place */
        post: operations["NamedPlacesController_reserve"];
        /** @description Cancel a reservation for a named place */
        delete: operations["NamedPlacesController_cancelReservation"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/named-places": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of named places */
        get: operations["NamedPlacesController_getPage"];
        put?: never;
        /** @description Create a new named place */
        post: operations["NamedPlacesController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/named-places/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a named place by id */
        get: operations["NamedPlacesController_get"];
        /** @description Update an existing named place */
        put: operations["NamedPlacesController_update"];
        post?: never;
        /** @description Delete a named place */
        delete: operations["NamedPlacesController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/areas/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of areas */
        get: operations["AreaController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/areas": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of areas */
        get: operations["AreaController_getPage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Starts a batch job that validates the documents. Use the returned job id to get the status of the job with GET
         *     /documents/:jobID, or create the documents with POST /documents/batch/:jobID */
        post: operations["DocumentsController_startBatchJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/batch/{jobID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a batch job's status. Once ready, the response will include properties 'documents' and 'errors', where the
         *     errors match the documents array indices, null meaning valid and an object. */
        get: operations["DocumentsController_getBatchJobStatus"];
        put?: never;
        /** @description Completes a given batch job by sending them to the store/warehouse. The batch job must be already validated. */
        post: operations["DocumentsController_completeBatchJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Validate a document */
        post: operations["DocumentsController_validate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/count/byYear": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get count of documents by type (currently just "byYear") */
        get: operations["DocumentsController_getCountByYear"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get the median date of documents for a named place */
        get: operations["DocumentsController_getStatistics"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of documents */
        get: operations["DocumentsController_getPage"];
        put?: never;
        /** @description Create a new document */
        post: operations["DocumentsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/documents/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a document */
        get: operations["DocumentsController_get"];
        /** @description Update an existing document */
        put: operations["DocumentsController_update"];
        post?: never;
        /** @description Update an existing document */
        delete: operations["DocumentsController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/annotations/tags": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Fetch all annotation tags (Only visible in dev mode) */
        get: operations["AnnotationsController_getTags"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/annotations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of annotations */
        get: operations["AnnotationsController_getPage"];
        put?: never;
        /** @description Create a new annotation */
        post: operations["AnnotationsController_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/annotations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** @description Delete an annotation */
        delete: operations["AnnotationsController_delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/information/index": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns id of the index page of some language */
        get: operations["InformationController_getIndex"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/information/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get information page by id */
        get: operations["InformationController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/information": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get information page contents */
        get: operations["InformationController_getAll"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checklists/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a checklist by id */
        get: operations["ChecklistController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checklists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of checklists */
        get: operations["ChecklistController_getPage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checklist-versions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a checklist by id */
        get: operations["ChecklistVersionsController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/checklist-versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of checklists */
        get: operations["ChecklistVersionsController_getPage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/organizations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Find an organization by id */
        get: operations["OrganizationsController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a page of informal taxon groups */
        get: operations["InformalTaxonGroupsController_getPage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/tree": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get the informal taxon group tree */
        get: operations["InformalTaxonGroupsController_getTree"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/roots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get first level of the informal taxon group tree */
        get: operations["InformalTaxonGroupsController_getRoots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get an informal taxon group by id */
        get: operations["InformalTaxonGroupsController_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/{id}/children": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get an informal taxon group's immediate children */
        get: operations["InformalTaxonGroupsController_getChildren"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/{id}/parents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get informal taxon group's parents */
        get: operations["InformalTaxonGroupsController_getParents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/{id}/parent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get informal taxon group's parents */
        get: operations["InformalTaxonGroupsController_getParent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/informal-taxon-groups/{id}/siblings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get informal taxon group's siblings */
        get: operations["InformalTaxonGroupsController_getSiblings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/push": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Load data to the Data Warehouse
         * @description Requires that API key has load permissions. Data is given in request body. Supports multiple data formats. See [documentation](https://laji.fi/about/1402). Accepts all payloads that pass format validation (for example is valid XML), but that does not mean the data will be processed succesfully.
         */
        post: {
            parameters: {
                query?: {
                    /** @description Normally sourceId is received via the API key. By giving this parameter you can override the sourceId. API key must have permissions to use that sourceId. */
                    sourceId?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            /** @description See [documentation](https://laji.fi/about/1402) for complete reference. Can contain multiple documents. */
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DwETL_DwRoot"];
                    "application/xml": string;
                    "application/rdf+xml": string;
                    "text/plain": string;
                    "text/csv": string;
                };
            };
            responses: {
                /** @description Accepted and stored for processing. Does not neccesarilly mean the data will be successfully processed. Returns "ok" */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
                /** @description Data was not accepted. Message tells why. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        /**
         * Report document deleted
         * @description Requires that API key has load permissions. Note that you can only delete documents from the source that is defined by access_token
         */
        delete: {
            parameters: {
                query: {
                    /** @description Document URI to be deleted. */
                    documentId: string;
                    /** @description Normally sourceId is received via the API key. By giving this parameter you can override the sourceId. API key must have permissions to use that sourceId. */
                    sourceId?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Accepted delete request. Does not neccesarilly mean there was anything to delete or that delete has gone through yet. Returns "ok" */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
                /** @description Data was not accepted. Message tells why. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/document": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get single full document.
         * @description Get single full document by document URI. Contains the document, gatherings and units, including facts, media etc
         */
        get: {
            parameters: {
                query: {
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "xml";
                    /** @description Full document ID (URI identifier) */
                    documentId: string;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwSingle_Document"];
                        "application/xml": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/document/aggregate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Perform aggregate queries (group by) on documents.
         * @description Aggregates the results of the query based on given "aggregateBy" parameters. Always includes count of rows (count(*)) to the result. Other aggregate functions vary based on the given parameters. Possible aggregate functions are [count, firstLoadDateMin, firstLoadDateMax, securedCount]
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define fields to aggregate by. Multiple values are seperated by ','. */
                    aggregateBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.notes" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.randomKey" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId";
                    /** @description Define what fields to use when sorting results. Defaults to count (desc) and each aggregate by field (asc). Each fieldname given as parameter defaults to ASC - if you want to sort using descending order, add " DESC" to the end of the field name. In addition to aggregateBy fields you can use the following aggregate function names: [count, firstLoadDateMin, firstLoadDateMax, securedCount]. Multiple values are seperated by ','. */
                    orderBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.notes" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.randomKey" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "count" | "firstLoadDateMin" | "firstLoadDateMax" | "securedCount";
                    /** @description Return only count of rows (default) or also additional aggregate function values. */
                    onlyCount?: boolean;
                    /** @description Include or exclude nulls to result. Will only check nullness of the first aggregateBy field. */
                    excludeNulls?: boolean;
                    /** @description Value of this parameter affects how oldestRecord and newestRecord are calculated regarding observations reported as date span. False (default): oldest=min(date.begin), newest=max(date.end). True: oldest=min(date.end), newest=max(date.begin). */
                    pessimisticDateRangeHandling?: boolean;
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "csv" | "tsv";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_AggregateResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "text/csv": string;
                        "text/tab-separated-values": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/gathering/aggregate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Perform aggregate queries (group by) on gatherings.
         * @description Aggregates the results of the query based on given "aggregateBy" parameters. Always includes count of rows (count(*)) to the result. Other aggregate functions vary based on the given parameters. Possible aggregate functions are [count, oldestRecord, newestRecord, lineLengthSum, firstLoadDateMin, firstLoadDateMax, securedCount]
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define fields to aggregate by. Multiple values are seperated by ','. */
                    aggregateBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers" | "gathering.locality" | "gathering.media.author" | "gathering.media.copyrightOwner" | "gathering.media.licenseId" | "gathering.media.mediaType" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.notes" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "gathering.team.memberId" | "gathering.team.memberName";
                    /** @description Define what fields to use when sorting results. Defaults to count (desc) and each aggregate by field (asc). Each fieldname given as parameter defaults to ASC - if you want to sort using descending order, add " DESC" to the end of the field name. In addition to aggregateBy fields you can use the following aggregate function names: [count, oldestRecord, newestRecord, lineLengthSum, firstLoadDateMin, firstLoadDateMax, securedCount]. Multiple values are seperated by ','. */
                    orderBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers" | "gathering.locality" | "gathering.media.author" | "gathering.media.copyrightOwner" | "gathering.media.licenseId" | "gathering.media.mediaType" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.notes" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "gathering.team.memberId" | "gathering.team.memberName" | "count" | "oldestRecord" | "newestRecord" | "lineLengthSum" | "firstLoadDateMin" | "firstLoadDateMax" | "securedCount";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Return only count of rows (default) or also additional aggregate function values. */
                    onlyCount?: boolean;
                    /** @description Include or exclude nulls to result. Will only check nullness of the first aggregateBy field. */
                    excludeNulls?: boolean;
                    /** @description Value of this parameter affects how oldestRecord and newestRecord are calculated regarding observations reported as date span. False (default): oldest=min(date.begin), newest=max(date.end). True: oldest=min(date.end), newest=max(date.begin). */
                    pessimisticDateRangeHandling?: boolean;
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "csv" | "tsv";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_AggregateResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "text/csv": string;
                        "text/tab-separated-values": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/gathering/statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Perform aggregate queries on gatherings to PRIVATE side of the data warehouse.
         * @description  Functionality is same as normal /aggregate API except functionaly is limited to only certain collections, filters and aggregateBy fields. CollectionId filter is required and only certain collections are allowed.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define fields to aggregate by. Multiple values are seperated by ','. */
                    aggregateBy?: "document.documentId" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.year" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.gatheringSection";
                    /** @description Define what fields to use when sorting results. Defaults to count (desc) and each aggregate by field (asc). Each fieldname given as parameter defaults to ASC - if you want to sort using descending order, add " DESC" to the end of the field name. In addition to aggregateBy fields you can use the following aggregate function names: [count, oldestRecord, newestRecord, lineLengthSum, firstLoadDateMin, firstLoadDateMax, securedCount]. Multiple values are seperated by ','. */
                    orderBy?: "document.documentId" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.year" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.gatheringSection" | "count" | "oldestRecord" | "newestRecord" | "lineLengthSum" | "firstLoadDateMin" | "firstLoadDateMax" | "securedCount";
                    /** @description Return only count of rows (default) or also additional aggregate function values. */
                    onlyCount?: boolean;
                    /** @description Include or exclude nulls to result. Will only check nullness of the first aggregateBy field. */
                    excludeNulls?: boolean;
                    /** @description Value of this parameter affects how oldestRecord and newestRecord are calculated regarding observations reported as date span. False (default): oldest=min(date.begin), newest=max(date.end). True: oldest=min(date.end), newest=max(date.begin). */
                    pessimisticDateRangeHandling?: boolean;
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "csv" | "tsv";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_AggregateResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "text/csv": string;
                        "text/tab-separated-values": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/unit/count": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get count of units using given filters
         * @description Use this API to test how many results your query would return and then proceed with list query.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "xml" | "plain";
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_CountResponse"];
                        "application/xml": string;
                        "text/plain": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/unit/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get list of units using given filters
         * @description Get list of results as a 'flat row'. Application/json and application/xml responses respect the "selected" parameter, but application/rdf+xml returns always the same "CETAF standard" fields.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define what fields to include to the result. Defaults to [document.collectionId, document.documentId, document.licenseId, document.secureLevel, document.secureReasons, document.sourceId, gathering.conversions.wgs84CenterPoint.lat, gathering.conversions.wgs84CenterPoint.lon, gathering.displayDateTime, gathering.gatheringId, gathering.interpretations.coordinateAccuracy, gathering.interpretations.municipalityDisplayname, gathering.interpretations.sourceOfCoordinates, gathering.locality, gathering.team, unit.abundanceString, unit.linkings.taxon.id, unit.linkings.taxon.scientificName, unit.linkings.taxon.vernacularName, unit.notes, unit.recordBasis, unit.taxonVerbatim, unit.unitId] Multiple values are seperated by ','. */
                    selected?: "document.annotations.addedTags" | "document.annotations.annotationByPerson" | "document.annotations.annotationByPersonName" | "document.annotations.annotationBySystem" | "document.annotations.annotationBySystemName" | "document.annotations.byRole" | "document.annotations.created" | "document.annotations.deleted" | "document.annotations.deletedByPerson" | "document.annotations.deletedByPersonName" | "document.annotations.deletedDateTime" | "document.annotations.id" | "document.annotations.notes" | "document.annotations.removedTags" | "document.annotations.valid" | "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors.fullName" | "document.linkings.editors.id" | "document.linkings.editors.userId" | "document.loadDate" | "document.media.author" | "document.media.caption" | "document.media.copyrightOwner" | "document.media.fullResolutionMediaAvailable" | "document.media.fullURL" | "document.media.highDetailModelURL" | "document.media.licenseId" | "document.media.lowDetailModelURL" | "document.media.mediaType" | "document.media.mp3URL" | "document.media.squareThumbnailURL" | "document.media.thumbnailURL" | "document.media.type" | "document.media.videoURL" | "document.media.wavURL" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.tags" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.notes" | "document.partial" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.message" | "document.quality.issue.source" | "document.referenceURL" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "document.sourceTags" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.eurefWKT" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.wgs84WKT" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.conversions.ykjWKT" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.biogeographicalProvinces" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipalities" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers.fullName" | "gathering.linkings.observers.id" | "gathering.linkings.observers.userId" | "gathering.locality" | "gathering.media.author" | "gathering.media.caption" | "gathering.media.copyrightOwner" | "gathering.media.fullResolutionMediaAvailable" | "gathering.media.fullURL" | "gathering.media.highDetailModelURL" | "gathering.media.licenseId" | "gathering.media.lowDetailModelURL" | "gathering.media.mediaType" | "gathering.media.mp3URL" | "gathering.media.squareThumbnailURL" | "gathering.media.thumbnailURL" | "gathering.media.type" | "gathering.media.videoURL" | "gathering.media.wavURL" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.notes" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.message" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.message" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.message" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.addedTags" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.byRole" | "unit.annotations.created" | "unit.annotations.deleted" | "unit.annotations.deletedByPerson" | "unit.annotations.deletedByPersonName" | "unit.annotations.deletedDateTime" | "unit.annotations.id" | "unit.annotations.identification.author" | "unit.annotations.identification.facts.decimalValue" | "unit.annotations.identification.facts.fact" | "unit.annotations.identification.facts.integerValue" | "unit.annotations.identification.facts.value" | "unit.annotations.identification.id" | "unit.annotations.identification.linkings.taxon.administrativeStatuses" | "unit.annotations.identification.linkings.taxon.checklist" | "unit.annotations.identification.linkings.taxon.cursiveName" | "unit.annotations.identification.linkings.taxon.finnish" | "unit.annotations.identification.linkings.taxon.id" | "unit.annotations.identification.linkings.taxon.informalTaxonGroups" | "unit.annotations.identification.linkings.taxon.kingdomScientificName" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.identification.linkings.taxon.nameEnglish" | "unit.annotations.identification.linkings.taxon.nameFinnish" | "unit.annotations.identification.linkings.taxon.nameSwedish" | "unit.annotations.identification.linkings.taxon.occurrenceCountFinland" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.identification.linkings.taxon.primaryHabitat.id" | "unit.annotations.identification.linkings.taxon.primaryHabitat.order" | "unit.annotations.identification.linkings.taxon.scientificName" | "unit.annotations.identification.linkings.taxon.scientificNameAuthorship" | "unit.annotations.identification.linkings.taxon.scientificNameDisplayName" | "unit.annotations.identification.linkings.taxon.sensitive" | "unit.annotations.identification.linkings.taxon.taxonConceptIds" | "unit.annotations.identification.linkings.taxon.taxonRank" | "unit.annotations.identification.linkings.taxon.taxonomicOrder" | "unit.annotations.identification.linkings.taxon.threatenedStatus" | "unit.annotations.identification.linkings.taxon.vernacularName" | "unit.annotations.identification.notes" | "unit.annotations.identification.taxon" | "unit.annotations.identification.taxonID" | "unit.annotations.identification.taxonSpecifier" | "unit.annotations.identification.taxonSpecifierAuthor" | "unit.annotations.notes" | "unit.annotations.occurrenceAtTimeOfAnnotation.countryVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateBegin" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateEnd" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.administrativeStatuses" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.checklist" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.cursiveName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.finnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.informalTaxonGroups" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.kingdomScientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameEnglish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameFinnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameSwedish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.occurrenceCountFinland" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.order" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameAuthorship" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameDisplayName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.sensitive" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonConceptIds" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonRank" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonomicOrder" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.threatenedStatus" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.vernacularName" | "unit.annotations.occurrenceAtTimeOfAnnotation.locality" | "unit.annotations.occurrenceAtTimeOfAnnotation.municipalityVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonId" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLat" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLon" | "unit.annotations.removedTags" | "unit.annotations.valid" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.externalMediaCount" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.identificationBasis" | "unit.identifications.author" | "unit.identifications.det" | "unit.identifications.detDate" | "unit.identifications.facts.decimalValue" | "unit.identifications.facts.fact" | "unit.identifications.facts.integerValue" | "unit.identifications.facts.value" | "unit.identifications.id" | "unit.identifications.linkings.taxon.administrativeStatuses" | "unit.identifications.linkings.taxon.checklist" | "unit.identifications.linkings.taxon.cursiveName" | "unit.identifications.linkings.taxon.finnish" | "unit.identifications.linkings.taxon.id" | "unit.identifications.linkings.taxon.informalTaxonGroups" | "unit.identifications.linkings.taxon.kingdomScientificName" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.status" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.year" | "unit.identifications.linkings.taxon.nameEnglish" | "unit.identifications.linkings.taxon.nameFinnish" | "unit.identifications.linkings.taxon.nameSwedish" | "unit.identifications.linkings.taxon.occurrenceCountFinland" | "unit.identifications.linkings.taxon.primaryHabitat.habitat" | "unit.identifications.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.identifications.linkings.taxon.primaryHabitat.id" | "unit.identifications.linkings.taxon.primaryHabitat.order" | "unit.identifications.linkings.taxon.scientificName" | "unit.identifications.linkings.taxon.scientificNameAuthorship" | "unit.identifications.linkings.taxon.scientificNameDisplayName" | "unit.identifications.linkings.taxon.sensitive" | "unit.identifications.linkings.taxon.taxonConceptIds" | "unit.identifications.linkings.taxon.taxonRank" | "unit.identifications.linkings.taxon.taxonomicOrder" | "unit.identifications.linkings.taxon.threatenedStatus" | "unit.identifications.linkings.taxon.vernacularName" | "unit.identifications.notes" | "unit.identifications.preferred" | "unit.identifications.taxon" | "unit.identifications.taxonID" | "unit.identifications.taxonSpecifier" | "unit.identifications.taxonSpecifierAuthor" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.checklist" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.kingdomScientificName" | "unit.linkings.originalTaxon.latestRedListStatusFinland.status" | "unit.linkings.originalTaxon.latestRedListStatusFinland.year" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.primaryHabitat.habitat" | "unit.linkings.originalTaxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.originalTaxon.primaryHabitat.id" | "unit.linkings.originalTaxon.primaryHabitat.order" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameAuthorship" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.taxonConceptIds" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.threatenedStatus" | "unit.linkings.originalTaxon.vernacularName" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.checklist" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.kingdomScientificName" | "unit.linkings.taxon.latestRedListStatusFinland.status" | "unit.linkings.taxon.latestRedListStatusFinland.year" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.primaryHabitat.habitat" | "unit.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.taxon.primaryHabitat.id" | "unit.linkings.taxon.primaryHabitat.order" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameAuthorship" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.taxonConceptIds" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.threatenedStatus" | "unit.linkings.taxon.vernacularName" | "unit.local" | "unit.media.author" | "unit.media.caption" | "unit.media.copyrightOwner" | "unit.media.fullResolutionMediaAvailable" | "unit.media.fullURL" | "unit.media.highDetailModelURL" | "unit.media.licenseId" | "unit.media.lowDetailModelURL" | "unit.media.mediaType" | "unit.media.mp3URL" | "unit.media.squareThumbnailURL" | "unit.media.thumbnailURL" | "unit.media.type" | "unit.media.videoURL" | "unit.media.wavURL" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.message" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.reportedTaxonId" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.notes" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.sourceTags" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.types.author" | "unit.types.basionymePublication" | "unit.types.facts.decimalValue" | "unit.types.facts.fact" | "unit.types.facts.integerValue" | "unit.types.facts.value" | "unit.types.id" | "unit.types.linkings.taxon.administrativeStatuses" | "unit.types.linkings.taxon.checklist" | "unit.types.linkings.taxon.cursiveName" | "unit.types.linkings.taxon.finnish" | "unit.types.linkings.taxon.id" | "unit.types.linkings.taxon.informalTaxonGroups" | "unit.types.linkings.taxon.kingdomScientificName" | "unit.types.linkings.taxon.latestRedListStatusFinland.status" | "unit.types.linkings.taxon.latestRedListStatusFinland.year" | "unit.types.linkings.taxon.nameEnglish" | "unit.types.linkings.taxon.nameFinnish" | "unit.types.linkings.taxon.nameSwedish" | "unit.types.linkings.taxon.occurrenceCountFinland" | "unit.types.linkings.taxon.primaryHabitat.habitat" | "unit.types.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.types.linkings.taxon.primaryHabitat.id" | "unit.types.linkings.taxon.primaryHabitat.order" | "unit.types.linkings.taxon.scientificName" | "unit.types.linkings.taxon.scientificNameAuthorship" | "unit.types.linkings.taxon.scientificNameDisplayName" | "unit.types.linkings.taxon.sensitive" | "unit.types.linkings.taxon.taxonConceptIds" | "unit.types.linkings.taxon.taxonRank" | "unit.types.linkings.taxon.taxonomicOrder" | "unit.types.linkings.taxon.threatenedStatus" | "unit.types.linkings.taxon.vernacularName" | "unit.types.notes" | "unit.types.publication" | "unit.types.status" | "unit.types.taxon" | "unit.types.taxonID" | "unit.types.taxonSpecifier" | "unit.types.taxonSpecifierAuthor" | "unit.types.typif" | "unit.types.typifDate" | "unit.types.verification" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild";
                    /** @description Define what fields to use when sorting results. Defaults to [gathering.eventDate.begin DESC, document.loadDate DESC, unit.taxonVerbatim ASC]. Unit key is always added as a last parameter to ensure correct paging. You can include ASC or DESC after the name of the field (defaults to ASC).Multiple values are seperated by ','. */
                    orderBy?: "RANDOM" | "RANDOM:seed" | "document.collectionId" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.firstLoadDate" | "document.linkings.collectionQuality" | "document.loadDate" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.name" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secured" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.biogeographicalProvince" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.locality" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.team" | "unit.abundanceString" | "unit.alive" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.lifeStage" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.taxon.author" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.local" | "unit.mediaCount" | "unit.notes" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedTaxonConfidence" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.wild";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "rdf_xml";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_ListResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "application/rdf+xml": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/unit/aggregate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Perform aggregate queries (group by) on units.
         * @description Aggregates the results of the query based on given "aggregateBy" parameters. Always includes count of rows (count(*)) to the result. Other aggregate functions vary based on the given parameters. Possible aggregate functions are [count, individualCountSum, individualCountMax, oldestRecord, newestRecord, recordQualityMax, firstLoadDateMin, firstLoadDateMax, gatheringCount, securedCount, pairCountMax, pairCountSum, taxonCount, speciesCount, redListStatusMax, atlasCodeMax, atlasClassMax]
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define fields to aggregate by. Multiple values are seperated by ','. */
                    aggregateBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers" | "gathering.locality" | "gathering.media.author" | "gathering.media.copyrightOwner" | "gathering.media.licenseId" | "gathering.media.mediaType" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "gathering.team.memberId" | "gathering.team.memberName" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.created" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.aggregateId" | "unit.linkings.originalTaxon.anamorphId" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.birdlifeCode" | "unit.linkings.originalTaxon.classId" | "unit.linkings.originalTaxon.cultivarId" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.divisionId" | "unit.linkings.originalTaxon.domainId" | "unit.linkings.originalTaxon.ecotypeId" | "unit.linkings.originalTaxon.euringCode" | "unit.linkings.originalTaxon.euringNumber" | "unit.linkings.originalTaxon.familyId" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.formId" | "unit.linkings.originalTaxon.genusId" | "unit.linkings.originalTaxon.grexId" | "unit.linkings.originalTaxon.groupId" | "unit.linkings.originalTaxon.habitats" | "unit.linkings.originalTaxon.hybridId" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.infraclassId" | "unit.linkings.originalTaxon.infradivisionId" | "unit.linkings.originalTaxon.infragenericHybridId" | "unit.linkings.originalTaxon.infragenericTaxonId" | "unit.linkings.originalTaxon.infrakingdomId" | "unit.linkings.originalTaxon.infraorderId" | "unit.linkings.originalTaxon.infraphylumId" | "unit.linkings.originalTaxon.infraspecificTaxonId" | "unit.linkings.originalTaxon.intergenericHybridId" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.kingdomId" | "unit.linkings.originalTaxon.nameAccordingTo" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.nothogenusId" | "unit.linkings.originalTaxon.nothospeciesId" | "unit.linkings.originalTaxon.nothosubspeciesId" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.orderId" | "unit.linkings.originalTaxon.parentId" | "unit.linkings.originalTaxon.parvclassId" | "unit.linkings.originalTaxon.parvorderId" | "unit.linkings.originalTaxon.phylumId" | "unit.linkings.originalTaxon.populationGroupId" | "unit.linkings.originalTaxon.primaryHabitat" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.redListStatusGroup" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sectionId" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.seriesId" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesAggregateId" | "unit.linkings.originalTaxon.speciesId" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.speciesTaxonomicOrder" | "unit.linkings.originalTaxon.subclassId" | "unit.linkings.originalTaxon.subdivisionId" | "unit.linkings.originalTaxon.subfamilyId" | "unit.linkings.originalTaxon.subformId" | "unit.linkings.originalTaxon.subgenusId" | "unit.linkings.originalTaxon.subkingdomId" | "unit.linkings.originalTaxon.suborderId" | "unit.linkings.originalTaxon.subphylumId" | "unit.linkings.originalTaxon.subsectionId" | "unit.linkings.originalTaxon.subseriesId" | "unit.linkings.originalTaxon.subspeciesId" | "unit.linkings.originalTaxon.subspecificAggregateId" | "unit.linkings.originalTaxon.subtribeId" | "unit.linkings.originalTaxon.subvarietyId" | "unit.linkings.originalTaxon.superclassId" | "unit.linkings.originalTaxon.superdivisionId" | "unit.linkings.originalTaxon.superdomainId" | "unit.linkings.originalTaxon.superfamilyId" | "unit.linkings.originalTaxon.supergenusId" | "unit.linkings.originalTaxon.superorderId" | "unit.linkings.originalTaxon.superphylumId" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonSets" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.tribeId" | "unit.linkings.originalTaxon.typesOfOccurrenceInFinland" | "unit.linkings.originalTaxon.varietyId" | "unit.linkings.originalTaxon.virva" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.aggregateId" | "unit.linkings.taxon.anamorphId" | "unit.linkings.taxon.author" | "unit.linkings.taxon.birdlifeCode" | "unit.linkings.taxon.classId" | "unit.linkings.taxon.cultivarId" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.divisionId" | "unit.linkings.taxon.domainId" | "unit.linkings.taxon.ecotypeId" | "unit.linkings.taxon.euringCode" | "unit.linkings.taxon.euringNumber" | "unit.linkings.taxon.familyId" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.formId" | "unit.linkings.taxon.genusId" | "unit.linkings.taxon.grexId" | "unit.linkings.taxon.groupId" | "unit.linkings.taxon.habitats" | "unit.linkings.taxon.hybridId" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.infraclassId" | "unit.linkings.taxon.infradivisionId" | "unit.linkings.taxon.infragenericHybridId" | "unit.linkings.taxon.infragenericTaxonId" | "unit.linkings.taxon.infrakingdomId" | "unit.linkings.taxon.infraorderId" | "unit.linkings.taxon.infraphylumId" | "unit.linkings.taxon.infraspecificTaxonId" | "unit.linkings.taxon.intergenericHybridId" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.kingdomId" | "unit.linkings.taxon.nameAccordingTo" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.nothogenusId" | "unit.linkings.taxon.nothospeciesId" | "unit.linkings.taxon.nothosubspeciesId" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.orderId" | "unit.linkings.taxon.parentId" | "unit.linkings.taxon.parvclassId" | "unit.linkings.taxon.parvorderId" | "unit.linkings.taxon.phylumId" | "unit.linkings.taxon.populationGroupId" | "unit.linkings.taxon.primaryHabitat" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.redListStatusGroup" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sectionId" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.seriesId" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesAggregateId" | "unit.linkings.taxon.speciesId" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.speciesTaxonomicOrder" | "unit.linkings.taxon.subclassId" | "unit.linkings.taxon.subdivisionId" | "unit.linkings.taxon.subfamilyId" | "unit.linkings.taxon.subformId" | "unit.linkings.taxon.subgenusId" | "unit.linkings.taxon.subkingdomId" | "unit.linkings.taxon.suborderId" | "unit.linkings.taxon.subphylumId" | "unit.linkings.taxon.subsectionId" | "unit.linkings.taxon.subseriesId" | "unit.linkings.taxon.subspeciesId" | "unit.linkings.taxon.subspecificAggregateId" | "unit.linkings.taxon.subtribeId" | "unit.linkings.taxon.subvarietyId" | "unit.linkings.taxon.superclassId" | "unit.linkings.taxon.superdivisionId" | "unit.linkings.taxon.superdomainId" | "unit.linkings.taxon.superfamilyId" | "unit.linkings.taxon.supergenusId" | "unit.linkings.taxon.superorderId" | "unit.linkings.taxon.superphylumId" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonSets" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.tribeId" | "unit.linkings.taxon.typesOfOccurrenceInFinland" | "unit.linkings.taxon.varietyId" | "unit.linkings.taxon.virva" | "unit.local" | "unit.media.author" | "unit.media.copyrightOwner" | "unit.media.licenseId" | "unit.media.mediaType" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild";
                    /** @description Define what fields to use when sorting results. Defaults to count (desc) and each aggregate by field (asc). Each fieldname given as parameter defaults to ASC - if you want to sort using descending order, add " DESC" to the end of the field name. In addition to aggregateBy fields you can use the following aggregate function names: [count, individualCountSum, individualCountMax, oldestRecord, newestRecord, recordQualityMax, firstLoadDateMin, firstLoadDateMax, gatheringCount, securedCount, pairCountMax, pairCountSum, taxonCount, speciesCount, redListStatusMax, atlasCodeMax, atlasClassMax]. Multiple values are seperated by ','. */
                    orderBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers" | "gathering.locality" | "gathering.media.author" | "gathering.media.copyrightOwner" | "gathering.media.licenseId" | "gathering.media.mediaType" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "gathering.team.memberId" | "gathering.team.memberName" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.created" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.aggregateId" | "unit.linkings.originalTaxon.anamorphId" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.birdlifeCode" | "unit.linkings.originalTaxon.classId" | "unit.linkings.originalTaxon.cultivarId" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.divisionId" | "unit.linkings.originalTaxon.domainId" | "unit.linkings.originalTaxon.ecotypeId" | "unit.linkings.originalTaxon.euringCode" | "unit.linkings.originalTaxon.euringNumber" | "unit.linkings.originalTaxon.familyId" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.formId" | "unit.linkings.originalTaxon.genusId" | "unit.linkings.originalTaxon.grexId" | "unit.linkings.originalTaxon.groupId" | "unit.linkings.originalTaxon.habitats" | "unit.linkings.originalTaxon.hybridId" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.infraclassId" | "unit.linkings.originalTaxon.infradivisionId" | "unit.linkings.originalTaxon.infragenericHybridId" | "unit.linkings.originalTaxon.infragenericTaxonId" | "unit.linkings.originalTaxon.infrakingdomId" | "unit.linkings.originalTaxon.infraorderId" | "unit.linkings.originalTaxon.infraphylumId" | "unit.linkings.originalTaxon.infraspecificTaxonId" | "unit.linkings.originalTaxon.intergenericHybridId" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.kingdomId" | "unit.linkings.originalTaxon.nameAccordingTo" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.nothogenusId" | "unit.linkings.originalTaxon.nothospeciesId" | "unit.linkings.originalTaxon.nothosubspeciesId" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.orderId" | "unit.linkings.originalTaxon.parentId" | "unit.linkings.originalTaxon.parvclassId" | "unit.linkings.originalTaxon.parvorderId" | "unit.linkings.originalTaxon.phylumId" | "unit.linkings.originalTaxon.populationGroupId" | "unit.linkings.originalTaxon.primaryHabitat" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.redListStatusGroup" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sectionId" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.seriesId" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesAggregateId" | "unit.linkings.originalTaxon.speciesId" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.speciesTaxonomicOrder" | "unit.linkings.originalTaxon.subclassId" | "unit.linkings.originalTaxon.subdivisionId" | "unit.linkings.originalTaxon.subfamilyId" | "unit.linkings.originalTaxon.subformId" | "unit.linkings.originalTaxon.subgenusId" | "unit.linkings.originalTaxon.subkingdomId" | "unit.linkings.originalTaxon.suborderId" | "unit.linkings.originalTaxon.subphylumId" | "unit.linkings.originalTaxon.subsectionId" | "unit.linkings.originalTaxon.subseriesId" | "unit.linkings.originalTaxon.subspeciesId" | "unit.linkings.originalTaxon.subspecificAggregateId" | "unit.linkings.originalTaxon.subtribeId" | "unit.linkings.originalTaxon.subvarietyId" | "unit.linkings.originalTaxon.superclassId" | "unit.linkings.originalTaxon.superdivisionId" | "unit.linkings.originalTaxon.superdomainId" | "unit.linkings.originalTaxon.superfamilyId" | "unit.linkings.originalTaxon.supergenusId" | "unit.linkings.originalTaxon.superorderId" | "unit.linkings.originalTaxon.superphylumId" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonSets" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.tribeId" | "unit.linkings.originalTaxon.typesOfOccurrenceInFinland" | "unit.linkings.originalTaxon.varietyId" | "unit.linkings.originalTaxon.virva" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.aggregateId" | "unit.linkings.taxon.anamorphId" | "unit.linkings.taxon.author" | "unit.linkings.taxon.birdlifeCode" | "unit.linkings.taxon.classId" | "unit.linkings.taxon.cultivarId" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.divisionId" | "unit.linkings.taxon.domainId" | "unit.linkings.taxon.ecotypeId" | "unit.linkings.taxon.euringCode" | "unit.linkings.taxon.euringNumber" | "unit.linkings.taxon.familyId" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.formId" | "unit.linkings.taxon.genusId" | "unit.linkings.taxon.grexId" | "unit.linkings.taxon.groupId" | "unit.linkings.taxon.habitats" | "unit.linkings.taxon.hybridId" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.infraclassId" | "unit.linkings.taxon.infradivisionId" | "unit.linkings.taxon.infragenericHybridId" | "unit.linkings.taxon.infragenericTaxonId" | "unit.linkings.taxon.infrakingdomId" | "unit.linkings.taxon.infraorderId" | "unit.linkings.taxon.infraphylumId" | "unit.linkings.taxon.infraspecificTaxonId" | "unit.linkings.taxon.intergenericHybridId" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.kingdomId" | "unit.linkings.taxon.nameAccordingTo" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.nothogenusId" | "unit.linkings.taxon.nothospeciesId" | "unit.linkings.taxon.nothosubspeciesId" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.orderId" | "unit.linkings.taxon.parentId" | "unit.linkings.taxon.parvclassId" | "unit.linkings.taxon.parvorderId" | "unit.linkings.taxon.phylumId" | "unit.linkings.taxon.populationGroupId" | "unit.linkings.taxon.primaryHabitat" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.redListStatusGroup" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sectionId" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.seriesId" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesAggregateId" | "unit.linkings.taxon.speciesId" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.speciesTaxonomicOrder" | "unit.linkings.taxon.subclassId" | "unit.linkings.taxon.subdivisionId" | "unit.linkings.taxon.subfamilyId" | "unit.linkings.taxon.subformId" | "unit.linkings.taxon.subgenusId" | "unit.linkings.taxon.subkingdomId" | "unit.linkings.taxon.suborderId" | "unit.linkings.taxon.subphylumId" | "unit.linkings.taxon.subsectionId" | "unit.linkings.taxon.subseriesId" | "unit.linkings.taxon.subspeciesId" | "unit.linkings.taxon.subspecificAggregateId" | "unit.linkings.taxon.subtribeId" | "unit.linkings.taxon.subvarietyId" | "unit.linkings.taxon.superclassId" | "unit.linkings.taxon.superdivisionId" | "unit.linkings.taxon.superdomainId" | "unit.linkings.taxon.superfamilyId" | "unit.linkings.taxon.supergenusId" | "unit.linkings.taxon.superorderId" | "unit.linkings.taxon.superphylumId" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonSets" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.tribeId" | "unit.linkings.taxon.typesOfOccurrenceInFinland" | "unit.linkings.taxon.varietyId" | "unit.linkings.taxon.virva" | "unit.local" | "unit.media.author" | "unit.media.copyrightOwner" | "unit.media.licenseId" | "unit.media.mediaType" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild" | "count" | "individualCountSum" | "individualCountMax" | "oldestRecord" | "newestRecord" | "recordQualityMax" | "firstLoadDateMin" | "firstLoadDateMax" | "gatheringCount" | "securedCount" | "pairCountMax" | "pairCountSum" | "taxonCount" | "speciesCount" | "redListStatusMax" | "atlasCodeMax" | "atlasClassMax";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Return only count of rows (default) or also additional aggregate function values. */
                    onlyCount?: boolean;
                    /** @description Include taxon count, species count and max red list status */
                    taxonCounts?: boolean;
                    /** @description Include gatheringCount */
                    gatheringCounts?: boolean;
                    /** @description Include pair count sum and max. */
                    pairCounts?: boolean;
                    /** @description Include atlas code and class max. */
                    atlasCounts?: boolean;
                    /** @description Include or exclude nulls to result. Will only check nullness of the first aggregateBy field. */
                    excludeNulls?: boolean;
                    /** @description Value of this parameter affects how oldestRecord and newestRecord are calculated regarding observations reported as date span. False (default): oldest=min(date.begin), newest=max(date.end). True: oldest=min(date.end), newest=max(date.begin). */
                    pessimisticDateRangeHandling?: boolean;
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "csv" | "tsv";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_AggregateResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "text/csv": string;
                        "text/tab-separated-values": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/unit/statistics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Perform aggregate queries on units to PRIVATE side of the data warehouse.
         * @description  Functionality is same as normal /aggregate API except functionaly is limited to only certain collections, filters and aggregateBy fields. CollectionId filter is required and only certain collections are allowed.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define fields to aggregate by. Multiple values are seperated by ','. */
                    aggregateBy?: "document.documentId" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.day" | "gathering.conversions.month" | "gathering.conversions.year" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.gatheringSection" | "unit.atlasClass" | "unit.atlasCode" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.aggregateId" | "unit.linkings.originalTaxon.anamorphId" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.birdlifeCode" | "unit.linkings.originalTaxon.classId" | "unit.linkings.originalTaxon.cultivarId" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.divisionId" | "unit.linkings.originalTaxon.domainId" | "unit.linkings.originalTaxon.ecotypeId" | "unit.linkings.originalTaxon.euringCode" | "unit.linkings.originalTaxon.euringNumber" | "unit.linkings.originalTaxon.familyId" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.formId" | "unit.linkings.originalTaxon.genusId" | "unit.linkings.originalTaxon.grexId" | "unit.linkings.originalTaxon.groupId" | "unit.linkings.originalTaxon.habitats" | "unit.linkings.originalTaxon.hybridId" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.infraclassId" | "unit.linkings.originalTaxon.infradivisionId" | "unit.linkings.originalTaxon.infragenericHybridId" | "unit.linkings.originalTaxon.infragenericTaxonId" | "unit.linkings.originalTaxon.infrakingdomId" | "unit.linkings.originalTaxon.infraorderId" | "unit.linkings.originalTaxon.infraphylumId" | "unit.linkings.originalTaxon.infraspecificTaxonId" | "unit.linkings.originalTaxon.intergenericHybridId" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.kingdomId" | "unit.linkings.originalTaxon.nameAccordingTo" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.nothogenusId" | "unit.linkings.originalTaxon.nothospeciesId" | "unit.linkings.originalTaxon.nothosubspeciesId" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.orderId" | "unit.linkings.originalTaxon.parentId" | "unit.linkings.originalTaxon.parvclassId" | "unit.linkings.originalTaxon.parvorderId" | "unit.linkings.originalTaxon.phylumId" | "unit.linkings.originalTaxon.populationGroupId" | "unit.linkings.originalTaxon.primaryHabitat" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.redListStatusGroup" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sectionId" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.seriesId" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesAggregateId" | "unit.linkings.originalTaxon.speciesId" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.speciesTaxonomicOrder" | "unit.linkings.originalTaxon.subclassId" | "unit.linkings.originalTaxon.subdivisionId" | "unit.linkings.originalTaxon.subfamilyId" | "unit.linkings.originalTaxon.subformId" | "unit.linkings.originalTaxon.subgenusId" | "unit.linkings.originalTaxon.subkingdomId" | "unit.linkings.originalTaxon.suborderId" | "unit.linkings.originalTaxon.subphylumId" | "unit.linkings.originalTaxon.subsectionId" | "unit.linkings.originalTaxon.subseriesId" | "unit.linkings.originalTaxon.subspeciesId" | "unit.linkings.originalTaxon.subspecificAggregateId" | "unit.linkings.originalTaxon.subtribeId" | "unit.linkings.originalTaxon.subvarietyId" | "unit.linkings.originalTaxon.superclassId" | "unit.linkings.originalTaxon.superdivisionId" | "unit.linkings.originalTaxon.superdomainId" | "unit.linkings.originalTaxon.superfamilyId" | "unit.linkings.originalTaxon.supergenusId" | "unit.linkings.originalTaxon.superorderId" | "unit.linkings.originalTaxon.superphylumId" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonSets" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.tribeId" | "unit.linkings.originalTaxon.typesOfOccurrenceInFinland" | "unit.linkings.originalTaxon.varietyId" | "unit.linkings.originalTaxon.virva" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.aggregateId" | "unit.linkings.taxon.anamorphId" | "unit.linkings.taxon.author" | "unit.linkings.taxon.birdlifeCode" | "unit.linkings.taxon.classId" | "unit.linkings.taxon.cultivarId" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.divisionId" | "unit.linkings.taxon.domainId" | "unit.linkings.taxon.ecotypeId" | "unit.linkings.taxon.euringCode" | "unit.linkings.taxon.euringNumber" | "unit.linkings.taxon.familyId" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.formId" | "unit.linkings.taxon.genusId" | "unit.linkings.taxon.grexId" | "unit.linkings.taxon.groupId" | "unit.linkings.taxon.habitats" | "unit.linkings.taxon.hybridId" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.infraclassId" | "unit.linkings.taxon.infradivisionId" | "unit.linkings.taxon.infragenericHybridId" | "unit.linkings.taxon.infragenericTaxonId" | "unit.linkings.taxon.infrakingdomId" | "unit.linkings.taxon.infraorderId" | "unit.linkings.taxon.infraphylumId" | "unit.linkings.taxon.infraspecificTaxonId" | "unit.linkings.taxon.intergenericHybridId" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.kingdomId" | "unit.linkings.taxon.nameAccordingTo" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.nothogenusId" | "unit.linkings.taxon.nothospeciesId" | "unit.linkings.taxon.nothosubspeciesId" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.orderId" | "unit.linkings.taxon.parentId" | "unit.linkings.taxon.parvclassId" | "unit.linkings.taxon.parvorderId" | "unit.linkings.taxon.phylumId" | "unit.linkings.taxon.populationGroupId" | "unit.linkings.taxon.primaryHabitat" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.redListStatusGroup" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sectionId" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.seriesId" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesAggregateId" | "unit.linkings.taxon.speciesId" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.speciesTaxonomicOrder" | "unit.linkings.taxon.subclassId" | "unit.linkings.taxon.subdivisionId" | "unit.linkings.taxon.subfamilyId" | "unit.linkings.taxon.subformId" | "unit.linkings.taxon.subgenusId" | "unit.linkings.taxon.subkingdomId" | "unit.linkings.taxon.suborderId" | "unit.linkings.taxon.subphylumId" | "unit.linkings.taxon.subsectionId" | "unit.linkings.taxon.subseriesId" | "unit.linkings.taxon.subspeciesId" | "unit.linkings.taxon.subspecificAggregateId" | "unit.linkings.taxon.subtribeId" | "unit.linkings.taxon.subvarietyId" | "unit.linkings.taxon.superclassId" | "unit.linkings.taxon.superdivisionId" | "unit.linkings.taxon.superdomainId" | "unit.linkings.taxon.superfamilyId" | "unit.linkings.taxon.supergenusId" | "unit.linkings.taxon.superorderId" | "unit.linkings.taxon.superphylumId" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonSets" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.tribeId" | "unit.linkings.taxon.typesOfOccurrenceInFinland" | "unit.linkings.taxon.varietyId" | "unit.linkings.taxon.virva";
                    /** @description Define what fields to use when sorting results. Defaults to count (desc) and each aggregate by field (asc). Each fieldname given as parameter defaults to ASC - if you want to sort using descending order, add " DESC" to the end of the field name. In addition to aggregateBy fields you can use the following aggregate function names: [count, individualCountSum, individualCountMax, oldestRecord, newestRecord, recordQualityMax, firstLoadDateMin, firstLoadDateMax, gatheringCount, securedCount, pairCountMax, pairCountSum, taxonCount, speciesCount, redListStatusMax, atlasCodeMax, atlasClassMax]. Multiple values are seperated by ','. */
                    orderBy?: "document.documentId" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.day" | "gathering.conversions.month" | "gathering.conversions.year" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.gatheringSection" | "unit.atlasClass" | "unit.atlasCode" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.aggregateId" | "unit.linkings.originalTaxon.anamorphId" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.birdlifeCode" | "unit.linkings.originalTaxon.classId" | "unit.linkings.originalTaxon.cultivarId" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.divisionId" | "unit.linkings.originalTaxon.domainId" | "unit.linkings.originalTaxon.ecotypeId" | "unit.linkings.originalTaxon.euringCode" | "unit.linkings.originalTaxon.euringNumber" | "unit.linkings.originalTaxon.familyId" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.formId" | "unit.linkings.originalTaxon.genusId" | "unit.linkings.originalTaxon.grexId" | "unit.linkings.originalTaxon.groupId" | "unit.linkings.originalTaxon.habitats" | "unit.linkings.originalTaxon.hybridId" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.infraclassId" | "unit.linkings.originalTaxon.infradivisionId" | "unit.linkings.originalTaxon.infragenericHybridId" | "unit.linkings.originalTaxon.infragenericTaxonId" | "unit.linkings.originalTaxon.infrakingdomId" | "unit.linkings.originalTaxon.infraorderId" | "unit.linkings.originalTaxon.infraphylumId" | "unit.linkings.originalTaxon.infraspecificTaxonId" | "unit.linkings.originalTaxon.intergenericHybridId" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.kingdomId" | "unit.linkings.originalTaxon.nameAccordingTo" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.nothogenusId" | "unit.linkings.originalTaxon.nothospeciesId" | "unit.linkings.originalTaxon.nothosubspeciesId" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.orderId" | "unit.linkings.originalTaxon.parentId" | "unit.linkings.originalTaxon.parvclassId" | "unit.linkings.originalTaxon.parvorderId" | "unit.linkings.originalTaxon.phylumId" | "unit.linkings.originalTaxon.populationGroupId" | "unit.linkings.originalTaxon.primaryHabitat" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.redListStatusGroup" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sectionId" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.seriesId" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesAggregateId" | "unit.linkings.originalTaxon.speciesId" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.speciesTaxonomicOrder" | "unit.linkings.originalTaxon.subclassId" | "unit.linkings.originalTaxon.subdivisionId" | "unit.linkings.originalTaxon.subfamilyId" | "unit.linkings.originalTaxon.subformId" | "unit.linkings.originalTaxon.subgenusId" | "unit.linkings.originalTaxon.subkingdomId" | "unit.linkings.originalTaxon.suborderId" | "unit.linkings.originalTaxon.subphylumId" | "unit.linkings.originalTaxon.subsectionId" | "unit.linkings.originalTaxon.subseriesId" | "unit.linkings.originalTaxon.subspeciesId" | "unit.linkings.originalTaxon.subspecificAggregateId" | "unit.linkings.originalTaxon.subtribeId" | "unit.linkings.originalTaxon.subvarietyId" | "unit.linkings.originalTaxon.superclassId" | "unit.linkings.originalTaxon.superdivisionId" | "unit.linkings.originalTaxon.superdomainId" | "unit.linkings.originalTaxon.superfamilyId" | "unit.linkings.originalTaxon.supergenusId" | "unit.linkings.originalTaxon.superorderId" | "unit.linkings.originalTaxon.superphylumId" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonSets" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.tribeId" | "unit.linkings.originalTaxon.typesOfOccurrenceInFinland" | "unit.linkings.originalTaxon.varietyId" | "unit.linkings.originalTaxon.virva" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.aggregateId" | "unit.linkings.taxon.anamorphId" | "unit.linkings.taxon.author" | "unit.linkings.taxon.birdlifeCode" | "unit.linkings.taxon.classId" | "unit.linkings.taxon.cultivarId" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.divisionId" | "unit.linkings.taxon.domainId" | "unit.linkings.taxon.ecotypeId" | "unit.linkings.taxon.euringCode" | "unit.linkings.taxon.euringNumber" | "unit.linkings.taxon.familyId" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.formId" | "unit.linkings.taxon.genusId" | "unit.linkings.taxon.grexId" | "unit.linkings.taxon.groupId" | "unit.linkings.taxon.habitats" | "unit.linkings.taxon.hybridId" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.infraclassId" | "unit.linkings.taxon.infradivisionId" | "unit.linkings.taxon.infragenericHybridId" | "unit.linkings.taxon.infragenericTaxonId" | "unit.linkings.taxon.infrakingdomId" | "unit.linkings.taxon.infraorderId" | "unit.linkings.taxon.infraphylumId" | "unit.linkings.taxon.infraspecificTaxonId" | "unit.linkings.taxon.intergenericHybridId" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.kingdomId" | "unit.linkings.taxon.nameAccordingTo" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.nothogenusId" | "unit.linkings.taxon.nothospeciesId" | "unit.linkings.taxon.nothosubspeciesId" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.orderId" | "unit.linkings.taxon.parentId" | "unit.linkings.taxon.parvclassId" | "unit.linkings.taxon.parvorderId" | "unit.linkings.taxon.phylumId" | "unit.linkings.taxon.populationGroupId" | "unit.linkings.taxon.primaryHabitat" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.redListStatusGroup" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sectionId" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.seriesId" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesAggregateId" | "unit.linkings.taxon.speciesId" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.speciesTaxonomicOrder" | "unit.linkings.taxon.subclassId" | "unit.linkings.taxon.subdivisionId" | "unit.linkings.taxon.subfamilyId" | "unit.linkings.taxon.subformId" | "unit.linkings.taxon.subgenusId" | "unit.linkings.taxon.subkingdomId" | "unit.linkings.taxon.suborderId" | "unit.linkings.taxon.subphylumId" | "unit.linkings.taxon.subsectionId" | "unit.linkings.taxon.subseriesId" | "unit.linkings.taxon.subspeciesId" | "unit.linkings.taxon.subspecificAggregateId" | "unit.linkings.taxon.subtribeId" | "unit.linkings.taxon.subvarietyId" | "unit.linkings.taxon.superclassId" | "unit.linkings.taxon.superdivisionId" | "unit.linkings.taxon.superdomainId" | "unit.linkings.taxon.superfamilyId" | "unit.linkings.taxon.supergenusId" | "unit.linkings.taxon.superorderId" | "unit.linkings.taxon.superphylumId" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonSets" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.tribeId" | "unit.linkings.taxon.typesOfOccurrenceInFinland" | "unit.linkings.taxon.varietyId" | "unit.linkings.taxon.virva" | "count" | "individualCountSum" | "individualCountMax" | "oldestRecord" | "newestRecord" | "recordQualityMax" | "firstLoadDateMin" | "firstLoadDateMax" | "gatheringCount" | "securedCount" | "pairCountMax" | "pairCountSum" | "taxonCount" | "speciesCount" | "redListStatusMax" | "atlasCodeMax" | "atlasClassMax";
                    /** @description Return only count of rows (default) or also additional aggregate function values. */
                    onlyCount?: boolean;
                    /** @description Include taxon count, species count and max red list status */
                    taxonCounts?: boolean;
                    /** @description Include gatheringCount */
                    gatheringCounts?: boolean;
                    /** @description Include pair count sum and max. */
                    pairCounts?: boolean;
                    /** @description Include atlas code and class max. */
                    atlasCounts?: boolean;
                    /** @description Include or exclude nulls to result. Will only check nullness of the first aggregateBy field. */
                    excludeNulls?: boolean;
                    /** @description Value of this parameter affects how oldestRecord and newestRecord are calculated regarding observations reported as date span. False (default): oldest=min(date.begin), newest=max(date.end). True: oldest=min(date.end), newest=max(date.begin). */
                    pessimisticDateRangeHandling?: boolean;
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "csv" | "tsv";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_AggregateResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "text/csv": string;
                        "text/tab-separated-values": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/annotation/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get list of annotations using given filters
         * @description Get list of results as a 'flat row'. Application/json and application/xml responses respect the "selected" parameter, but application/rdf+xml returns always the same "CETAF standard" fields.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define what fields to include to the result. Defaults to [annotation.addedTags, annotation.annotationByPerson, annotation.annotationByPersonName, annotation.annotationBySystem, annotation.annotationBySystemName, annotation.byRole, annotation.created, annotation.deleted, annotation.deletedByPerson, annotation.deletedByPersonName, annotation.deletedDateTime, annotation.id, annotation.identification.author, annotation.identification.facts.decimalValue, annotation.identification.facts.fact, annotation.identification.facts.integerValue, annotation.identification.facts.value, annotation.identification.id, annotation.identification.linkings.taxon.administrativeStatuses, annotation.identification.linkings.taxon.checklist, annotation.identification.linkings.taxon.cursiveName, annotation.identification.linkings.taxon.finnish, annotation.identification.linkings.taxon.id, annotation.identification.linkings.taxon.informalTaxonGroups, annotation.identification.linkings.taxon.kingdomScientificName, annotation.identification.linkings.taxon.latestRedListStatusFinland.status, annotation.identification.linkings.taxon.latestRedListStatusFinland.year, annotation.identification.linkings.taxon.nameEnglish, annotation.identification.linkings.taxon.nameFinnish, annotation.identification.linkings.taxon.nameSwedish, annotation.identification.linkings.taxon.occurrenceCountFinland, annotation.identification.linkings.taxon.primaryHabitat.habitat, annotation.identification.linkings.taxon.primaryHabitat.habitatSpecificTypes, annotation.identification.linkings.taxon.primaryHabitat.id, annotation.identification.linkings.taxon.primaryHabitat.order, annotation.identification.linkings.taxon.scientificName, annotation.identification.linkings.taxon.scientificNameAuthorship, annotation.identification.linkings.taxon.scientificNameDisplayName, annotation.identification.linkings.taxon.sensitive, annotation.identification.linkings.taxon.taxonConceptIds, annotation.identification.linkings.taxon.taxonRank, annotation.identification.linkings.taxon.taxonomicOrder, annotation.identification.linkings.taxon.threatenedStatus, annotation.identification.linkings.taxon.vernacularName, annotation.identification.notes, annotation.identification.taxon, annotation.identification.taxonID, annotation.identification.taxonSpecifier, annotation.identification.taxonSpecifierAuthor, annotation.notes, annotation.occurrenceAtTimeOfAnnotation.countryVerbatim, annotation.occurrenceAtTimeOfAnnotation.dateBegin, annotation.occurrenceAtTimeOfAnnotation.dateEnd, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.administrativeStatuses, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.checklist, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.cursiveName, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.finnish, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.id, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.informalTaxonGroups, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.kingdomScientificName, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.status, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.year, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.nameEnglish, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.nameFinnish, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.nameSwedish, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.occurrenceCountFinland, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitat, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitatSpecificTypes, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.id, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.order, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificName, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameAuthorship, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameDisplayName, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.sensitive, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonConceptIds, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonRank, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonomicOrder, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.threatenedStatus, annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.vernacularName, annotation.occurrenceAtTimeOfAnnotation.locality, annotation.occurrenceAtTimeOfAnnotation.municipalityVerbatim, annotation.occurrenceAtTimeOfAnnotation.taxonId, annotation.occurrenceAtTimeOfAnnotation.taxonVerbatim, annotation.occurrenceAtTimeOfAnnotation.wgs84centerPointLat, annotation.occurrenceAtTimeOfAnnotation.wgs84centerPointLon, annotation.removedTags, annotation.valid, document.collectionId, document.documentId, gathering.displayDateTime, gathering.team, unit.linkings.originalTaxon.id, unit.linkings.originalTaxon.scientificName, unit.linkings.originalTaxon.vernacularName, unit.linkings.taxon.id, unit.linkings.taxon.scientificName, unit.linkings.taxon.vernacularName, unit.taxonVerbatim, unit.unitId] Multiple values are seperated by ','. */
                    selected?: "annotation.addedTags" | "annotation.annotationByPerson" | "annotation.annotationByPersonName" | "annotation.annotationBySystem" | "annotation.annotationBySystemName" | "annotation.byRole" | "annotation.created" | "annotation.deleted" | "annotation.deletedByPerson" | "annotation.deletedByPersonName" | "annotation.deletedDateTime" | "annotation.id" | "annotation.identification.author" | "annotation.identification.facts.decimalValue" | "annotation.identification.facts.fact" | "annotation.identification.facts.integerValue" | "annotation.identification.facts.value" | "annotation.identification.id" | "annotation.identification.linkings.taxon.administrativeStatuses" | "annotation.identification.linkings.taxon.checklist" | "annotation.identification.linkings.taxon.cursiveName" | "annotation.identification.linkings.taxon.finnish" | "annotation.identification.linkings.taxon.id" | "annotation.identification.linkings.taxon.informalTaxonGroups" | "annotation.identification.linkings.taxon.kingdomScientificName" | "annotation.identification.linkings.taxon.latestRedListStatusFinland.status" | "annotation.identification.linkings.taxon.latestRedListStatusFinland.year" | "annotation.identification.linkings.taxon.nameEnglish" | "annotation.identification.linkings.taxon.nameFinnish" | "annotation.identification.linkings.taxon.nameSwedish" | "annotation.identification.linkings.taxon.occurrenceCountFinland" | "annotation.identification.linkings.taxon.primaryHabitat.habitat" | "annotation.identification.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "annotation.identification.linkings.taxon.primaryHabitat.id" | "annotation.identification.linkings.taxon.primaryHabitat.order" | "annotation.identification.linkings.taxon.scientificName" | "annotation.identification.linkings.taxon.scientificNameAuthorship" | "annotation.identification.linkings.taxon.scientificNameDisplayName" | "annotation.identification.linkings.taxon.sensitive" | "annotation.identification.linkings.taxon.taxonConceptIds" | "annotation.identification.linkings.taxon.taxonRank" | "annotation.identification.linkings.taxon.taxonomicOrder" | "annotation.identification.linkings.taxon.threatenedStatus" | "annotation.identification.linkings.taxon.vernacularName" | "annotation.identification.notes" | "annotation.identification.taxon" | "annotation.identification.taxonID" | "annotation.identification.taxonSpecifier" | "annotation.identification.taxonSpecifierAuthor" | "annotation.notes" | "annotation.occurrenceAtTimeOfAnnotation.countryVerbatim" | "annotation.occurrenceAtTimeOfAnnotation.dateBegin" | "annotation.occurrenceAtTimeOfAnnotation.dateEnd" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.administrativeStatuses" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.checklist" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.cursiveName" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.finnish" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.id" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.informalTaxonGroups" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.kingdomScientificName" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.status" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.year" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.nameEnglish" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.nameFinnish" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.nameSwedish" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.occurrenceCountFinland" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitat" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.id" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.order" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificName" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameAuthorship" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameDisplayName" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.sensitive" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonConceptIds" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonRank" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonomicOrder" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.threatenedStatus" | "annotation.occurrenceAtTimeOfAnnotation.linkings.taxon.vernacularName" | "annotation.occurrenceAtTimeOfAnnotation.locality" | "annotation.occurrenceAtTimeOfAnnotation.municipalityVerbatim" | "annotation.occurrenceAtTimeOfAnnotation.taxonId" | "annotation.occurrenceAtTimeOfAnnotation.taxonVerbatim" | "annotation.occurrenceAtTimeOfAnnotation.wgs84centerPointLat" | "annotation.occurrenceAtTimeOfAnnotation.wgs84centerPointLon" | "annotation.removedTags" | "annotation.valid" | "document.annotations.addedTags" | "document.annotations.annotationByPerson" | "document.annotations.annotationByPersonName" | "document.annotations.annotationBySystem" | "document.annotations.annotationBySystemName" | "document.annotations.byRole" | "document.annotations.created" | "document.annotations.deleted" | "document.annotations.deletedByPerson" | "document.annotations.deletedByPersonName" | "document.annotations.deletedDateTime" | "document.annotations.id" | "document.annotations.notes" | "document.annotations.removedTags" | "document.annotations.valid" | "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors.fullName" | "document.linkings.editors.id" | "document.linkings.editors.userId" | "document.loadDate" | "document.media.author" | "document.media.caption" | "document.media.copyrightOwner" | "document.media.fullResolutionMediaAvailable" | "document.media.fullURL" | "document.media.highDetailModelURL" | "document.media.licenseId" | "document.media.lowDetailModelURL" | "document.media.mediaType" | "document.media.mp3URL" | "document.media.squareThumbnailURL" | "document.media.thumbnailURL" | "document.media.type" | "document.media.videoURL" | "document.media.wavURL" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.tags" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.notes" | "document.partial" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.message" | "document.quality.issue.source" | "document.referenceURL" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "document.sourceTags" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.eurefWKT" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.wgs84WKT" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.conversions.ykjWKT" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.biogeographicalProvinces" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipalities" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers.fullName" | "gathering.linkings.observers.id" | "gathering.linkings.observers.userId" | "gathering.locality" | "gathering.media.author" | "gathering.media.caption" | "gathering.media.copyrightOwner" | "gathering.media.fullResolutionMediaAvailable" | "gathering.media.fullURL" | "gathering.media.highDetailModelURL" | "gathering.media.licenseId" | "gathering.media.lowDetailModelURL" | "gathering.media.mediaType" | "gathering.media.mp3URL" | "gathering.media.squareThumbnailURL" | "gathering.media.thumbnailURL" | "gathering.media.type" | "gathering.media.videoURL" | "gathering.media.wavURL" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.notes" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.message" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.message" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.message" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.addedTags" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.byRole" | "unit.annotations.created" | "unit.annotations.deleted" | "unit.annotations.deletedByPerson" | "unit.annotations.deletedByPersonName" | "unit.annotations.deletedDateTime" | "unit.annotations.id" | "unit.annotations.identification.author" | "unit.annotations.identification.facts.decimalValue" | "unit.annotations.identification.facts.fact" | "unit.annotations.identification.facts.integerValue" | "unit.annotations.identification.facts.value" | "unit.annotations.identification.id" | "unit.annotations.identification.linkings.taxon.administrativeStatuses" | "unit.annotations.identification.linkings.taxon.checklist" | "unit.annotations.identification.linkings.taxon.cursiveName" | "unit.annotations.identification.linkings.taxon.finnish" | "unit.annotations.identification.linkings.taxon.id" | "unit.annotations.identification.linkings.taxon.informalTaxonGroups" | "unit.annotations.identification.linkings.taxon.kingdomScientificName" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.identification.linkings.taxon.nameEnglish" | "unit.annotations.identification.linkings.taxon.nameFinnish" | "unit.annotations.identification.linkings.taxon.nameSwedish" | "unit.annotations.identification.linkings.taxon.occurrenceCountFinland" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.identification.linkings.taxon.primaryHabitat.id" | "unit.annotations.identification.linkings.taxon.primaryHabitat.order" | "unit.annotations.identification.linkings.taxon.scientificName" | "unit.annotations.identification.linkings.taxon.scientificNameAuthorship" | "unit.annotations.identification.linkings.taxon.scientificNameDisplayName" | "unit.annotations.identification.linkings.taxon.sensitive" | "unit.annotations.identification.linkings.taxon.taxonConceptIds" | "unit.annotations.identification.linkings.taxon.taxonRank" | "unit.annotations.identification.linkings.taxon.taxonomicOrder" | "unit.annotations.identification.linkings.taxon.threatenedStatus" | "unit.annotations.identification.linkings.taxon.vernacularName" | "unit.annotations.identification.notes" | "unit.annotations.identification.taxon" | "unit.annotations.identification.taxonID" | "unit.annotations.identification.taxonSpecifier" | "unit.annotations.identification.taxonSpecifierAuthor" | "unit.annotations.notes" | "unit.annotations.occurrenceAtTimeOfAnnotation.countryVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateBegin" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateEnd" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.administrativeStatuses" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.checklist" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.cursiveName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.finnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.informalTaxonGroups" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.kingdomScientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameEnglish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameFinnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameSwedish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.occurrenceCountFinland" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.order" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameAuthorship" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameDisplayName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.sensitive" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonConceptIds" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonRank" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonomicOrder" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.threatenedStatus" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.vernacularName" | "unit.annotations.occurrenceAtTimeOfAnnotation.locality" | "unit.annotations.occurrenceAtTimeOfAnnotation.municipalityVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonId" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLat" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLon" | "unit.annotations.removedTags" | "unit.annotations.valid" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.externalMediaCount" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.identificationBasis" | "unit.identifications.author" | "unit.identifications.det" | "unit.identifications.detDate" | "unit.identifications.facts.decimalValue" | "unit.identifications.facts.fact" | "unit.identifications.facts.integerValue" | "unit.identifications.facts.value" | "unit.identifications.id" | "unit.identifications.linkings.taxon.administrativeStatuses" | "unit.identifications.linkings.taxon.checklist" | "unit.identifications.linkings.taxon.cursiveName" | "unit.identifications.linkings.taxon.finnish" | "unit.identifications.linkings.taxon.id" | "unit.identifications.linkings.taxon.informalTaxonGroups" | "unit.identifications.linkings.taxon.kingdomScientificName" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.status" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.year" | "unit.identifications.linkings.taxon.nameEnglish" | "unit.identifications.linkings.taxon.nameFinnish" | "unit.identifications.linkings.taxon.nameSwedish" | "unit.identifications.linkings.taxon.occurrenceCountFinland" | "unit.identifications.linkings.taxon.primaryHabitat.habitat" | "unit.identifications.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.identifications.linkings.taxon.primaryHabitat.id" | "unit.identifications.linkings.taxon.primaryHabitat.order" | "unit.identifications.linkings.taxon.scientificName" | "unit.identifications.linkings.taxon.scientificNameAuthorship" | "unit.identifications.linkings.taxon.scientificNameDisplayName" | "unit.identifications.linkings.taxon.sensitive" | "unit.identifications.linkings.taxon.taxonConceptIds" | "unit.identifications.linkings.taxon.taxonRank" | "unit.identifications.linkings.taxon.taxonomicOrder" | "unit.identifications.linkings.taxon.threatenedStatus" | "unit.identifications.linkings.taxon.vernacularName" | "unit.identifications.notes" | "unit.identifications.preferred" | "unit.identifications.taxon" | "unit.identifications.taxonID" | "unit.identifications.taxonSpecifier" | "unit.identifications.taxonSpecifierAuthor" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.checklist" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.kingdomScientificName" | "unit.linkings.originalTaxon.latestRedListStatusFinland.status" | "unit.linkings.originalTaxon.latestRedListStatusFinland.year" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.primaryHabitat.habitat" | "unit.linkings.originalTaxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.originalTaxon.primaryHabitat.id" | "unit.linkings.originalTaxon.primaryHabitat.order" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameAuthorship" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.taxonConceptIds" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.threatenedStatus" | "unit.linkings.originalTaxon.vernacularName" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.checklist" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.kingdomScientificName" | "unit.linkings.taxon.latestRedListStatusFinland.status" | "unit.linkings.taxon.latestRedListStatusFinland.year" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.primaryHabitat.habitat" | "unit.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.taxon.primaryHabitat.id" | "unit.linkings.taxon.primaryHabitat.order" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameAuthorship" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.taxonConceptIds" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.threatenedStatus" | "unit.linkings.taxon.vernacularName" | "unit.local" | "unit.media.author" | "unit.media.caption" | "unit.media.copyrightOwner" | "unit.media.fullResolutionMediaAvailable" | "unit.media.fullURL" | "unit.media.highDetailModelURL" | "unit.media.licenseId" | "unit.media.lowDetailModelURL" | "unit.media.mediaType" | "unit.media.mp3URL" | "unit.media.squareThumbnailURL" | "unit.media.thumbnailURL" | "unit.media.type" | "unit.media.videoURL" | "unit.media.wavURL" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.message" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.reportedTaxonId" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.notes" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.sourceTags" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.types.author" | "unit.types.basionymePublication" | "unit.types.facts.decimalValue" | "unit.types.facts.fact" | "unit.types.facts.integerValue" | "unit.types.facts.value" | "unit.types.id" | "unit.types.linkings.taxon.administrativeStatuses" | "unit.types.linkings.taxon.checklist" | "unit.types.linkings.taxon.cursiveName" | "unit.types.linkings.taxon.finnish" | "unit.types.linkings.taxon.id" | "unit.types.linkings.taxon.informalTaxonGroups" | "unit.types.linkings.taxon.kingdomScientificName" | "unit.types.linkings.taxon.latestRedListStatusFinland.status" | "unit.types.linkings.taxon.latestRedListStatusFinland.year" | "unit.types.linkings.taxon.nameEnglish" | "unit.types.linkings.taxon.nameFinnish" | "unit.types.linkings.taxon.nameSwedish" | "unit.types.linkings.taxon.occurrenceCountFinland" | "unit.types.linkings.taxon.primaryHabitat.habitat" | "unit.types.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.types.linkings.taxon.primaryHabitat.id" | "unit.types.linkings.taxon.primaryHabitat.order" | "unit.types.linkings.taxon.scientificName" | "unit.types.linkings.taxon.scientificNameAuthorship" | "unit.types.linkings.taxon.scientificNameDisplayName" | "unit.types.linkings.taxon.sensitive" | "unit.types.linkings.taxon.taxonConceptIds" | "unit.types.linkings.taxon.taxonRank" | "unit.types.linkings.taxon.taxonomicOrder" | "unit.types.linkings.taxon.threatenedStatus" | "unit.types.linkings.taxon.vernacularName" | "unit.types.notes" | "unit.types.publication" | "unit.types.status" | "unit.types.taxon" | "unit.types.taxonID" | "unit.types.taxonSpecifier" | "unit.types.taxonSpecifierAuthor" | "unit.types.typif" | "unit.types.typifDate" | "unit.types.verification" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild";
                    /** @description Define what fields to use when sorting results. Defaults to [unit.annotations.created DESC, unit.annotations.id ASC]. Unit key is always added as a last parameter to ensure correct paging. You can include ASC or DESC after the name of the field (defaults to ASC).Multiple values are seperated by ','. */
                    orderBy?: "RANDOM" | "RANDOM:seed" | "document.collectionId" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.firstLoadDate" | "document.linkings.collectionQuality" | "document.loadDate" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.name" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secured" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.biogeographicalProvince" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.locality" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.team" | "unit.abundanceString" | "unit.alive" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystemName" | "unit.annotations.created" | "unit.annotations.id" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.lifeStage" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.taxon.author" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.local" | "unit.mediaCount" | "unit.notes" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedTaxonConfidence" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.wild";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Include only those units/annotations that are of the selected annotation type. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    annotationType?: "ALL" | "USER_EFFECTIVE" | "USER_CHECK" | "DW_AUTO" | "ADMIN" | "FORM_ADMIN" | "INVASIVE_CONTROL" | "COMMENT" | "DELETED";
                    /** @description Include those annotations that are made by automated quality checks. Defaults to false. */
                    includeSystemAnnotations?: boolean;
                    /** @description Include only those annotations that have been made after or on the same date/timestamp. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. */
                    annotatedSameOrAfter?: string;
                    /** @description Include only those annotations that have been made before or on the same date/timestamp. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. */
                    annotatedSameOrBefore?: string;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "rdf_xml";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_ListResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "application/rdf+xml": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/unitMedia/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get list of unit_medias using given filters
         * @description Get list of results as a 'flat row'. Application/json and application/xml responses respect the "selected" parameter, but application/rdf+xml returns always the same "CETAF standard" fields.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define what fields to include to the result. Defaults to [document.documentId, media.author, media.caption, media.copyrightOwner, media.fullResolutionMediaAvailable, media.fullURL, media.highDetailModelURL, media.licenseId, media.lowDetailModelURL, media.mediaType, media.mp3URL, media.squareThumbnailURL, media.thumbnailURL, media.type, media.videoURL, media.wavURL, unit.linkings.taxon.scientificName, unit.linkings.taxon.vernacularName, unit.reportedInformalTaxonGroup, unit.taxonVerbatim, unit.unitId] Multiple values are seperated by ','. */
                    selected?: "document.annotations.addedTags" | "document.annotations.annotationByPerson" | "document.annotations.annotationByPersonName" | "document.annotations.annotationBySystem" | "document.annotations.annotationBySystemName" | "document.annotations.byRole" | "document.annotations.created" | "document.annotations.deleted" | "document.annotations.deletedByPerson" | "document.annotations.deletedByPersonName" | "document.annotations.deletedDateTime" | "document.annotations.id" | "document.annotations.notes" | "document.annotations.removedTags" | "document.annotations.valid" | "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors.fullName" | "document.linkings.editors.id" | "document.linkings.editors.userId" | "document.loadDate" | "document.media.author" | "document.media.caption" | "document.media.copyrightOwner" | "document.media.fullResolutionMediaAvailable" | "document.media.fullURL" | "document.media.highDetailModelURL" | "document.media.licenseId" | "document.media.lowDetailModelURL" | "document.media.mediaType" | "document.media.mp3URL" | "document.media.squareThumbnailURL" | "document.media.thumbnailURL" | "document.media.type" | "document.media.videoURL" | "document.media.wavURL" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.tags" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.notes" | "document.partial" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.message" | "document.quality.issue.source" | "document.referenceURL" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "document.sourceTags" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.eurefWKT" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.wgs84WKT" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.conversions.ykjWKT" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.biogeographicalProvinces" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipalities" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers.fullName" | "gathering.linkings.observers.id" | "gathering.linkings.observers.userId" | "gathering.locality" | "gathering.media.author" | "gathering.media.caption" | "gathering.media.copyrightOwner" | "gathering.media.fullResolutionMediaAvailable" | "gathering.media.fullURL" | "gathering.media.highDetailModelURL" | "gathering.media.licenseId" | "gathering.media.lowDetailModelURL" | "gathering.media.mediaType" | "gathering.media.mp3URL" | "gathering.media.squareThumbnailURL" | "gathering.media.thumbnailURL" | "gathering.media.type" | "gathering.media.videoURL" | "gathering.media.wavURL" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.notes" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.message" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.message" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.message" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "media.author" | "media.caption" | "media.copyrightOwner" | "media.fullResolutionMediaAvailable" | "media.fullURL" | "media.highDetailModelURL" | "media.licenseId" | "media.lowDetailModelURL" | "media.mediaType" | "media.mp3URL" | "media.squareThumbnailURL" | "media.thumbnailURL" | "media.type" | "media.videoURL" | "media.wavURL" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.addedTags" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.byRole" | "unit.annotations.created" | "unit.annotations.deleted" | "unit.annotations.deletedByPerson" | "unit.annotations.deletedByPersonName" | "unit.annotations.deletedDateTime" | "unit.annotations.id" | "unit.annotations.identification.author" | "unit.annotations.identification.facts.decimalValue" | "unit.annotations.identification.facts.fact" | "unit.annotations.identification.facts.integerValue" | "unit.annotations.identification.facts.value" | "unit.annotations.identification.id" | "unit.annotations.identification.linkings.taxon.administrativeStatuses" | "unit.annotations.identification.linkings.taxon.checklist" | "unit.annotations.identification.linkings.taxon.cursiveName" | "unit.annotations.identification.linkings.taxon.finnish" | "unit.annotations.identification.linkings.taxon.id" | "unit.annotations.identification.linkings.taxon.informalTaxonGroups" | "unit.annotations.identification.linkings.taxon.kingdomScientificName" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.identification.linkings.taxon.nameEnglish" | "unit.annotations.identification.linkings.taxon.nameFinnish" | "unit.annotations.identification.linkings.taxon.nameSwedish" | "unit.annotations.identification.linkings.taxon.occurrenceCountFinland" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.identification.linkings.taxon.primaryHabitat.id" | "unit.annotations.identification.linkings.taxon.primaryHabitat.order" | "unit.annotations.identification.linkings.taxon.scientificName" | "unit.annotations.identification.linkings.taxon.scientificNameAuthorship" | "unit.annotations.identification.linkings.taxon.scientificNameDisplayName" | "unit.annotations.identification.linkings.taxon.sensitive" | "unit.annotations.identification.linkings.taxon.taxonConceptIds" | "unit.annotations.identification.linkings.taxon.taxonRank" | "unit.annotations.identification.linkings.taxon.taxonomicOrder" | "unit.annotations.identification.linkings.taxon.threatenedStatus" | "unit.annotations.identification.linkings.taxon.vernacularName" | "unit.annotations.identification.notes" | "unit.annotations.identification.taxon" | "unit.annotations.identification.taxonID" | "unit.annotations.identification.taxonSpecifier" | "unit.annotations.identification.taxonSpecifierAuthor" | "unit.annotations.notes" | "unit.annotations.occurrenceAtTimeOfAnnotation.countryVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateBegin" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateEnd" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.administrativeStatuses" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.checklist" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.cursiveName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.finnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.informalTaxonGroups" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.kingdomScientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameEnglish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameFinnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameSwedish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.occurrenceCountFinland" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.order" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameAuthorship" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameDisplayName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.sensitive" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonConceptIds" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonRank" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonomicOrder" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.threatenedStatus" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.vernacularName" | "unit.annotations.occurrenceAtTimeOfAnnotation.locality" | "unit.annotations.occurrenceAtTimeOfAnnotation.municipalityVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonId" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLat" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLon" | "unit.annotations.removedTags" | "unit.annotations.valid" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.externalMediaCount" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.identificationBasis" | "unit.identifications.author" | "unit.identifications.det" | "unit.identifications.detDate" | "unit.identifications.facts.decimalValue" | "unit.identifications.facts.fact" | "unit.identifications.facts.integerValue" | "unit.identifications.facts.value" | "unit.identifications.id" | "unit.identifications.linkings.taxon.administrativeStatuses" | "unit.identifications.linkings.taxon.checklist" | "unit.identifications.linkings.taxon.cursiveName" | "unit.identifications.linkings.taxon.finnish" | "unit.identifications.linkings.taxon.id" | "unit.identifications.linkings.taxon.informalTaxonGroups" | "unit.identifications.linkings.taxon.kingdomScientificName" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.status" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.year" | "unit.identifications.linkings.taxon.nameEnglish" | "unit.identifications.linkings.taxon.nameFinnish" | "unit.identifications.linkings.taxon.nameSwedish" | "unit.identifications.linkings.taxon.occurrenceCountFinland" | "unit.identifications.linkings.taxon.primaryHabitat.habitat" | "unit.identifications.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.identifications.linkings.taxon.primaryHabitat.id" | "unit.identifications.linkings.taxon.primaryHabitat.order" | "unit.identifications.linkings.taxon.scientificName" | "unit.identifications.linkings.taxon.scientificNameAuthorship" | "unit.identifications.linkings.taxon.scientificNameDisplayName" | "unit.identifications.linkings.taxon.sensitive" | "unit.identifications.linkings.taxon.taxonConceptIds" | "unit.identifications.linkings.taxon.taxonRank" | "unit.identifications.linkings.taxon.taxonomicOrder" | "unit.identifications.linkings.taxon.threatenedStatus" | "unit.identifications.linkings.taxon.vernacularName" | "unit.identifications.notes" | "unit.identifications.preferred" | "unit.identifications.taxon" | "unit.identifications.taxonID" | "unit.identifications.taxonSpecifier" | "unit.identifications.taxonSpecifierAuthor" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.checklist" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.kingdomScientificName" | "unit.linkings.originalTaxon.latestRedListStatusFinland.status" | "unit.linkings.originalTaxon.latestRedListStatusFinland.year" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.primaryHabitat.habitat" | "unit.linkings.originalTaxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.originalTaxon.primaryHabitat.id" | "unit.linkings.originalTaxon.primaryHabitat.order" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameAuthorship" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.taxonConceptIds" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.threatenedStatus" | "unit.linkings.originalTaxon.vernacularName" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.checklist" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.kingdomScientificName" | "unit.linkings.taxon.latestRedListStatusFinland.status" | "unit.linkings.taxon.latestRedListStatusFinland.year" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.primaryHabitat.habitat" | "unit.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.taxon.primaryHabitat.id" | "unit.linkings.taxon.primaryHabitat.order" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameAuthorship" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.taxonConceptIds" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.threatenedStatus" | "unit.linkings.taxon.vernacularName" | "unit.local" | "unit.media.author" | "unit.media.caption" | "unit.media.copyrightOwner" | "unit.media.fullResolutionMediaAvailable" | "unit.media.fullURL" | "unit.media.highDetailModelURL" | "unit.media.licenseId" | "unit.media.lowDetailModelURL" | "unit.media.mediaType" | "unit.media.mp3URL" | "unit.media.squareThumbnailURL" | "unit.media.thumbnailURL" | "unit.media.type" | "unit.media.videoURL" | "unit.media.wavURL" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.message" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.reportedTaxonId" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.notes" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.sourceTags" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.types.author" | "unit.types.basionymePublication" | "unit.types.facts.decimalValue" | "unit.types.facts.fact" | "unit.types.facts.integerValue" | "unit.types.facts.value" | "unit.types.id" | "unit.types.linkings.taxon.administrativeStatuses" | "unit.types.linkings.taxon.checklist" | "unit.types.linkings.taxon.cursiveName" | "unit.types.linkings.taxon.finnish" | "unit.types.linkings.taxon.id" | "unit.types.linkings.taxon.informalTaxonGroups" | "unit.types.linkings.taxon.kingdomScientificName" | "unit.types.linkings.taxon.latestRedListStatusFinland.status" | "unit.types.linkings.taxon.latestRedListStatusFinland.year" | "unit.types.linkings.taxon.nameEnglish" | "unit.types.linkings.taxon.nameFinnish" | "unit.types.linkings.taxon.nameSwedish" | "unit.types.linkings.taxon.occurrenceCountFinland" | "unit.types.linkings.taxon.primaryHabitat.habitat" | "unit.types.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.types.linkings.taxon.primaryHabitat.id" | "unit.types.linkings.taxon.primaryHabitat.order" | "unit.types.linkings.taxon.scientificName" | "unit.types.linkings.taxon.scientificNameAuthorship" | "unit.types.linkings.taxon.scientificNameDisplayName" | "unit.types.linkings.taxon.sensitive" | "unit.types.linkings.taxon.taxonConceptIds" | "unit.types.linkings.taxon.taxonRank" | "unit.types.linkings.taxon.taxonomicOrder" | "unit.types.linkings.taxon.threatenedStatus" | "unit.types.linkings.taxon.vernacularName" | "unit.types.notes" | "unit.types.publication" | "unit.types.status" | "unit.types.taxon" | "unit.types.taxonID" | "unit.types.taxonSpecifier" | "unit.types.taxonSpecifierAuthor" | "unit.types.typif" | "unit.types.typifDate" | "unit.types.verification" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild";
                    /** @description Define what fields to use when sorting results. Defaults to [gathering.eventDate.begin DESC, document.loadDate DESC, unit.taxonVerbatim ASC, unit.media.mediaType ASC, unit.media.fullURL ASC]. Unit key is always added as a last parameter to ensure correct paging. You can include ASC or DESC after the name of the field (defaults to ASC).Multiple values are seperated by ','. */
                    orderBy?: "RANDOM" | "RANDOM:seed" | "document.collectionId" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.firstLoadDate" | "document.linkings.collectionQuality" | "document.loadDate" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.name" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secured" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.biogeographicalProvince" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.locality" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.team" | "unit.abundanceString" | "unit.alive" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.lifeStage" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.taxon.author" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.local" | "unit.media.fullURL" | "unit.media.mediaType" | "unit.mediaCount" | "unit.notes" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedTaxonConfidence" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.wild";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "rdf_xml";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_ListResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "application/rdf+xml": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/sample/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get list of samples using given filters
         * @description Get list of results as a 'flat row'. Application/json and application/xml responses respect the "selected" parameter, but application/rdf+xml returns always the same "CETAF standard" fields.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define what fields to include to the result. Defaults to [document.documentId, sample.collectionId, sample.facts.decimalValue, sample.facts.fact, sample.facts.integerValue, sample.facts.value, sample.keywords, sample.material, sample.multiple, sample.notes, sample.quality, sample.sampleId, sample.sampleOrder, sample.status, sample.type, unit.linkings.taxon.id, unit.linkings.taxon.scientificName, unit.taxonVerbatim, unit.unitId] Multiple values are seperated by ','. */
                    selected?: "document.annotations.addedTags" | "document.annotations.annotationByPerson" | "document.annotations.annotationByPersonName" | "document.annotations.annotationBySystem" | "document.annotations.annotationBySystemName" | "document.annotations.byRole" | "document.annotations.created" | "document.annotations.deleted" | "document.annotations.deletedByPerson" | "document.annotations.deletedByPersonName" | "document.annotations.deletedDateTime" | "document.annotations.id" | "document.annotations.notes" | "document.annotations.removedTags" | "document.annotations.valid" | "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors.fullName" | "document.linkings.editors.id" | "document.linkings.editors.userId" | "document.loadDate" | "document.media.author" | "document.media.caption" | "document.media.copyrightOwner" | "document.media.fullResolutionMediaAvailable" | "document.media.fullURL" | "document.media.highDetailModelURL" | "document.media.licenseId" | "document.media.lowDetailModelURL" | "document.media.mediaType" | "document.media.mp3URL" | "document.media.squareThumbnailURL" | "document.media.thumbnailURL" | "document.media.type" | "document.media.videoURL" | "document.media.wavURL" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.tags" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.notes" | "document.partial" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.message" | "document.quality.issue.source" | "document.referenceURL" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "document.sourceTags" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.eurefWKT" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.wgs84WKT" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.conversions.ykjWKT" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.biogeographicalProvinces" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipalities" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers.fullName" | "gathering.linkings.observers.id" | "gathering.linkings.observers.userId" | "gathering.locality" | "gathering.media.author" | "gathering.media.caption" | "gathering.media.copyrightOwner" | "gathering.media.fullResolutionMediaAvailable" | "gathering.media.fullURL" | "gathering.media.highDetailModelURL" | "gathering.media.licenseId" | "gathering.media.lowDetailModelURL" | "gathering.media.mediaType" | "gathering.media.mp3URL" | "gathering.media.squareThumbnailURL" | "gathering.media.thumbnailURL" | "gathering.media.type" | "gathering.media.videoURL" | "gathering.media.wavURL" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.notes" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.message" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.message" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.message" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "sample.collectionId" | "sample.facts.decimalValue" | "sample.facts.fact" | "sample.facts.integerValue" | "sample.facts.value" | "sample.keywords" | "sample.material" | "sample.multiple" | "sample.notes" | "sample.quality" | "sample.sampleId" | "sample.sampleOrder" | "sample.status" | "sample.type" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.addedTags" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.byRole" | "unit.annotations.created" | "unit.annotations.deleted" | "unit.annotations.deletedByPerson" | "unit.annotations.deletedByPersonName" | "unit.annotations.deletedDateTime" | "unit.annotations.id" | "unit.annotations.identification.author" | "unit.annotations.identification.facts.decimalValue" | "unit.annotations.identification.facts.fact" | "unit.annotations.identification.facts.integerValue" | "unit.annotations.identification.facts.value" | "unit.annotations.identification.id" | "unit.annotations.identification.linkings.taxon.administrativeStatuses" | "unit.annotations.identification.linkings.taxon.checklist" | "unit.annotations.identification.linkings.taxon.cursiveName" | "unit.annotations.identification.linkings.taxon.finnish" | "unit.annotations.identification.linkings.taxon.id" | "unit.annotations.identification.linkings.taxon.informalTaxonGroups" | "unit.annotations.identification.linkings.taxon.kingdomScientificName" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.identification.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.identification.linkings.taxon.nameEnglish" | "unit.annotations.identification.linkings.taxon.nameFinnish" | "unit.annotations.identification.linkings.taxon.nameSwedish" | "unit.annotations.identification.linkings.taxon.occurrenceCountFinland" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.identification.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.identification.linkings.taxon.primaryHabitat.id" | "unit.annotations.identification.linkings.taxon.primaryHabitat.order" | "unit.annotations.identification.linkings.taxon.scientificName" | "unit.annotations.identification.linkings.taxon.scientificNameAuthorship" | "unit.annotations.identification.linkings.taxon.scientificNameDisplayName" | "unit.annotations.identification.linkings.taxon.sensitive" | "unit.annotations.identification.linkings.taxon.taxonConceptIds" | "unit.annotations.identification.linkings.taxon.taxonRank" | "unit.annotations.identification.linkings.taxon.taxonomicOrder" | "unit.annotations.identification.linkings.taxon.threatenedStatus" | "unit.annotations.identification.linkings.taxon.vernacularName" | "unit.annotations.identification.notes" | "unit.annotations.identification.taxon" | "unit.annotations.identification.taxonID" | "unit.annotations.identification.taxonSpecifier" | "unit.annotations.identification.taxonSpecifierAuthor" | "unit.annotations.notes" | "unit.annotations.occurrenceAtTimeOfAnnotation.countryVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateBegin" | "unit.annotations.occurrenceAtTimeOfAnnotation.dateEnd" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.administrativeStatuses" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.checklist" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.cursiveName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.finnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.informalTaxonGroups" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.kingdomScientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.status" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.latestRedListStatusFinland.year" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameEnglish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameFinnish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.nameSwedish" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.occurrenceCountFinland" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitat" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.id" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.primaryHabitat.order" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameAuthorship" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.scientificNameDisplayName" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.sensitive" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonConceptIds" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonRank" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.taxonomicOrder" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.threatenedStatus" | "unit.annotations.occurrenceAtTimeOfAnnotation.linkings.taxon.vernacularName" | "unit.annotations.occurrenceAtTimeOfAnnotation.locality" | "unit.annotations.occurrenceAtTimeOfAnnotation.municipalityVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonId" | "unit.annotations.occurrenceAtTimeOfAnnotation.taxonVerbatim" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLat" | "unit.annotations.occurrenceAtTimeOfAnnotation.wgs84centerPointLon" | "unit.annotations.removedTags" | "unit.annotations.valid" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.externalMediaCount" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.identificationBasis" | "unit.identifications.author" | "unit.identifications.det" | "unit.identifications.detDate" | "unit.identifications.facts.decimalValue" | "unit.identifications.facts.fact" | "unit.identifications.facts.integerValue" | "unit.identifications.facts.value" | "unit.identifications.id" | "unit.identifications.linkings.taxon.administrativeStatuses" | "unit.identifications.linkings.taxon.checklist" | "unit.identifications.linkings.taxon.cursiveName" | "unit.identifications.linkings.taxon.finnish" | "unit.identifications.linkings.taxon.id" | "unit.identifications.linkings.taxon.informalTaxonGroups" | "unit.identifications.linkings.taxon.kingdomScientificName" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.status" | "unit.identifications.linkings.taxon.latestRedListStatusFinland.year" | "unit.identifications.linkings.taxon.nameEnglish" | "unit.identifications.linkings.taxon.nameFinnish" | "unit.identifications.linkings.taxon.nameSwedish" | "unit.identifications.linkings.taxon.occurrenceCountFinland" | "unit.identifications.linkings.taxon.primaryHabitat.habitat" | "unit.identifications.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.identifications.linkings.taxon.primaryHabitat.id" | "unit.identifications.linkings.taxon.primaryHabitat.order" | "unit.identifications.linkings.taxon.scientificName" | "unit.identifications.linkings.taxon.scientificNameAuthorship" | "unit.identifications.linkings.taxon.scientificNameDisplayName" | "unit.identifications.linkings.taxon.sensitive" | "unit.identifications.linkings.taxon.taxonConceptIds" | "unit.identifications.linkings.taxon.taxonRank" | "unit.identifications.linkings.taxon.taxonomicOrder" | "unit.identifications.linkings.taxon.threatenedStatus" | "unit.identifications.linkings.taxon.vernacularName" | "unit.identifications.notes" | "unit.identifications.preferred" | "unit.identifications.taxon" | "unit.identifications.taxonID" | "unit.identifications.taxonSpecifier" | "unit.identifications.taxonSpecifierAuthor" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.checklist" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.kingdomScientificName" | "unit.linkings.originalTaxon.latestRedListStatusFinland.status" | "unit.linkings.originalTaxon.latestRedListStatusFinland.year" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.primaryHabitat.habitat" | "unit.linkings.originalTaxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.originalTaxon.primaryHabitat.id" | "unit.linkings.originalTaxon.primaryHabitat.order" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameAuthorship" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.taxonConceptIds" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.threatenedStatus" | "unit.linkings.originalTaxon.vernacularName" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.checklist" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.kingdomScientificName" | "unit.linkings.taxon.latestRedListStatusFinland.status" | "unit.linkings.taxon.latestRedListStatusFinland.year" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.primaryHabitat.habitat" | "unit.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.linkings.taxon.primaryHabitat.id" | "unit.linkings.taxon.primaryHabitat.order" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameAuthorship" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.taxonConceptIds" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.threatenedStatus" | "unit.linkings.taxon.vernacularName" | "unit.local" | "unit.media.author" | "unit.media.caption" | "unit.media.copyrightOwner" | "unit.media.fullResolutionMediaAvailable" | "unit.media.fullURL" | "unit.media.highDetailModelURL" | "unit.media.licenseId" | "unit.media.lowDetailModelURL" | "unit.media.mediaType" | "unit.media.mp3URL" | "unit.media.squareThumbnailURL" | "unit.media.thumbnailURL" | "unit.media.type" | "unit.media.videoURL" | "unit.media.wavURL" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.message" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.reportedTaxonId" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.notes" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.sourceTags" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.types.author" | "unit.types.basionymePublication" | "unit.types.facts.decimalValue" | "unit.types.facts.fact" | "unit.types.facts.integerValue" | "unit.types.facts.value" | "unit.types.id" | "unit.types.linkings.taxon.administrativeStatuses" | "unit.types.linkings.taxon.checklist" | "unit.types.linkings.taxon.cursiveName" | "unit.types.linkings.taxon.finnish" | "unit.types.linkings.taxon.id" | "unit.types.linkings.taxon.informalTaxonGroups" | "unit.types.linkings.taxon.kingdomScientificName" | "unit.types.linkings.taxon.latestRedListStatusFinland.status" | "unit.types.linkings.taxon.latestRedListStatusFinland.year" | "unit.types.linkings.taxon.nameEnglish" | "unit.types.linkings.taxon.nameFinnish" | "unit.types.linkings.taxon.nameSwedish" | "unit.types.linkings.taxon.occurrenceCountFinland" | "unit.types.linkings.taxon.primaryHabitat.habitat" | "unit.types.linkings.taxon.primaryHabitat.habitatSpecificTypes" | "unit.types.linkings.taxon.primaryHabitat.id" | "unit.types.linkings.taxon.primaryHabitat.order" | "unit.types.linkings.taxon.scientificName" | "unit.types.linkings.taxon.scientificNameAuthorship" | "unit.types.linkings.taxon.scientificNameDisplayName" | "unit.types.linkings.taxon.sensitive" | "unit.types.linkings.taxon.taxonConceptIds" | "unit.types.linkings.taxon.taxonRank" | "unit.types.linkings.taxon.taxonomicOrder" | "unit.types.linkings.taxon.threatenedStatus" | "unit.types.linkings.taxon.vernacularName" | "unit.types.notes" | "unit.types.publication" | "unit.types.status" | "unit.types.taxon" | "unit.types.taxonID" | "unit.types.taxonSpecifier" | "unit.types.taxonSpecifierAuthor" | "unit.types.typif" | "unit.types.typifDate" | "unit.types.verification" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild";
                    /** @description Define what fields to use when sorting results. Defaults to [unit.taxonVerbatim ASC, unit.unitId ASC, unit.samples.sampleOrder ASC]. Unit key is always added as a last parameter to ensure correct paging. You can include ASC or DESC after the name of the field (defaults to ASC).Multiple values are seperated by ','. */
                    orderBy?: "RANDOM" | "RANDOM:seed" | "document.collectionId" | "document.createdDate" | "document.dataSource" | "document.documentId" | "document.firstLoadDate" | "document.linkings.collectionQuality" | "document.loadDate" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.name" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secured" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.biogeographicalProvince" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.locality" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.team" | "unit.abundanceString" | "unit.alive" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.lifeStage" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.taxon.author" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonomicOrder" | "unit.local" | "unit.mediaCount" | "unit.notes" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedTaxonConfidence" | "unit.samples.collectionId" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.wild";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using preparation/sample ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sampleId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    sampleCollectionId?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Was DNA extracted from single or multiple individuals? Include only those that were (true) or weren't (false). */
                    sampleMultiple?: boolean;
                    /** @description Filter based on URI or Qname identifier of MF.preparationTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MF.preparationTypeEnum */
                    sampleType?: string;
                    /** @description Filter based on URI or Qname identifier of MF.qualityEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MF.qualityEnum */
                    sampleQuality?: string;
                    /** @description Filter based on URI or Qname identifier of MY.statuses (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.statuses */
                    sampleStatus?: string;
                    /** @description Filter based on URI or Qname identifier of MY.statuses (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MF.materialEnum */
                    sampleMaterial?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    sampleFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "rdf_xml";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_ListResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "application/rdf+xml": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/query/annotation/aggregate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Perform aggregate queries (group by) on annotations.
         * @description Aggregates the results of the query based on given "aggregateBy" parameters. Always includes count of rows (count(*)) to the result. Other aggregate functions vary based on the given parameters. Possible aggregate functions are [count, individualCountSum, individualCountMax, oldestRecord, newestRecord, recordQualityMax, firstLoadDateMin, firstLoadDateMax, gatheringCount, securedCount, pairCountMax, pairCountSum, taxonCount, speciesCount, redListStatusMax, atlasCodeMax, atlasClassMax]
         */
        get: {
            parameters: {
                query?: {
                    /** @description Define fields to aggregate by. Multiple values are seperated by ','. */
                    aggregateBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers" | "gathering.locality" | "gathering.media.author" | "gathering.media.copyrightOwner" | "gathering.media.licenseId" | "gathering.media.mediaType" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "gathering.team.memberId" | "gathering.team.memberName" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.created" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.aggregateId" | "unit.linkings.originalTaxon.anamorphId" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.birdlifeCode" | "unit.linkings.originalTaxon.classId" | "unit.linkings.originalTaxon.cultivarId" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.divisionId" | "unit.linkings.originalTaxon.domainId" | "unit.linkings.originalTaxon.ecotypeId" | "unit.linkings.originalTaxon.euringCode" | "unit.linkings.originalTaxon.euringNumber" | "unit.linkings.originalTaxon.familyId" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.formId" | "unit.linkings.originalTaxon.genusId" | "unit.linkings.originalTaxon.grexId" | "unit.linkings.originalTaxon.groupId" | "unit.linkings.originalTaxon.habitats" | "unit.linkings.originalTaxon.hybridId" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.infraclassId" | "unit.linkings.originalTaxon.infradivisionId" | "unit.linkings.originalTaxon.infragenericHybridId" | "unit.linkings.originalTaxon.infragenericTaxonId" | "unit.linkings.originalTaxon.infrakingdomId" | "unit.linkings.originalTaxon.infraorderId" | "unit.linkings.originalTaxon.infraphylumId" | "unit.linkings.originalTaxon.infraspecificTaxonId" | "unit.linkings.originalTaxon.intergenericHybridId" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.kingdomId" | "unit.linkings.originalTaxon.nameAccordingTo" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.nothogenusId" | "unit.linkings.originalTaxon.nothospeciesId" | "unit.linkings.originalTaxon.nothosubspeciesId" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.orderId" | "unit.linkings.originalTaxon.parentId" | "unit.linkings.originalTaxon.parvclassId" | "unit.linkings.originalTaxon.parvorderId" | "unit.linkings.originalTaxon.phylumId" | "unit.linkings.originalTaxon.populationGroupId" | "unit.linkings.originalTaxon.primaryHabitat" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.redListStatusGroup" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sectionId" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.seriesId" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesAggregateId" | "unit.linkings.originalTaxon.speciesId" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.speciesTaxonomicOrder" | "unit.linkings.originalTaxon.subclassId" | "unit.linkings.originalTaxon.subdivisionId" | "unit.linkings.originalTaxon.subfamilyId" | "unit.linkings.originalTaxon.subformId" | "unit.linkings.originalTaxon.subgenusId" | "unit.linkings.originalTaxon.subkingdomId" | "unit.linkings.originalTaxon.suborderId" | "unit.linkings.originalTaxon.subphylumId" | "unit.linkings.originalTaxon.subsectionId" | "unit.linkings.originalTaxon.subseriesId" | "unit.linkings.originalTaxon.subspeciesId" | "unit.linkings.originalTaxon.subspecificAggregateId" | "unit.linkings.originalTaxon.subtribeId" | "unit.linkings.originalTaxon.subvarietyId" | "unit.linkings.originalTaxon.superclassId" | "unit.linkings.originalTaxon.superdivisionId" | "unit.linkings.originalTaxon.superdomainId" | "unit.linkings.originalTaxon.superfamilyId" | "unit.linkings.originalTaxon.supergenusId" | "unit.linkings.originalTaxon.superorderId" | "unit.linkings.originalTaxon.superphylumId" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonSets" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.tribeId" | "unit.linkings.originalTaxon.typesOfOccurrenceInFinland" | "unit.linkings.originalTaxon.varietyId" | "unit.linkings.originalTaxon.virva" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.aggregateId" | "unit.linkings.taxon.anamorphId" | "unit.linkings.taxon.author" | "unit.linkings.taxon.birdlifeCode" | "unit.linkings.taxon.classId" | "unit.linkings.taxon.cultivarId" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.divisionId" | "unit.linkings.taxon.domainId" | "unit.linkings.taxon.ecotypeId" | "unit.linkings.taxon.euringCode" | "unit.linkings.taxon.euringNumber" | "unit.linkings.taxon.familyId" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.formId" | "unit.linkings.taxon.genusId" | "unit.linkings.taxon.grexId" | "unit.linkings.taxon.groupId" | "unit.linkings.taxon.habitats" | "unit.linkings.taxon.hybridId" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.infraclassId" | "unit.linkings.taxon.infradivisionId" | "unit.linkings.taxon.infragenericHybridId" | "unit.linkings.taxon.infragenericTaxonId" | "unit.linkings.taxon.infrakingdomId" | "unit.linkings.taxon.infraorderId" | "unit.linkings.taxon.infraphylumId" | "unit.linkings.taxon.infraspecificTaxonId" | "unit.linkings.taxon.intergenericHybridId" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.kingdomId" | "unit.linkings.taxon.nameAccordingTo" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.nothogenusId" | "unit.linkings.taxon.nothospeciesId" | "unit.linkings.taxon.nothosubspeciesId" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.orderId" | "unit.linkings.taxon.parentId" | "unit.linkings.taxon.parvclassId" | "unit.linkings.taxon.parvorderId" | "unit.linkings.taxon.phylumId" | "unit.linkings.taxon.populationGroupId" | "unit.linkings.taxon.primaryHabitat" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.redListStatusGroup" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sectionId" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.seriesId" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesAggregateId" | "unit.linkings.taxon.speciesId" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.speciesTaxonomicOrder" | "unit.linkings.taxon.subclassId" | "unit.linkings.taxon.subdivisionId" | "unit.linkings.taxon.subfamilyId" | "unit.linkings.taxon.subformId" | "unit.linkings.taxon.subgenusId" | "unit.linkings.taxon.subkingdomId" | "unit.linkings.taxon.suborderId" | "unit.linkings.taxon.subphylumId" | "unit.linkings.taxon.subsectionId" | "unit.linkings.taxon.subseriesId" | "unit.linkings.taxon.subspeciesId" | "unit.linkings.taxon.subspecificAggregateId" | "unit.linkings.taxon.subtribeId" | "unit.linkings.taxon.subvarietyId" | "unit.linkings.taxon.superclassId" | "unit.linkings.taxon.superdivisionId" | "unit.linkings.taxon.superdomainId" | "unit.linkings.taxon.superfamilyId" | "unit.linkings.taxon.supergenusId" | "unit.linkings.taxon.superorderId" | "unit.linkings.taxon.superphylumId" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonSets" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.tribeId" | "unit.linkings.taxon.typesOfOccurrenceInFinland" | "unit.linkings.taxon.varietyId" | "unit.linkings.taxon.virva" | "unit.local" | "unit.media.author" | "unit.media.copyrightOwner" | "unit.media.licenseId" | "unit.media.mediaType" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild";
                    /** @description Define what fields to use when sorting results. Defaults to count (desc) and each aggregate by field (asc). Each fieldname given as parameter defaults to ASC - if you want to sort using descending order, add " DESC" to the end of the field name. In addition to aggregateBy fields you can use the following aggregate function names: [count, individualCountSum, individualCountMax, oldestRecord, newestRecord, recordQualityMax, firstLoadDateMin, firstLoadDateMax, gatheringCount, securedCount, pairCountMax, pairCountSum, taxonCount, speciesCount, redListStatusMax, atlasCodeMax, atlasClassMax]. Multiple values are seperated by ','. */
                    orderBy?: "document.collectionId" | "document.completeListTaxonId" | "document.completeListType" | "document.createdDate" | "document.createdDateMonth" | "document.dataSource" | "document.documentId" | "document.editorUserIds" | "document.facts.decimalValue" | "document.facts.fact" | "document.facts.integerValue" | "document.facts.value" | "document.firstLoadDate" | "document.formId" | "document.keywords" | "document.licenseId" | "document.linkings.collectionQuality" | "document.linkings.editors" | "document.loadDate" | "document.media.author" | "document.media.copyrightOwner" | "document.media.licenseId" | "document.media.mediaType" | "document.mediaCount" | "document.modifiedDate" | "document.namedPlace.alternativeId" | "document.namedPlace.alternativeIds" | "document.namedPlace.birdAssociationAreaDisplayName" | "document.namedPlace.birdAssociationAreaId" | "document.namedPlace.collectionId" | "document.namedPlace.id" | "document.namedPlace.municipalityDisplayName" | "document.namedPlace.municipalityId" | "document.namedPlace.name" | "document.namedPlace.wgs84CenterPoint.lat" | "document.namedPlace.wgs84CenterPoint.lon" | "document.namedPlace.ykj10km.lat" | "document.namedPlace.ykj10km.lon" | "document.namedPlaceId" | "document.prefix" | "document.quality.issue.issue" | "document.quality.issue.source" | "document.secureLevel" | "document.secureReasons" | "document.secured" | "document.siteDead" | "document.siteStatus" | "document.siteType" | "document.sourceId" | "gathering.accurateArea" | "gathering.biogeographicalProvince" | "gathering.conversions.birdAssociationArea" | "gathering.conversions.boundingBoxAreaInSquareMeters" | "gathering.conversions.century" | "gathering.conversions.day" | "gathering.conversions.dayOfYearBegin" | "gathering.conversions.dayOfYearEnd" | "gathering.conversions.decade" | "gathering.conversions.euref.latMax" | "gathering.conversions.euref.latMin" | "gathering.conversions.euref.lonMax" | "gathering.conversions.euref.lonMin" | "gathering.conversions.eurefCenterPoint.lat" | "gathering.conversions.eurefCenterPoint.lon" | "gathering.conversions.linelengthInMeters" | "gathering.conversions.month" | "gathering.conversions.seasonBegin" | "gathering.conversions.seasonEnd" | "gathering.conversions.wgs84.latMax" | "gathering.conversions.wgs84.latMin" | "gathering.conversions.wgs84.lonMax" | "gathering.conversions.wgs84.lonMin" | "gathering.conversions.wgs84CenterPoint.lat" | "gathering.conversions.wgs84CenterPoint.lon" | "gathering.conversions.wgs84Grid005.lat" | "gathering.conversions.wgs84Grid005.lon" | "gathering.conversions.wgs84Grid01.lat" | "gathering.conversions.wgs84Grid01.lon" | "gathering.conversions.wgs84Grid05.lat" | "gathering.conversions.wgs84Grid05.lon" | "gathering.conversions.wgs84Grid1.lat" | "gathering.conversions.wgs84Grid1.lon" | "gathering.conversions.year" | "gathering.conversions.ykj.latMax" | "gathering.conversions.ykj.latMin" | "gathering.conversions.ykj.lonMax" | "gathering.conversions.ykj.lonMin" | "gathering.conversions.ykj100km.lat" | "gathering.conversions.ykj100km.lon" | "gathering.conversions.ykj100kmCenter.lat" | "gathering.conversions.ykj100kmCenter.lon" | "gathering.conversions.ykj10km.lat" | "gathering.conversions.ykj10km.lon" | "gathering.conversions.ykj10kmCenter.lat" | "gathering.conversions.ykj10kmCenter.lon" | "gathering.conversions.ykj1km.lat" | "gathering.conversions.ykj1km.lon" | "gathering.conversions.ykj1kmCenter.lat" | "gathering.conversions.ykj1kmCenter.lon" | "gathering.conversions.ykj50km.lat" | "gathering.conversions.ykj50km.lon" | "gathering.conversions.ykj50kmCenter.lat" | "gathering.conversions.ykj50kmCenter.lon" | "gathering.coordinatesVerbatim" | "gathering.country" | "gathering.displayDateTime" | "gathering.eventDate.begin" | "gathering.eventDate.end" | "gathering.facts.decimalValue" | "gathering.facts.fact" | "gathering.facts.integerValue" | "gathering.facts.value" | "gathering.gatheringId" | "gathering.gatheringOrder" | "gathering.gatheringSection" | "gathering.higherGeography" | "gathering.hourBegin" | "gathering.hourEnd" | "gathering.interpretations.biogeographicalProvince" | "gathering.interpretations.biogeographicalProvinceDisplayname" | "gathering.interpretations.coordinateAccuracy" | "gathering.interpretations.country" | "gathering.interpretations.countryDisplayname" | "gathering.interpretations.finnishMunicipality" | "gathering.interpretations.municipalityDisplayname" | "gathering.interpretations.sourceOfBiogeographicalProvince" | "gathering.interpretations.sourceOfCoordinates" | "gathering.interpretations.sourceOfCountry" | "gathering.interpretations.sourceOfFinnishMunicipality" | "gathering.linkings.observers" | "gathering.locality" | "gathering.media.author" | "gathering.media.copyrightOwner" | "gathering.media.licenseId" | "gathering.media.mediaType" | "gathering.mediaCount" | "gathering.minutesBegin" | "gathering.minutesEnd" | "gathering.municipality" | "gathering.observerUserIds" | "gathering.province" | "gathering.quality.issue.issue" | "gathering.quality.issue.source" | "gathering.quality.locationIssue.issue" | "gathering.quality.locationIssue.source" | "gathering.quality.timeIssue.issue" | "gathering.quality.timeIssue.source" | "gathering.stateLand" | "gathering.taxonCensus.taxonId" | "gathering.taxonCensus.type" | "gathering.team" | "gathering.team.memberId" | "gathering.team.memberName" | "unit.abundanceString" | "unit.abundanceUnit" | "unit.alive" | "unit.annotationCount" | "unit.annotations.annotationByPerson" | "unit.annotations.annotationByPersonName" | "unit.annotations.annotationBySystem" | "unit.annotations.annotationBySystemName" | "unit.annotations.created" | "unit.atlasClass" | "unit.atlasCode" | "unit.audioCount" | "unit.author" | "unit.breedingSite" | "unit.det" | "unit.facts.decimalValue" | "unit.facts.fact" | "unit.facts.integerValue" | "unit.facts.value" | "unit.imageCount" | "unit.individualCountFemale" | "unit.individualCountMale" | "unit.individualId" | "unit.interpretations.annotatedTaxonId" | "unit.interpretations.collectionAndRecordQuality" | "unit.interpretations.effectiveTags" | "unit.interpretations.individualCount" | "unit.interpretations.invasiveControlEffectiveness" | "unit.interpretations.invasiveControlled" | "unit.interpretations.needsCheck" | "unit.interpretations.needsIdentification" | "unit.interpretations.pairCount" | "unit.interpretations.recordQuality" | "unit.interpretations.recordQualityNumeric" | "unit.interpretations.reliability" | "unit.keywords" | "unit.lifeStage" | "unit.linkings.originalTaxon.administrativeStatuses" | "unit.linkings.originalTaxon.aggregateId" | "unit.linkings.originalTaxon.anamorphId" | "unit.linkings.originalTaxon.author" | "unit.linkings.originalTaxon.birdlifeCode" | "unit.linkings.originalTaxon.classId" | "unit.linkings.originalTaxon.cultivarId" | "unit.linkings.originalTaxon.cursiveName" | "unit.linkings.originalTaxon.divisionId" | "unit.linkings.originalTaxon.domainId" | "unit.linkings.originalTaxon.ecotypeId" | "unit.linkings.originalTaxon.euringCode" | "unit.linkings.originalTaxon.euringNumber" | "unit.linkings.originalTaxon.familyId" | "unit.linkings.originalTaxon.finnish" | "unit.linkings.originalTaxon.formId" | "unit.linkings.originalTaxon.genusId" | "unit.linkings.originalTaxon.grexId" | "unit.linkings.originalTaxon.groupId" | "unit.linkings.originalTaxon.habitats" | "unit.linkings.originalTaxon.hybridId" | "unit.linkings.originalTaxon.id" | "unit.linkings.originalTaxon.informalTaxonGroups" | "unit.linkings.originalTaxon.infraclassId" | "unit.linkings.originalTaxon.infradivisionId" | "unit.linkings.originalTaxon.infragenericHybridId" | "unit.linkings.originalTaxon.infragenericTaxonId" | "unit.linkings.originalTaxon.infrakingdomId" | "unit.linkings.originalTaxon.infraorderId" | "unit.linkings.originalTaxon.infraphylumId" | "unit.linkings.originalTaxon.infraspecificTaxonId" | "unit.linkings.originalTaxon.intergenericHybridId" | "unit.linkings.originalTaxon.invasive" | "unit.linkings.originalTaxon.kingdomId" | "unit.linkings.originalTaxon.nameAccordingTo" | "unit.linkings.originalTaxon.nameEnglish" | "unit.linkings.originalTaxon.nameFinnish" | "unit.linkings.originalTaxon.nameSwedish" | "unit.linkings.originalTaxon.nothogenusId" | "unit.linkings.originalTaxon.nothospeciesId" | "unit.linkings.originalTaxon.nothosubspeciesId" | "unit.linkings.originalTaxon.occurrenceCount" | "unit.linkings.originalTaxon.occurrenceCountFinland" | "unit.linkings.originalTaxon.orderId" | "unit.linkings.originalTaxon.parentId" | "unit.linkings.originalTaxon.parvclassId" | "unit.linkings.originalTaxon.parvorderId" | "unit.linkings.originalTaxon.phylumId" | "unit.linkings.originalTaxon.populationGroupId" | "unit.linkings.originalTaxon.primaryHabitat" | "unit.linkings.originalTaxon.redListStatus" | "unit.linkings.originalTaxon.redListStatusGroup" | "unit.linkings.originalTaxon.scientificName" | "unit.linkings.originalTaxon.scientificNameDisplayName" | "unit.linkings.originalTaxon.sectionId" | "unit.linkings.originalTaxon.sensitive" | "unit.linkings.originalTaxon.seriesId" | "unit.linkings.originalTaxon.species" | "unit.linkings.originalTaxon.speciesAggregateId" | "unit.linkings.originalTaxon.speciesId" | "unit.linkings.originalTaxon.speciesNameEnglish" | "unit.linkings.originalTaxon.speciesNameFinnish" | "unit.linkings.originalTaxon.speciesNameSwedish" | "unit.linkings.originalTaxon.speciesScientificName" | "unit.linkings.originalTaxon.speciesTaxonomicOrder" | "unit.linkings.originalTaxon.subclassId" | "unit.linkings.originalTaxon.subdivisionId" | "unit.linkings.originalTaxon.subfamilyId" | "unit.linkings.originalTaxon.subformId" | "unit.linkings.originalTaxon.subgenusId" | "unit.linkings.originalTaxon.subkingdomId" | "unit.linkings.originalTaxon.suborderId" | "unit.linkings.originalTaxon.subphylumId" | "unit.linkings.originalTaxon.subsectionId" | "unit.linkings.originalTaxon.subseriesId" | "unit.linkings.originalTaxon.subspeciesId" | "unit.linkings.originalTaxon.subspecificAggregateId" | "unit.linkings.originalTaxon.subtribeId" | "unit.linkings.originalTaxon.subvarietyId" | "unit.linkings.originalTaxon.superclassId" | "unit.linkings.originalTaxon.superdivisionId" | "unit.linkings.originalTaxon.superdomainId" | "unit.linkings.originalTaxon.superfamilyId" | "unit.linkings.originalTaxon.supergenusId" | "unit.linkings.originalTaxon.superorderId" | "unit.linkings.originalTaxon.superphylumId" | "unit.linkings.originalTaxon.taxonRank" | "unit.linkings.originalTaxon.taxonSets" | "unit.linkings.originalTaxon.taxonomicOrder" | "unit.linkings.originalTaxon.tribeId" | "unit.linkings.originalTaxon.typesOfOccurrenceInFinland" | "unit.linkings.originalTaxon.varietyId" | "unit.linkings.originalTaxon.virva" | "unit.linkings.taxon.administrativeStatuses" | "unit.linkings.taxon.aggregateId" | "unit.linkings.taxon.anamorphId" | "unit.linkings.taxon.author" | "unit.linkings.taxon.birdlifeCode" | "unit.linkings.taxon.classId" | "unit.linkings.taxon.cultivarId" | "unit.linkings.taxon.cursiveName" | "unit.linkings.taxon.divisionId" | "unit.linkings.taxon.domainId" | "unit.linkings.taxon.ecotypeId" | "unit.linkings.taxon.euringCode" | "unit.linkings.taxon.euringNumber" | "unit.linkings.taxon.familyId" | "unit.linkings.taxon.finnish" | "unit.linkings.taxon.formId" | "unit.linkings.taxon.genusId" | "unit.linkings.taxon.grexId" | "unit.linkings.taxon.groupId" | "unit.linkings.taxon.habitats" | "unit.linkings.taxon.hybridId" | "unit.linkings.taxon.id" | "unit.linkings.taxon.informalTaxonGroups" | "unit.linkings.taxon.infraclassId" | "unit.linkings.taxon.infradivisionId" | "unit.linkings.taxon.infragenericHybridId" | "unit.linkings.taxon.infragenericTaxonId" | "unit.linkings.taxon.infrakingdomId" | "unit.linkings.taxon.infraorderId" | "unit.linkings.taxon.infraphylumId" | "unit.linkings.taxon.infraspecificTaxonId" | "unit.linkings.taxon.intergenericHybridId" | "unit.linkings.taxon.invasive" | "unit.linkings.taxon.kingdomId" | "unit.linkings.taxon.nameAccordingTo" | "unit.linkings.taxon.nameEnglish" | "unit.linkings.taxon.nameFinnish" | "unit.linkings.taxon.nameSwedish" | "unit.linkings.taxon.nothogenusId" | "unit.linkings.taxon.nothospeciesId" | "unit.linkings.taxon.nothosubspeciesId" | "unit.linkings.taxon.occurrenceCount" | "unit.linkings.taxon.occurrenceCountFinland" | "unit.linkings.taxon.orderId" | "unit.linkings.taxon.parentId" | "unit.linkings.taxon.parvclassId" | "unit.linkings.taxon.parvorderId" | "unit.linkings.taxon.phylumId" | "unit.linkings.taxon.populationGroupId" | "unit.linkings.taxon.primaryHabitat" | "unit.linkings.taxon.redListStatus" | "unit.linkings.taxon.redListStatusGroup" | "unit.linkings.taxon.scientificName" | "unit.linkings.taxon.scientificNameDisplayName" | "unit.linkings.taxon.sectionId" | "unit.linkings.taxon.sensitive" | "unit.linkings.taxon.seriesId" | "unit.linkings.taxon.species" | "unit.linkings.taxon.speciesAggregateId" | "unit.linkings.taxon.speciesId" | "unit.linkings.taxon.speciesNameEnglish" | "unit.linkings.taxon.speciesNameFinnish" | "unit.linkings.taxon.speciesNameSwedish" | "unit.linkings.taxon.speciesScientificName" | "unit.linkings.taxon.speciesTaxonomicOrder" | "unit.linkings.taxon.subclassId" | "unit.linkings.taxon.subdivisionId" | "unit.linkings.taxon.subfamilyId" | "unit.linkings.taxon.subformId" | "unit.linkings.taxon.subgenusId" | "unit.linkings.taxon.subkingdomId" | "unit.linkings.taxon.suborderId" | "unit.linkings.taxon.subphylumId" | "unit.linkings.taxon.subsectionId" | "unit.linkings.taxon.subseriesId" | "unit.linkings.taxon.subspeciesId" | "unit.linkings.taxon.subspecificAggregateId" | "unit.linkings.taxon.subtribeId" | "unit.linkings.taxon.subvarietyId" | "unit.linkings.taxon.superclassId" | "unit.linkings.taxon.superdivisionId" | "unit.linkings.taxon.superdomainId" | "unit.linkings.taxon.superfamilyId" | "unit.linkings.taxon.supergenusId" | "unit.linkings.taxon.superorderId" | "unit.linkings.taxon.superphylumId" | "unit.linkings.taxon.taxonRank" | "unit.linkings.taxon.taxonSets" | "unit.linkings.taxon.taxonomicOrder" | "unit.linkings.taxon.tribeId" | "unit.linkings.taxon.typesOfOccurrenceInFinland" | "unit.linkings.taxon.varietyId" | "unit.linkings.taxon.virva" | "unit.local" | "unit.media.author" | "unit.media.copyrightOwner" | "unit.media.licenseId" | "unit.media.mediaType" | "unit.mediaCount" | "unit.modelCount" | "unit.notes" | "unit.plantStatusCode" | "unit.primarySpecimen" | "unit.quality.documentGatheringUnitQualityIssues" | "unit.quality.issue.issue" | "unit.quality.issue.source" | "unit.recordBasis" | "unit.referencePublication" | "unit.reportedInformalTaxonGroup" | "unit.reportedTaxonConfidence" | "unit.sampleCount" | "unit.samples.collectionId" | "unit.samples.facts.decimalValue" | "unit.samples.facts.fact" | "unit.samples.facts.integerValue" | "unit.samples.facts.value" | "unit.samples.keywords" | "unit.samples.material" | "unit.samples.multiple" | "unit.samples.quality" | "unit.samples.sampleId" | "unit.samples.sampleOrder" | "unit.samples.status" | "unit.samples.type" | "unit.samplingMethod" | "unit.sex" | "unit.superRecordBasis" | "unit.taxonVerbatim" | "unit.typeSpecimen" | "unit.unitId" | "unit.unitOrder" | "unit.videoCount" | "unit.wild" | "count" | "individualCountSum" | "individualCountMax" | "oldestRecord" | "newestRecord" | "recordQualityMax" | "firstLoadDateMin" | "firstLoadDateMax" | "gatheringCount" | "securedCount" | "pairCountMax" | "pairCountSum" | "taxonCount" | "speciesCount" | "redListStatusMax" | "atlasCodeMax" | "atlasClassMax";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the coordinate reference system used in the returned GeoJSON features. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description For GeoJSON requests there are two additional parameters: crs and featureType. This controls the type of returned GeoJSON features. */
                    featureType?: "CENTER_POINT" | "ENVELOPE" | "ORIGINAL_FEATURE";
                    /** @description Return only count of rows (default) or also additional aggregate function values. */
                    onlyCount?: boolean;
                    /** @description Include or exclude nulls to result. Will only check nullness of the first aggregateBy field. */
                    excludeNulls?: boolean;
                    /** @description Value of this parameter affects how oldestRecord and newestRecord are calculated regarding observations reported as date span. False (default): oldest=min(date.begin), newest=max(date.end). True: oldest=min(date.end), newest=max(date.begin). */
                    pessimisticDateRangeHandling?: boolean;
                    /** @description Set number of results in one page. */
                    pageSize?: number;
                    /** @description Set current page. */
                    page?: number;
                    /** @description Use cache for this query. Defaults to false. */
                    cache?: boolean;
                    /** @description Filter based on URI or Qname identifier of a taxon. Use Taxonomy-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonId?: string;
                    /** @description Same as taxonId, but system resolves identifier of the taxon based on the given target name. If no such match can be resolved (name does not exist in taxonomy), will filter based on the given verbatim target name (case insensitive). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    target?: string;
                    /** @description By default, all taxon linking related filters use taxon linking that may have been altered because of quality control identification annotations. If you want to use original user identifications, set this to false. */
                    useIdentificationAnnotations?: boolean;
                    /** @description By default, all taxon linking related filters return all entries that belong to the filtered taxa. To return only exact matches (no subtaxa), set this to false. */
                    includeSubTaxa?: boolean;
                    /** @description Set to false if you want to include only those entries where reported target name can be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    includeNonValidTaxa?: boolean;
                    /** @description Set to true if you want to include only those entries where reported target name can not be linked with a taxon of the reference taxonomy. By default includes all entries. */
                    onlyNonValidTaxa?: boolean;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupId?: string;
                    /** @description Exclude based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will exclude entries that have been linked with taxa that belong to any of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdNot?: string;
                    /** @description Filter based on URI or Qname identifier of an informal taxon group. Use InformalTaxonGroups-API to find identifiers. Will return entries that have been linked with taxa that belong to one of the given groups OR reported to belong to one of the given groups. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /informal-taxon-groups */
                    informalTaxonGroupIdIncludingReported?: string;
                    /** @description Filter based on URI or Qname identifier of an administrative status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the admin status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.adminStatusEnum */
                    administrativeStatusId?: string;
                    /** @description Filter based on URI or Qname identifier of red list status. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with the red list status. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.iucnStatuses */
                    redListStatusId?: string;
                    /** @description This parameter controls if search between administrativeStatusId and redListStatusId is an AND (default) or OR search. */
                    taxonAdminFiltersOperator?: "AND" | "OR";
                    /** @description Filter based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are marked with one or more of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceId?: string;
                    /** @description Exclude based on URI or Qname identifier of type of occurrence in Finland. Use Metadata-API to find identifiers. Will return entries of taxa that are not marked with any of the specified statuses. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.typeOfOccurrenceEnum */
                    typeOfOccurrenceIdNot?: string;
                    /** @description Filter based on primary habitat of taxa. Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    primaryHabitat?: string;
                    /** @description Filter based on habitat of taxa (primary or secondary). Will return entries of taxa that have one of the specified habitats or a subhabitat of the given habitats. Syntax: MKV.habitatMk[MKV.habitatSpecificTypeJ,MKV.habitatSpecificTypePAK] Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    anyHabitat?: string;
                    /** @description Filter based on occurrence count of taxa. Will return entries of taxa that have less occurrences than the given parameter. */
                    occurrenceCountMax?: number;
                    /** @description Filter based on occurrence count in Finland of taxa. Will return entries of taxa that have less occurrences in Finland than the given parameter. */
                    occurrenceCountFinlandMax?: number;
                    /** @description Filter only those taxa that are finnish or are not finnish. */
                    finnish?: boolean;
                    /** @description Filter only those taxa that are invasive or are not invasive. */
                    invasive?: boolean;
                    /** @description Include only those occurrences that are of sensitive species or those that are of non-sensitive species */
                    sensitive?: boolean;
                    /** @description True: Filter those occurrence that are linked to a higher taxon (like genus, family). False: linked to taxon that is species, subspecies, aggregate or other lower rank. */
                    higherTaxon?: boolean;
                    /** @description Filter based on URI or Qname identifier of taxon rank. Use Metadata-API to find identifiers. Will return entries of taxa that are of the specified ranks. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonRankEnum */
                    taxonRankId?: string;
                    /** @description Filter based on URI or Qname identifier of a country. Use Area-API to find identifiers. Will return entries where we have been able to interpret the country from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    countryId?: string;
                    /** @description Filter based on URI or Qname identifier of a finnish municipality. Use Area-API to find identifiers. Will return entries where we have been able to interpret the municipality from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    finnishMunicipalityId?: string;
                    /** @description Filter based on URI or Qname identifier of a biogeographical province. Use Area-API to find identifiers. Will return entries where we have been able to interpret the province from coordinates or from reported area name. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    biogeographicalProvinceId?: string;
                    /** @description Filter based on URI or Qname identifier of a ELY centre. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    elyCentreId?: string;
                    /** @description Filter based on URI or Qname identifier of a Finnish province. Use Area-API to find identifiers. Implementation is based on municipality interpretations. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    provinceId?: string;
                    /** @description Filter using name of country, municipality, province or locality. If the given name matches exactly one known area, the search will perform an identifier search. Otherwise the search looks from country verbatim, municipality verbatim, province verbatim and locality using exact match case insensitive search. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    area?: string;
                    /** @description Filter based on URI or Qname identifier of a NamedPlace. Use NamedPlace-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /named-places */
                    namedPlaceId?: string;
                    /** @description Filter based on URI or Qname identifier of MNP.tagEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MNP.tagEnum */
                    namedPlaceTag?: string;
                    /** @description Filter based on URI or Qname identifier of a BirdAssociationArea. Use Area-API to find identifiers. Bird association area is interpreted based on YKJ 10KM grids (the grid the occurrence centerpoint is in). Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /areas */
                    birdAssociationAreaId?: string;
                    /** @description Filter based on URI or Qname identifier of a Vihko Notebook form that was used to report the entry. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /forms */
                    formId?: string;
                    /** @description Filter using event date. Date can be a full date or part of a date, for example 2000, 2000-06 or 2000-06-25. Time can be a range, for example 2000/2005 or 2000-01-01/2005-12-31. Relative days "last N days" can be used: 0 is today, -1 is yesterday and so on; for example -7/0 is a range between 7 days ago and today. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    time?: string;
                    /** @description Filter using event date accuracy range in days. Will include entries where time span in days is less or equal to the given value. */
                    timeAccuracy?: number;
                    /** @description Filter using event date. Value can be a year (2000), year range (2000/2001), year-month (2000-06) or a year-month range (2000-06/2000-08). (Note: this filter is mostly aimed to be used in /statistics queries because 'time' filter is not available for /statistics queries.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    yearMonth?: string;
                    /** @description Filter using day of year. For example "100/160" gives all records during spring and "330/30" during mid winter. If begin is ommited will use day 1 and if end is ommited will use day 366. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    dayOfYear?: string;
                    /** @description Filter using season. For example "501/630" gives all records for May and July and "1220/0220" between 20.12. - 20.2. If begin is ommited will use 1.1. and if end is ommited will use 31.12. Multiple ranges can be given by providing the parameter more times. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    season?: string;
                    /** @description Filter using keywords that have been tagged to entries. There are many types of keywods varying from legacy identifiers, project names and IDs, dataset ids, etc.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    keyword?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionId?: string;
                    /** @description Filter based on URI or Qname identifier of collections. Use Collections-API to resolve identifiers. Will not include child collections Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicit?: string;
                    /** @description Exclude certain collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdNot?: string;
                    /** @description Exclude certain collection (only the specified collection, not child collections) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /collections */
                    collectionIdExplicitNot?: string;
                    /** @description Defines if collectionId filter should include sub collections of the given collection ids. By default sub collections are included. */
                    includeSubCollections?: boolean;
                    /** @description Filter using identifiers of data sources (information systems). Use InformationSystem-API to resolve identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /sources */
                    sourceId?: string;
                    /** @description Filter using record basis. This can be used for example to get only preserved specimens. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using super record basis. (Note: Even though the enumeration lists all record basis values, only few of those are super record basis: PRESERVED_SPECIMEN, HUMAN_OBSERVATION_UNSPECIFIED, ..; use aggregate by superRecordBasis to find used values. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
                    /** @description Filter using life stage of an unit. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
                    /** @description Filter using sex of an unit. When filtering MALE or FEMALE, will include those where individualCountMale/Female is >= 1 Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
                    /** @description Filter using effectiveness of invasive control measures Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    invasiveControl?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
                    /** @description Filter only invasives that are reported to have been controlled successfully or not reported to have been controlled succesfully. */
                    invasiveControlled?: boolean;
                    /** @description Filter using document URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentId?: string;
                    /** @description Filter using document URI prefix. For example prefix of http://id.luomus.fi/JA.1 is luomus:JA.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    documentIdPrefix?: string;
                    /** @description Filter using gathering URIs. Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    gatheringId?: string;
                    /** @description Filter using unit ids.  Will include records with quality issues (normally exluded by default). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    unitId?: string;
                    /** @description Filter using identifier of an individual, for example bird ring. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    individualId?: string;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "zero observations" use max=0. Defaults to 1 but when using annotation endpoint defaults to null. */
                    individualCountMin?: number;
                    /** @description Filter using idividual count. Unreported individual count is assumed to mean "1+", so searching min=1 returns where count > 0 or count is not given. To search for "null observations" use max=0. */
                    individualCountMax?: number;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    loadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    loadedSameOrBefore?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded later or on the same date/timestamp. */
                    firstLoadedSameOrAfter?: string;
                    /** @description Filter using the date data was loaded to Data Warehouse (first load of document). Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. Returns entries loaded before or on the same date/timestamp. */
                    firstLoadedSameOrBefore?: string;
                    /** @description Filter using the year the record was created */
                    createdDateYear?: number;
                    /** @description Filter using coordinates. Valid formats are latMin:latMax:lonMin:lonMax:CRS:ratio and lat:lon:CRS:ratio. The last parameter (ratio) is not required. Valid CRSs are WGS84, YKJ and EUREF (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393). For metric coordinates (ykj, euref): the search 666:333:YKJ means lat between 6660000-6670000 and lon between 3330000-3340000. Ratio is a number between 0.0-1.0. Default ratio is 1.0 (observation area must be entirely inside the search area). Ratio 0.0: the search area must intersect with the observation area. For WGS84 the ratio is not calculated in meters but in degrees so it an approximation. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    coordinates?: string;
                    /** @description Filter centerpoint of occurrences by polygon. Valid formats are WKT and WKT:CRS. Valid CRSs are WGS84, YKJ and EUREF (default) (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393).  Polygon search is implemented only for Finland (based on ETRS-TM35FIN coordinate system). WKT must be somewhat shorter than 4000 chars. To overcome this limitation use polygonId filter and /polygon/ endpoint to get the polygonIds. */
                    polygon?: string;
                    /** @description Filter centerpoint occurrences using ID of a search polygon. Use /polygon/ endpoint to get id if the polygon. */
                    polygonId?: string;
                    /** @description Exclude coordinates that are less accurate or equal than the provided value (inclusive). Value is meters. Accuracy is a guiding logaritmic figure, for example 1m, 10m, 100m or 100km. (More specifically the longest length of the area bouding box rounded up on the logarithmic scale.) */
                    coordinateAccuracyMax?: number;
                    /** @description Filter using WGS84 (EPSG:4326) centerpoint. Valid formats are lat:lon:WGS84 and latMin:latMax:lonMin:lonMax:WGS84. (You must include the crs WGS84 even though it is the only supported type.) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wgs84CenterPoint?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s). Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100km?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 1km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj1kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 10km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj10kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 50km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj50kmCenter?: string;
                    /** @description Filter using uniform (YKJ, EPSG:2393) 100km grid square(s) that are resolved using center point of the area. Valid format is lat:lon. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    ykj100kmCenter?: string;
                    /** @description Filter based on source of coordinates. Possible values are REPORTED_VALUE = the reported coordinates or FINNISH_MUNICIPALITY = the coordinates are the bounding box of the reported Finnish municipality (no coordinates were reported). Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
                    /** @description Filter only type specimens or those that are not type specimens. */
                    typeSpecimen?: boolean;
                    /** @description Filter occurrences based on reported/annotated wild status. By default, non-wild occurrences are exluded. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    wild?: "WILD" | "WILD_UNKNOWN" | "NON_WILD";
                    /** @description Filter only occurrences reported to be at their breeding site. */
                    breedingSite?: boolean;
                    /** @description Filter only for local species. */
                    local?: boolean;
                    /** @description Filter occurences reported to be dead (alive=false) or alive or unknown ( reported to be alive (true) or dead (false). */
                    alive?: boolean;
                    /** @description Filter based on URI or Qname identifier of identification basis. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.identificationBasisEnum */
                    identificationBasis?: string;
                    /** @description Filter based on URI or Qname identifier of sampling method. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.samplingMethods */
                    samplingMethod?: string;
                    /** @description Filter only occurrences reported with a certain plant status code. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.plantStatusCodeEnum */
                    plantStatusCode?: string;
                    /** @description Filter only units where parent document has media or doesn't have media. */
                    hasDocumentMedia?: boolean;
                    /** @description Filter only units where parent gathering has media or doesn't have media. */
                    hasGatheringMedia?: boolean;
                    /** @description Filter only units where unit has media or doesn't have media. */
                    hasUnitMedia?: boolean;
                    /** @description Filter only units where unit has images or doesn't have images. */
                    hasUnitImages?: boolean;
                    /** @description Filter only units where unit has audio or doesn't have audio. */
                    hasUnitAudio?: boolean;
                    /** @description Filter only units where unit has video or doesn't have video. */
                    hasUnitVideo?: boolean;
                    /** @description Filter only units where unit has 3d models or doesn't have 3d-models. */
                    hasUnitModel?: boolean;
                    /** @description Filter only records where parent document, gathering or unit has media or none have media. */
                    hasMedia?: boolean;
                    /** @description Filter based on "owners" of records (those who have edit permissions or have edited, modified). Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorId?: string;
                    /** @description Filter based on observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    observerId?: string;
                    /** @description Filter based on "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverId?: string;
                    /** @description Filter based on verbatim observer names. Search is case insensitive and wildcard * can be used. Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    teamMember?: string;
                    /** @description Filter based on person not being "owners" or observers of records. Only available in private-query-API. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /person */
                    editorOrObserverIdIsNot?: string;
                    /** @description Filter based on ids of verbatim observer name strings. (The only way to access these ids is to aggregate by gathering.team.memberId) Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    teamMemberId?: string;
                    /** @description Filter based on secure reasons. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureReason?: "DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME";
                    /** @description Filter based on secure level. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
                    /** @description Include only those that are secured or those that are not secured. */
                    secured?: boolean;
                    /** @description Include only those units that have annotations or those that do not have annotations. */
                    annotated?: boolean;
                    /** @description Include only those units/annotations that are of the selected annotation type. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    annotationType?: "ALL" | "USER_EFFECTIVE" | "USER_CHECK" | "DW_AUTO" | "ADMIN" | "FORM_ADMIN" | "INVASIVE_CONTROL" | "COMMENT" | "DELETED";
                    /** @description Include those annotations that are made by automated quality checks. Defaults to false. */
                    includeSystemAnnotations?: boolean;
                    /** @description Include only those annotations that have been made after or on the same date/timestamp. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. */
                    annotatedSameOrAfter?: string;
                    /** @description Include only those annotations that have been made before or on the same date/timestamp. Format is yyyy-MM-dd or UNIX EPOCH timestamp in seconds. */
                    annotatedSameOrBefore?: string;
                    /** @description Possible values: NO_ISSUES, BOTH, ONLY_ISSUES. Include records with quality issues (document, gathering or unit issues). Default is NO_ISSUES, but when searching by id (documentId, unitId, keyword) or using annotation endpoint the default is BOTH. */
                    qualityIssues?: "NO_ISSUES" | "BOTH" | "ONLY_ISSUES";
                    /** @description Filter based on quality rating of collections. Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
                    /** @description Filter using quality rating of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
                    /** @description Filter using quality rating of collection and occurrence. Format: "PROFESSIONAL:NEUTRAL,UNCERTAIN". Multiple values are seperated by ';'. When multiple values are given, this is an OR search. */
                    collectionAndRecordQuality?: string;
                    /** @description Filter using reliability of the occurrence Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
                    /** @description Filter using effective tags of the record Multiple values are seperated by ','. When multiple values are given, this is an OR search. */
                    effectiveTag?: "ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND";
                    /** @description Show only records that need an identification (or do not need an identification) */
                    unidentified?: boolean;
                    /** @description Show only records that are marked to need checking by experts (or do not need checking) */
                    needsCheck?: boolean;
                    /** @description Show only records where document contains complete list for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    completeListTaxonId?: string;
                    /** @description Show only records where document contains complete list and the list is of this type: URI or Qname identifier of MY.completeListTypeEnum (use metadata-api to resolve identifiers) Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.completeListTypeEnum */
                    completeListType?: string;
                    /** @description Filter based on URI or Qname identifier of an taxon sets: Use Metadata-API to find identifiers. Returns occurrences of taxa that belong to the specified taxon set. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MX.taxonSetEnum */
                    taxonSetId?: string;
                    /** @description Show only records where observations are completely recorded for this higher taxon. For example include only records where all birds or mammals were documented, if they were seens -> something that is not documented was not seen. Use taxon IDs. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /taxa */
                    taxonCensus?: string;
                    /** @description Include only those units that have samples or those that do not have samples. */
                    hasSample?: boolean;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    unitFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    gatheringFact?: string;
                    /** @description Format is "factName=value;otherFact=value". If value is not given (for example just "factName"), this filter matches all records that have the given fact. If value is a numeric range (for example "factName=-5.0/-1.5"), this filter matches all values where the value is between the range (inclusive). When multiple fact names are given, this is an AND search. For facts that are URIs, you can use full URI or Qname. */
                    documentFact?: string;
                    /** @description You can split search results into partitions. Syntax: '1/5' splits the results to five partitions and returns the first. Useful when downloading large lists of results and you want to split the task into smaller sub-queries. */
                    partition?: string;
                    /** @description Name (or names) of fields that must be non-null for the occurrence to be included to results. The field must be from level document, gathering or unit (not for example annotation) and must not be an array field. Also, when quering gathering level, unit fields can not be used, etc. When multiple fields are listed, this is an AND search (all must be non-null). Multiple values are seperated by ','. */
                    hasValue?: string;
                    /** @description Filter based on URI or Qname identifier of atlas code. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasCodeEnum */
                    atlasCode?: string;
                    /** @description Filter based on URI or Qname identifier of atlas class. Use Metadata-API to find identifiers. Multiple values are seperated by ','. When multiple values are given, this is an OR search. API resource: /metadata/ranges/MY.atlasClassEnum */
                    atlasClass?: string;
                    /** @description Filter to occurrences that are not on state lands (true) or to occurrences that are only from state lands (false) */
                    onlyNonStateLands?: boolean;
                    /** @description Search for records the user has save or modified. When using this filter, results come from the private warehouse! */
                    editorPersonToken?: string;
                    /** @description Search for records where the user has been marked as the observer. When using this filter, results come from the private warehouse! */
                    observerPersonToken?: string;
                    /** @description Search for records the user has saved OR where marked as the observer. When using this filter, results come from the private warehouse! */
                    editorOrObserverPersonToken?: string;
                    /** @description Search for records where the user has not saved or observed the record (= everyone else's records). These come from the public warehouse! -> Results may contain records that have actually been saved by the user, but the info is not available in public (has been secured). */
                    editorOrObserverIsNotPersonToken?: string;
                    /** @description Use granted permissions to search the private warehouse */
                    permissionToken?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "geojson" | "xml" | "csv" | "tsv";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful query. Schema varies based on content-type of the response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwQuery_AggregateResponse"];
                        "application/geo+json": string;
                        "application/xml": string;
                        "text/csv": string;
                        "text/tab-separated-values": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/enumeration-labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Enumeration labels
         * @description Get descriptions of enumerations that are used in query parameters and responses.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/enumeration-labels/{enumeration}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Enumeration label
         * @description Get descriptions of enumeration.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Name of the enumeration */
                    enumeration: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/filters": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Filter descriptions
         * @description Get descriptions of filters used in queries.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/filters/{filter}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Filter description
         * @description Get description of a filter.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Name of the filter */
                    filter: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/polygon": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Polygon ids for polygon search
         * @description Submit polygons in various coordinate reference systems and in GeoJSON or WKT format, and get id of the polygon which can be given to polygonId search filter.
         */
        post: {
            parameters: {
                query: {
                    /** @description Person token is required to limit number of created polygon ids per day to 100 */
                    personToken: string;
                    /** @description Give coordinate reference system of the GeoJSON or WKT. Defaults to EUREF. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                    /** @description Either this or wkt is required. The polygon as GeoJSON. */
                    geoJSON?: string;
                    /** @description Either this or geoJSON is required. The polygon as WKT. */
                    wkt?: string;
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "json" | "xml" | "plain";
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string;
                        "application/xml": string;
                        "text/plain": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description User limit per day was exceeded. */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/warehouse/polygon/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Polygon by polygonId
         * @description Get polygon as GeoJSON or WKT in various coordinate reference systems. Polygon has been previously subscribed and given and id by making a POST request.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Alternative way to Accept header to define content type of the response. */
                    format?: "wkt" | "geojson";
                    /** @description Give coordinate reference system in which to return the polygon. Defaults to EUREF. (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
                    crs?: "WGS84" | "EUREF" | "YKJ";
                };
                header?: never;
                path: {
                    /** @description Id of the polygon */
                    id: number;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/wkt": string;
                        "application/geo+json": string;
                    };
                };
                /** @description Parameters were not accepted. Message has details. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Invalid credentials. Message has details. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Too many pending requests for the access_token; max is 12 */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DwError"];
                    };
                };
                /** @description Service is in unknown erroneous state. */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "text/plain": string;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search traits
         * @description Search traits from all published datasets.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Page size */
                    pageSize?: number;
                    /** @description Page number */
                    page?: number;
                    /** @description A set of key-value pairs used to filter search results.
                     *     Each key represents a field name in the result model, and its corresponding value specifies the criteria that must be met for the records to match.
                     *     If field is given multiple time as parameter, at least one of the given values must match.
                     *     Example: subject.type=TDF.typeTaxon&trait.id=TDF.1&trait.id=TDF.2&subjectFinBIFTaxon.higherTaxa.kingdom=Animalia */
                    searchParams?: {
                        [key: string]: string | undefined;
                    };
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPISearchResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/search/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Download traits
         * @description Search traits from all published datasets and download results as Zipped TSV file. Returns maximum of 1000000 rows.
         */
        get: {
            parameters: {
                query?: {
                    /** @description A set of key-value pairs used to filter search results.
                     *     Each key represents a field name in the result model, and its corresponding value specifies the criteria that must be met for the records to match.
                     *     If field is given multiple time as parameter, at least one of the given values must match.
                     *     Example: subject.type=TDF.typeTaxon&trait.id=TDF.1&trait.id=TDF.2&subjectFinBIFTaxon.higherTaxa.kingdom=Animalia */
                    searchParams?: {
                        [key: string]: string | undefined;
                    };
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/zip": string;
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get trait input row by id */
        get: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the InputRow */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InputRow"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        /** Update an input row */
        put: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the InputRow */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InputRow"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InputRow"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        post?: never;
        /** Delete an input row */
        delete: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIOKResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate adding a new input row */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InputRow"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/validate-update/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate update of an input row */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the InputRow */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InputRow"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/validate-delete/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate deleting input row */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Insert new input row */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InputRow"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InputRow"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/tsv2rows/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate TSV to InputRows conversion */
        post: {
            parameters: {
                query: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                    /** @description Id if the dataset */
                    datasetId: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "text/tab-separated-values": string;
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitTSVValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/tsv2rows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Convert TSV lines to InputRows */
        post: {
            parameters: {
                query: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                    /** @description Id if the dataset */
                    datasetId: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "text/tab-separated-values": string;
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InputRow"][];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoint before doing conversion. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/multi/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate adding a batch of input rows */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InputRow"][];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitMultiValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/multi": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Store a batch of input rows */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InputRow"][];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIOKResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoint before doing insert. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/rows/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search input rows
         * @description Search stored traits of a single dataset. Requires permissions to the dataset.
         */
        get: {
            parameters: {
                query: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                    /** @description Id if the dataset */
                    datasetId: string;
                    /** @description Page size */
                    pageSize?: number;
                    /** @description A set of key-value pairs used to filter search results.
                     *     Each key represents a field name in the result model, and its corresponding value specifies the criteria that must be met for the records to match.
                     *     If field is given multiple time as parameter, at least one of the given values must match.
                     *     Example: subject.type=TDF.typeTaxon&traits.statisticalMethod=TDF.statisticalMethodSD&traits.statisticalMethod=TDF.statisticalMethodAvg */
                    searchParams?: {
                        [key: string]: string | undefined;
                    };
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InputRow"][];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/datasets": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all datasets */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Dataset"][];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        /** Insert new dataset */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Dataset"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Dataset"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/datasets/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get dataset by id */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the Dataset */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Dataset"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        /** Update a dataset */
        put: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the Dataset */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Dataset"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Dataset"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        post?: never;
        /** Delete a dataset */
        delete: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIOKResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/datasets/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate adding a new dataset */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Dataset"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/datasets/validate-update/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate dataset update */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the Dataset */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Dataset"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/datasets/validate-delete/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate deleting a dataset */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/dataset-permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get users all permissions (defined by personToken or - in absence - of the access_token) */
        get: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DatasetPermissions"][];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/dataset-permissions/{datasetId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get permissions of a dataset */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the dataset */
                    datasetId: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DatasetPermissions"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        /** Update permissions of a dataset */
        put: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the dataset */
                    datasetId: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DatasetPermissions"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DatasetPermissions"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/dataset-permissions/validate-update/{datasetId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate permission submission */
        post: {
            parameters: {
                query?: {
                    /** @description Identity of a logged in user */
                    personToken?: string;
                };
                header?: never;
                path: {
                    /** @description Id of the dataset */
                    datasetId: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DatasetPermissions"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/trait-groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all trait groups */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitGroup"][];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        /** Insert new trait group */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TraitGroup"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitGroup"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/trait-groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get trait group by id */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the TraitGroup */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitGroup"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        /** Update a trait group */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the TraitGroup */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TraitGroup"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitGroup"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        post?: never;
        /** Delete a trait group */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIOKResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/trait-groups/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate adding a new trait group */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TraitGroup"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/trait-groups/validate-update/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate trait group update */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the TraitGroup */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TraitGroup"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/trait-groups/validate-delete/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate deleting a trait group */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/traits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all traits */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Trait"][];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        /** Insert new trait */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Trait"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Trait"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/traits/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get trait by id */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the Trait */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Trait"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        /** Update a trait */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the Trait */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Trait"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Trait"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        post?: never;
        /** Delete a trait */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIOKResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Validation failure - should call validation endpoints before calling upsert operations. */
                422: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/traits/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate adding a new trait */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Trait"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/traits/validate-update/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate trait update */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the Trait */
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["Trait"];
                };
            };
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description Illegal arguments */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/traits/validate-delete/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validate deleting a trait */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ValidationResponse"];
                    };
                };
                /** @description No access / Invalid authorization */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/units": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get all units of measurement */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UnitOfMeasurement"][];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/trait/units/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get unit of measurement by id */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Id of the UnitOfMeasurement */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Succesful response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["UnitOfMeasurement"];
                    };
                };
                /** @description No entity with the given id */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
                /** @description Unknown failure */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TraitAPIError"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        FormPermissionPersonDto: {
            admins: string[];
            editors: string[];
            permissionRequests: string[];
        };
        FormPermissionDto: {
            /** @enum {string} */
            restrictAccess?: "MHL.restrictAccessStrict" | "MHL.restrictAccessLoose";
            admins: string[];
            editors: string[];
            permissionRequests: string[];
            collectionID: string;
            hasAdmins?: boolean;
        };
        Person: {
            id: string;
            emailAddress: string;
            inheritedName?: string;
            preferredName?: string;
            lajiAuthLoginName?: string;
            fullName?: string;
            /** @default [] */
            role: ("MA.admin" | "_IMPORT_")[];
            group?: string;
            organisation?: string[];
            organisationAdmin?: string[];
            securePortalUserRoleExpires?: string;
            /** @enum {string} */
            roleAnnotation: "MMAN.expert";
            "@context": string;
        };
        Profile: {
            id: string;
            userID: string;
            profileDescription: string;
            personalCollectionIdentifier: string;
            /** @default [] */
            taxonExpertise: string[];
            taxonExpertiseNotes: string;
            image: string;
            /** @default [] */
            friends: string[];
            /** @default [] */
            blocked: string[];
            /** @default [] */
            friendRequests: string[];
            /** @default {} */
            settings: Record<string, never>;
        };
        StoreDeleteResponse: {
            affected: number;
        };
        Collection: {
            collectionName: Record<string, never>;
            description?: Record<string, never>;
            concealmentBasis?: Record<string, never>;
            onlineUrl?: Record<string, never>;
            longName: Record<string, never>;
            dataQualityDescription?: Record<string, never>;
            dataUseTerm?: Record<string, never>;
            hasChildren?: boolean;
            collectionLocation?: Record<string, never>;
            dataLocation?: Record<string, never>;
            inMustikka?: boolean;
            editor?: string;
            creator?: string;
            "@context": string;
            id: string;
            /** @enum {string} */
            metadataStatus?: "MY.metadataStatusHidden";
            isPartOf?: string;
            abbreviation?: string;
            temporalCoverage?: Record<string, never>;
            taxonomicCoverage?: Record<string, never>;
            methods?: Record<string, never>;
            coverageBasis?: Record<string, never>;
            geographicCoverage?: Record<string, never>;
            downloadRequestHandler?: string[];
            shareToFEO?: boolean;
            shareToGbif?: string;
            collectionType: Record<string, never>;
            intellectualRights: Record<string, never>;
        };
        ApiUserEntity: {
            id: number;
            email: string;
            systemID?: string;
            feedbackEmail?: string;
            /** @default noop */
            password: string;
        };
        ApiUserCreateDto: {
            email: string;
        };
        FileUploadResponse: {
            name: string;
            fileName: string;
            id: string;
            expires: number;
        };
        Image: {
            author?: string;
            caption?: string;
            copyrightOwner?: string;
            fullURL?: string;
            keywords?: string[];
            largeURL?: string;
            licenseAbbreviation?: string;
            licenseFullname?: components["schemas"]["LocalizedText"];
            /** @description Qname identifier */
            licenseId?: string;
            lifeStage?: string[];
            plantLifeStage?: string[];
            sex?: string[];
            sortOrder?: number;
            /** @description Qname identifier */
            source?: string;
            squareThumbnailURL?: string;
            taxon?: components["schemas"]["SimpleTaxon"];
            taxonDescriptionCaption?: components["schemas"]["LocalizedText"];
            thumbnailURL?: string;
            /** @description Qname identifier */
            type?: string;
            primaryForTaxon?: boolean;
        };
        Audio: {
            /** @enum {string} */
            intellectualRights: "MZ.intellectualRightsCC-BY-SA-4.0" | "MZ.intellectualRightsCC-BY-NC-4.0" | "MZ.intellectualRightsCC-BY-NC-SA-4.0" | "MZ.intellectualRightsCC-BY-4.0" | "MZ.intellectualRightsCC0-4.0" | "MZ.intellectualRightsODBL-1.0" | "MZ.intellectualRightsPD" | "MZ.intellectualRightsARR" | "MZ.intellectualRightsCC-BY-2.0" | "MZ.intellectualRightsCC-BY-SA-2.0" | "MZ.intellectualRightsCC-BY-SA-2.0-DE" | "MZ.intellectualRightsCC-BY-NC-2.0" | "MZ.intellectualRightsCC-BY-NC-SA-2.0" | "MZ.intellectualRightsCC-BY-NC-ND-2.0" | "MZ.intellectualRightsCC-BY-SA-2.5" | "MZ.intellectualRightsCC-BY-SA-2.5-SE" | "MZ.intellectualRightsCC-BY-3.0" | "MZ.intellectualRightsCC-BY-SA-3.0" | "MZ.intellectualRightsCC-BY-NC-SA-3.0" | "MZ.intellectualRightsCC-BY-ND-4.0" | "MZ.intellectualRightsCC-BY-NC-ND-4.0";
            caption?: string;
            captureDateTime?: string;
            capturerVerbatim?: string[];
            flacURL?: string;
            fullURL: string;
            id?: string;
            intellectualOwner: string;
            keyword?: string[];
            mp3URL: string;
            thumbnailURL: string;
            uploadedBy?: string;
            wavURL?: string;
        };
        NamedPlace: {
            id: string;
            geometry: Record<string, never>;
            /** @default false */
            public: Record<string, never>;
            /** @default [] */
            owners: string[];
            /**
             * @description Read access, not edit access
             * @default []
             */
            editors: string[];
            prepopulatedDocument?: Record<string, never>;
            acceptedDocument?: Record<string, never>;
        };
        ErrorsObj: Record<string, never>;
        BatchJobValidationStatus: {
            percentage: number;
            /** @default 0 */
            processed: Record<string, never>;
            total: number;
        };
        BatchJobValidationStatusResponse: {
            /** @enum {string} */
            phase: "VALIDATING" | "READY_TO_COMPLETE" | "COMPLETING" | "COMPLETED";
            /** @default [] */
            errors: (components["schemas"]["ErrorsObj"] | null)[];
            id: string;
            documents?: components["schemas"]["document"][];
            status: components["schemas"]["BatchJobValidationStatus"];
            personID: string;
        };
        DocumentCountItemResponse: {
            year: string;
            count: number;
        };
        StatisticsResponse: {
            dateMedian: string;
        };
        FeaturedImage: {
            url: string;
            caption: string;
        };
        InformationChild: {
            title: string;
            id: string;
            children?: components["schemas"]["InformationChild"][];
        };
        Information: {
            id: string;
            content: string;
            title: string;
            author: string;
            posted: string;
            featuredImage?: components["schemas"]["FeaturedImage"];
            /** @default [] */
            tags: string[];
            modified?: string;
            children?: components["schemas"]["InformationChild"][];
            parents?: components["schemas"]["InformationChild"][];
        };
        DwQuery_CountResponse: {
            total?: number;
            cacheTimestamp?: number;
        };
        DwQuery_ListResponse: {
            currentPage?: number;
            prevPage?: number;
            nextPage?: number;
            lastPage?: number;
            pageSize?: number;
            total?: number;
            results?: components["schemas"]["DwQuery_JoinedRow"][];
            cacheTimestamp?: number;
        };
        DwQuery_AggregateResponse: {
            currentPage?: number;
            prevPage?: number;
            nextPage?: number;
            lastPage?: number;
            pageSize?: number;
            total?: number;
            results?: components["schemas"]["DwQuery_AggregateRow"][];
            cacheTimestamp?: number;
        };
        DwQuery_JoinedRow: {
            document?: components["schemas"]["DwQuery_Document"];
            gathering?: components["schemas"]["DwQuery_Gathering"];
            unit?: components["schemas"]["DwQuery_Unit"];
            annotation?: components["schemas"]["DwQuery_Annotation"];
            media?: components["schemas"]["DwQuery_MediaObject"];
            sample?: components["schemas"]["DwQuery_Sample"];
        };
        DwQuery_AggregateRow: {
            count?: number;
            gatheringCount?: number;
            securedCount?: number;
            /** Format: yyyy-MM-dd */
            oldestRecord?: string;
            /** Format: yyyy-MM-dd */
            newestRecord?: string;
            /** Format: yyyy-MM-dd */
            firstLoadDateMin?: string;
            /** Format: yyyy-MM-dd */
            firstLoadDateMax?: string;
            individualCountSum?: number;
            individualCountMax?: number;
            /** Format: URI */
            recordQualityMax?: string;
            /** Format: URI */
            redListStatusMax?: string;
            speciesCount?: number;
            taxonCount?: number;
            lineLengthSum?: number;
            pairCountSum?: number;
            pairCountMax?: number;
            /** Format: URI */
            atlasCodeMax?: string;
            /** Format: URI */
            atlasClassMax?: string;
            aggregateBy?: Record<string, never>;
        };
        DwQuery_Document: {
            /** Format: URI */
            documentId?: string;
            /** @enum {string} */
            secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
            secureReasons?: ("DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME")[];
            partial?: boolean;
            /** Format: URI */
            collectionId?: string;
            licenseId?: string;
            dataSource?: string;
            linkings?: components["schemas"]["DwQuery_DocumentDWLinkings"];
            quality?: components["schemas"]["DwQuery_DocumentQuality"];
            /** Format: URI */
            sourceId?: string;
            namedPlaceId?: string;
            siteType?: string;
            siteStatus?: string;
            keywords?: string[];
            /** Format: yyyy-MM-dd */
            firstLoadDate?: string;
            /** Format: yyyy-MM-dd */
            loadDate?: string;
            /** Format: yyyy-MM-dd */
            createdDate?: string;
            /** Format: yyyy-MM-dd */
            modifiedDate?: string;
            notes?: string;
            annotations?: components["schemas"]["DwQuery_Annotation"][];
            completeListTaxonId?: string;
            completeListType?: string;
            editorUserIds?: string[];
            facts?: components["schemas"]["DwQuery_Fact"][];
            formId?: string;
            media?: components["schemas"]["DwQuery_MediaObject"][];
            mediaCount?: number;
            namedPlace?: components["schemas"]["DwQuery_NamedPlaceEntity"];
            prefix?: string;
            referenceURL?: string;
            secured?: boolean;
            siteDead?: boolean;
            sourceTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
        };
        DwQuery_Gathering: {
            /** Format: URI */
            gatheringId?: string;
            gatheringOrder?: number;
            gatheringSection?: number;
            quality?: components["schemas"]["DwQuery_GatheringQuality"];
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            geo?: Record<string, never>;
            eventDate?: components["schemas"]["DwQuery_DateRange"];
            hourBegin?: number;
            hourEnd?: number;
            displayDateTime?: string;
            team?: string[];
            conversions?: components["schemas"]["DwQuery_GatheringConversions"];
            interpretations?: components["schemas"]["DwQuery_GatheringInterpretations"];
            stateLand?: boolean;
            accurateArea?: boolean;
            higherGeography?: string;
            country?: string;
            municipality?: string;
            biogeographicalProvince?: string;
            province?: string;
            locality?: string;
            notes?: string;
            coordinatesVerbatim?: string;
            facts?: components["schemas"]["DwQuery_Fact"][];
            linkings?: components["schemas"]["DwQuery_GatheringDWLinkings"];
            media?: components["schemas"]["DwQuery_MediaObject"][];
            mediaCount?: number;
            minutesBegin?: number;
            minutesEnd?: number;
            observerUserIds?: string[];
            taxonCensus?: components["schemas"]["DwQuery_TaxonCensus"][];
        };
        DwQuery_Unit: {
            /** Format: URI */
            unitId?: string;
            unitOrder?: number;
            taxonVerbatim?: string;
            quality?: components["schemas"]["DwQuery_UnitQuality"];
            /** @enum {string} */
            reportedTaxonConfidence?: "SURE" | "UNSURE" | "SUBSPECIES_UNSURE";
            linkings?: components["schemas"]["DwQuery_UnitDWLinkings"];
            /** Format: URI */
            referencePublication?: string;
            abundanceString?: string;
            /** @enum {string} */
            abundanceUnit?: "OCCURS_DOES_NOT_OCCUR" | "INDIVIDUAL_COUNT" | "PAIRCOUNT" | "NESTS" | "BREEDING_SITES" | "FEEDING_SITES" | "COLONIES" | "QUEENS" | "FRUITBODIES" | "SPROUTS" | "HUMMOCKS" | "THALLI" | "FLOWERS" | "SPOTS" | "TRUNKS" | "SHELLS" | "DROPPINGS" | "FEEDING_MARKS" | "INDIRECT_MARKS" | "SQUARE_DM" | "SQUARE_M" | "RELATIVE_DENSITY";
            interpretations?: components["schemas"]["DwQuery_UnitInterpretations"];
            /** @enum {string} */
            superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
            /** @enum {string} */
            recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
            typeSpecimen?: boolean;
            det?: string;
            /** @enum {string} */
            sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
            /** @enum {string} */
            lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
            wild?: boolean;
            alive?: boolean;
            local?: boolean;
            keywords?: string[];
            breedingSite?: boolean;
            plantStatusCode?: string;
            atlasCode?: string;
            atlasClass?: string;
            individualId?: string;
            notes?: string;
            annotationCount?: number;
            annotations?: components["schemas"]["DwQuery_Annotation"][];
            audioCount?: number;
            author?: string;
            externalMediaCount?: number;
            facts?: components["schemas"]["DwQuery_Fact"][];
            identificationBasis?: string[];
            identifications?: components["schemas"]["DwQuery_IdentificationEvent"][];
            imageCount?: number;
            individualCountFemale?: number;
            individualCountMale?: number;
            media?: components["schemas"]["DwQuery_MediaObject"][];
            mediaCount?: number;
            modelCount?: number;
            primarySpecimen?: boolean;
            /** Format: URI */
            reportedInformalTaxonGroup?: string;
            /** Format: URI */
            reportedTaxonId?: string;
            sampleCount?: number;
            samples?: components["schemas"]["DwQuery_Sample"][];
            samplingMethod?: string;
            sourceTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            types?: components["schemas"]["DwQuery_TypeSpecimen"][];
            videoCount?: number;
        };
        DwQuery_Sample: {
            /** Format: URI */
            sampleId?: string;
            /** Format: URI */
            collectionId?: string;
            keywords?: string[];
            type?: string;
            quality?: string;
            status?: string;
            material?: string;
            multiple?: boolean;
            sampleOrder?: number;
            notes?: string;
            facts?: components["schemas"]["DwQuery_Fact"][];
        };
        DwQuery_MediaObject: {
            /** @enum {string} */
            mediaType?: "IMAGE" | "AUDIO" | "VIDEO" | "MODEL";
            fullURL?: string;
            thumbnailURL?: string;
            author?: string;
            caption?: string;
            licenseId?: string;
            copyrightOwner?: string;
            fullResolutionMediaAvailable?: boolean;
            highDetailModelURL?: string;
            lowDetailModelURL?: string;
            mp3URL?: string;
            squareThumbnailURL?: string;
            /** Format: URI */
            type?: string;
            videoURL?: string;
            wavURL?: string;
        };
        DwQuery_Coordinates: {
            latMin?: number;
            latMax?: number;
            lonMin?: number;
            lonMax?: number;
        };
        DwQuery_DateRange: {
            /** Format: yyyy-MM-dd */
            begin?: string;
            /** Format: yyyy-MM-dd */
            end?: string;
        };
        DwQuery_Fact: {
            fact?: string;
            value?: string;
            integerValue?: number;
            decimalValue?: number;
        };
        DwQuery_TaxonCensus: {
            /** Format: URI */
            taxonId?: string;
            /** Format: URI */
            type?: string;
        };
        DwQuery_DocumentQuality: {
            issue?: components["schemas"]["DwQuery_Quality"];
        };
        DwQuery_GatheringQuality: {
            issue?: components["schemas"]["DwQuery_Quality"];
            timeIssue?: components["schemas"]["DwQuery_Quality"];
            locationIssue?: components["schemas"]["DwQuery_Quality"];
        };
        DwQuery_UnitQuality: {
            issue?: components["schemas"]["DwQuery_Quality"];
            documentGatheringUnitQualityIssues?: boolean;
        };
        DwQuery_Quality: {
            /** @enum {string} */
            issue?: "REPORTED_UNRELIABLE" | "MEDIA_ISSUE" | "INVALID_CREATED_DATE" | "INVALID_MODIFIED_DATE" | "COORDINATES_COUNTRY_MISMATCH" | "COORDINATES_MUNICIPALITY_MISMATCH" | "TOO_LARGE_AREA" | "INVALID_GEO" | "INVALID_YKJ_COORDINATES" | "INVALID_EUREF_COORDINATES" | "INVALID_WGS84_COORDINATES" | "DATE_END_BEFORE_BEGIN" | "DATE_END_GIVEN_WITHOUT_BEGIN" | "DATE_IN_FUTURE" | "DATE_TOO_FAR_IN_THE_PAST" | "INVALID_DATE" | "RECORD_BASIS_MISSING" | "INVALID_HOUR" | "INVALID_MINUTE" | "TIME_END_BEFORE_BEGIN" | "INVALID_COORDINATES" | "ETL_ISSUE";
            /** @enum {string} */
            source?: "AUTOMATED_FINBIF_VALIDATION" | "ORIGINAL_DOCUMENT" | "QUALITY_CONTROL";
            message?: string;
        };
        DwQuery_IdentificationEvent: {
            notes?: string;
            author?: string;
            det?: string;
            detDate?: string;
            facts?: components["schemas"]["DwQuery_Fact"][];
            /** Format: URI */
            id?: string;
            linkings?: components["schemas"]["DwQuery_IdentificationDwLinkings"];
            preferred?: boolean;
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
        };
        DwQuery_TypeSpecimen: {
            notes?: string;
            author?: string;
            basionymePublication?: string;
            facts?: components["schemas"]["DwQuery_Fact"][];
            /** Format: URI */
            id?: string;
            linkings?: components["schemas"]["DwQuery_IdentificationDwLinkings"];
            publication?: string;
            /** Format: URI */
            status?: string;
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
            typif?: string;
            typifDate?: string;
            /** Format: URI */
            verification?: string;
        };
        DwQuery_DocumentDWLinkings: {
            /** @enum {string} */
            collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
            editors?: components["schemas"]["DwQuery_Person"][];
        };
        DwQuery_GatheringInterpretations: {
            coordinateAccuracy?: number;
            /** @enum {string} */
            sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            countryDisplayname?: string;
            biogeographicalProvinceDisplayname?: string;
            municipalityDisplayname?: string;
            /** @enum {string} */
            sourceOfCountry?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            /** @enum {string} */
            sourceOfBiogeographicalProvince?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            /** @enum {string} */
            sourceOfFinnishMunicipality?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            /** Format: URI */
            biogeographicalProvince?: string;
            biogeographicalProvinces?: string[];
            /** Format: URI */
            country?: string;
            finnishMunicipalities?: string[];
            /** Format: URI */
            finnishMunicipality?: string;
        };
        DwQuery_GatheringConversions: {
            wgs84?: components["schemas"]["DwQuery_Coordinates"];
            wgs84CenterPoint?: components["schemas"]["DwQuery_SingleCoordinates"];
            eurefCenterPoint?: components["schemas"]["DwQuery_SingleCoordinates"];
            euref?: components["schemas"]["DwQuery_Coordinates"];
            ykj?: components["schemas"]["DwQuery_Coordinates"];
            ykj10kmCenter?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj1kmCenter?: components["schemas"]["DwQuery_SingleCoordinates"];
            century?: number;
            decade?: number;
            year?: number;
            month?: number;
            day?: number;
            dayOfYearBegin?: number;
            dayOfYearEnd?: number;
            wgs84WKT?: string;
            /** Format: URI */
            birdAssociationArea?: string;
            boundingBoxAreaInSquareMeters?: number;
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            eurefGeo?: Record<string, never>;
            eurefWKT?: string;
            linelengthInMeters?: number;
            seasonBegin?: number;
            seasonEnd?: number;
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            wgs84Geo?: Record<string, never>;
            wgs84Grid005?: components["schemas"]["DwQuery_SingleCoordinates"];
            wgs84Grid01?: components["schemas"]["DwQuery_SingleCoordinates"];
            wgs84Grid05?: components["schemas"]["DwQuery_SingleCoordinates"];
            wgs84Grid1?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj100km?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj100kmCenter?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj10km?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj1km?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj50km?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj50kmCenter?: components["schemas"]["DwQuery_SingleCoordinates"];
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            ykjGeo?: Record<string, never>;
            ykjWKT?: string;
        };
        DwQuery_GatheringDWLinkings: {
            observers?: components["schemas"]["DwQuery_Person"][];
        };
        DwQuery_UnitDWLinkings: {
            taxon?: components["schemas"]["DwQuery_Taxon"];
            originalTaxon?: components["schemas"]["DwQuery_Taxon"];
        };
        DwQuery_UnitInterpretations: {
            /** Format: URI */
            annotatedTaxonId?: string;
            individualCount?: number;
            pairCount?: number;
            /** @enum {string} */
            invasiveControlEffectiveness?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
            collectionAndRecordQuality?: string;
            effectiveTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            invasiveControlled?: boolean;
            needsCheck?: boolean;
            needsIdentification?: boolean;
            /** @enum {string} */
            recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
            recordQualityNumeric?: number;
            /** @enum {string} */
            reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
        };
        DwQuery_SingleCoordinates: {
            lat?: number;
            lon?: number;
        };
        DwQuery_Person: {
            fullName?: string;
            /** Format: URI */
            id?: string;
            userId?: string;
        };
        DwQuery_Annotation: {
            addedTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            /** Format: URI */
            annotationByPerson?: string;
            annotationByPersonName?: string;
            /** Format: URI */
            annotationBySystem?: string;
            annotationBySystemName?: string;
            /** Format: URI */
            byRole?: string;
            created?: string;
            deleted?: boolean;
            /** Format: URI */
            deletedByPerson?: string;
            deletedByPersonName?: string;
            deletedDateTime?: string;
            /** Format: URI */
            id?: string;
            identification?: components["schemas"]["DwQuery_Identification"];
            notes?: string;
            occurrenceAtTimeOfAnnotation?: components["schemas"]["DwQuery_OccurrenceAtTimeOfAnnotation"];
            removedTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            valid?: boolean;
        };
        DwQuery_Identification: {
            notes?: string;
            author?: string;
            facts?: components["schemas"]["DwQuery_Fact"][];
            /** Format: URI */
            id?: string;
            linkings?: components["schemas"]["DwQuery_IdentificationDwLinkings"];
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
        };
        DwQuery_OccurrenceAtTimeOfAnnotation: {
            countryVerbatim?: string;
            /** Format: yyyy-MM-dd */
            dateBegin?: string;
            /** Format: yyyy-MM-dd */
            dateEnd?: string;
            linkings?: components["schemas"]["DwQuery_IdentificationDwLinkings"];
            locality?: string;
            municipalityVerbatim?: string;
            /** Format: URI */
            taxonId?: string;
            taxonVerbatim?: string;
            wgs84centerPointLat?: number;
            wgs84centerPointLon?: number;
        };
        DwQuery_IdentificationDwLinkings: {
            taxon?: components["schemas"]["DwQuery_Taxon"];
        };
        DwQuery_RedListStatus: {
            /** Format: URI */
            status?: string;
            year?: number;
        };
        DwQuery_HabitatObject: {
            /** Format: URI */
            habitat?: string;
            habitatSpecificTypes?: string[];
            /** Format: URI */
            id?: string;
            order?: number;
        };
        DwQuery_NamedPlaceEntity: {
            alternativeId?: string;
            alternativeIds?: string;
            birdAssociationAreaDisplayName?: string;
            birdAssociationAreaId?: string;
            collectionId?: string;
            id?: string;
            municipalityDisplayName?: string;
            municipalityId?: string;
            name?: string;
            tags?: string[];
            wgs84CenterPoint?: components["schemas"]["DwQuery_SingleCoordinates"];
            ykj10km?: components["schemas"]["DwQuery_SingleCoordinates"];
        };
        DwETL_DwRoot: {
            /** Format: URI */
            documentId?: string;
            /** Format: URI */
            sourceId?: string;
            /** Format: URI */
            collectionId?: string;
            publicDocument?: components["schemas"]["DwETL_Document"];
            privateDocument?: components["schemas"]["DwETL_Document"];
            deleteRequest?: boolean;
        };
        DwETL_Document: {
            /** Format: URI */
            documentId?: string;
            /** @enum {string} */
            secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
            secureReasons?: ("DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME")[];
            /** Format: URI */
            collectionId?: string;
            licenseId?: string;
            dataSource?: string;
            quality?: components["schemas"]["DwETL_DocumentQuality"];
            /** Format: URI */
            sourceId?: string;
            namedPlaceId?: string;
            siteType?: string;
            siteStatus?: string;
            keywords?: string[];
            /** Format: yyyy-MM-dd */
            createdDate?: string;
            /** Format: yyyy-MM-dd */
            modifiedDate?: string;
            notes?: string;
            completeListTaxonId?: string;
            completeListType?: string;
            /** @enum {string} */
            concealment?: "PUBLIC" | "PRIVATE";
            deleted?: boolean;
            editorUserIds?: string[];
            facts?: components["schemas"]["DwETL_Fact"][];
            formId?: string;
            gatherings?: components["schemas"]["DwETL_Gathering"][];
            media?: components["schemas"]["DwETL_MediaObject"][];
            referenceURL?: string;
            siteDead?: boolean;
            sourceTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
        };
        DwETL_Gathering: {
            /** Format: URI */
            gatheringId?: string;
            gatheringSection?: number;
            quality?: components["schemas"]["DwETL_GatheringQuality"];
            coordinates?: components["schemas"]["DwETL_Coordinates"];
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            geo?: Record<string, never>;
            eventDate?: components["schemas"]["DwETL_DateRange"];
            hourBegin?: number;
            hourEnd?: number;
            team?: string[];
            stateLand?: boolean;
            accurateArea?: boolean;
            higherGeography?: string;
            country?: string;
            municipality?: string;
            biogeographicalProvince?: string;
            province?: string;
            locality?: string;
            notes?: string;
            coordinatesVerbatim?: string;
            facts?: components["schemas"]["DwETL_Fact"][];
            media?: components["schemas"]["DwETL_MediaObject"][];
            minutesBegin?: number;
            minutesEnd?: number;
            observerUserIds?: string[];
            taxonCensus?: components["schemas"]["DwETL_TaxonCensus"][];
            units?: components["schemas"]["DwETL_Unit"][];
        };
        DwETL_Unit: {
            /** Format: URI */
            unitId?: string;
            taxonVerbatim?: string;
            quality?: components["schemas"]["DwETL_UnitQuality"];
            /** @enum {string} */
            reportedTaxonConfidence?: "SURE" | "UNSURE" | "SUBSPECIES_UNSURE";
            /** Format: URI */
            referencePublication?: string;
            abundanceString?: string;
            /** @enum {string} */
            abundanceUnit?: "OCCURS_DOES_NOT_OCCUR" | "INDIVIDUAL_COUNT" | "PAIRCOUNT" | "NESTS" | "BREEDING_SITES" | "FEEDING_SITES" | "COLONIES" | "QUEENS" | "FRUITBODIES" | "SPROUTS" | "HUMMOCKS" | "THALLI" | "FLOWERS" | "SPOTS" | "TRUNKS" | "SHELLS" | "DROPPINGS" | "FEEDING_MARKS" | "INDIRECT_MARKS" | "SQUARE_DM" | "SQUARE_M" | "RELATIVE_DENSITY";
            /** @enum {string} */
            recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
            typeSpecimen?: boolean;
            det?: string;
            /** @enum {string} */
            sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
            /** @enum {string} */
            lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
            wild?: boolean;
            alive?: boolean;
            local?: boolean;
            keywords?: string[];
            breedingSite?: boolean;
            plantStatusCode?: string;
            atlasCode?: string;
            atlasClass?: string;
            individualId?: string;
            notes?: string;
            author?: string;
            /** Format: URI */
            autocompleteSelectedTaxonId?: string;
            externalMediaCount?: number;
            facts?: components["schemas"]["DwETL_Fact"][];
            identificationBasis?: string[];
            identifications?: components["schemas"]["DwETL_IdentificationEvent"][];
            individualCountFemale?: number;
            individualCountMale?: number;
            media?: components["schemas"]["DwETL_MediaObject"][];
            primarySpecimen?: boolean;
            /** Format: URI */
            reportedInformalTaxonGroup?: string;
            /** Format: URI */
            reportedTaxonId?: string;
            samples?: components["schemas"]["DwETL_Sample"][];
            samplingMethod?: string;
            sourceTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            types?: components["schemas"]["DwETL_TypeSpecimen"][];
        };
        DwETL_Sample: {
            /** Format: URI */
            sampleId?: string;
            /** Format: URI */
            collectionId?: string;
            keywords?: string[];
            type?: string;
            quality?: string;
            status?: string;
            material?: string;
            multiple?: boolean;
            notes?: string;
            facts?: components["schemas"]["DwETL_Fact"][];
        };
        DwETL_MediaObject: {
            /** @enum {string} */
            mediaType?: "IMAGE" | "AUDIO" | "VIDEO" | "MODEL";
            fullURL?: string;
            thumbnailURL?: string;
            author?: string;
            caption?: string;
            licenseId?: string;
            copyrightOwner?: string;
            fullResolutionMediaAvailable?: boolean;
            highDetailModelURL?: string;
            /** Format: URI */
            id?: string;
            lowDetailModelURL?: string;
            mp3URL?: string;
            squareThumbnailURL?: string;
            /** Format: URI */
            type?: string;
            videoURL?: string;
            wavURL?: string;
        };
        DwETL_Coordinates: {
            latMin?: number;
            latMax?: number;
            lonMin?: number;
            lonMax?: number;
            accuracyInMeters?: number;
            /** @enum {string} */
            type?: "WGS84" | "EUREF" | "YKJ";
        };
        DwETL_DateRange: {
            /** Format: yyyy-MM-dd */
            begin?: string;
            /** Format: yyyy-MM-dd */
            end?: string;
        };
        DwETL_Fact: {
            fact?: string;
            value?: string;
        };
        DwETL_TaxonCensus: {
            /** Format: URI */
            taxonId?: string;
            /** Format: URI */
            type?: string;
        };
        DwETL_DocumentQuality: {
            issue?: components["schemas"]["DwETL_Quality"];
        };
        DwETL_GatheringQuality: {
            issue?: components["schemas"]["DwETL_Quality"];
            timeIssue?: components["schemas"]["DwETL_Quality"];
            locationIssue?: components["schemas"]["DwETL_Quality"];
        };
        DwETL_UnitQuality: {
            issue?: components["schemas"]["DwETL_Quality"];
        };
        DwETL_Quality: {
            /** @enum {string} */
            issue?: "REPORTED_UNRELIABLE" | "MEDIA_ISSUE" | "INVALID_CREATED_DATE" | "INVALID_MODIFIED_DATE" | "COORDINATES_COUNTRY_MISMATCH" | "COORDINATES_MUNICIPALITY_MISMATCH" | "TOO_LARGE_AREA" | "INVALID_GEO" | "INVALID_YKJ_COORDINATES" | "INVALID_EUREF_COORDINATES" | "INVALID_WGS84_COORDINATES" | "DATE_END_BEFORE_BEGIN" | "DATE_END_GIVEN_WITHOUT_BEGIN" | "DATE_IN_FUTURE" | "DATE_TOO_FAR_IN_THE_PAST" | "INVALID_DATE" | "RECORD_BASIS_MISSING" | "INVALID_HOUR" | "INVALID_MINUTE" | "TIME_END_BEFORE_BEGIN" | "INVALID_COORDINATES" | "ETL_ISSUE";
            /** @enum {string} */
            source?: "AUTOMATED_FINBIF_VALIDATION" | "ORIGINAL_DOCUMENT" | "QUALITY_CONTROL";
            message?: string;
        };
        DwETL_IdentificationEvent: {
            notes?: string;
            author?: string;
            det?: string;
            detDate?: string;
            facts?: components["schemas"]["DwETL_Fact"][];
            /** Format: URI */
            id?: string;
            preferred?: boolean;
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
        };
        DwETL_TypeSpecimen: {
            notes?: string;
            author?: string;
            basionymePublication?: string;
            facts?: components["schemas"]["DwETL_Fact"][];
            /** Format: URI */
            id?: string;
            publication?: string;
            /** Format: URI */
            status?: string;
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
            typif?: string;
            typifDate?: string;
            /** Format: URI */
            verification?: string;
        };
        DwSingle_Document: {
            /** Format: URI */
            documentId?: string;
            /** @enum {string} */
            secureLevel?: "NOSHOW" | "HIGHEST" | "KM100" | "KM50" | "KM25" | "KM10" | "KM5" | "KM1" | "NONE";
            secureReasons?: ("DEFAULT_TAXON_CONSERVATION" | "BREEDING_SITE_CONSERVATION" | "NATURA_AREA_CONSERVATION" | "WINTER_SEASON_TAXON_CONSERVATION" | "BREEDING_SEASON_TAXON_CONSERVATION" | "CUSTOM" | "USER_HIDDEN" | "ADMIN_HIDDEN" | "DATA_QUARANTINE_PERIOD" | "ONLY_PRIVATE" | "USER_PERSON_NAMES_HIDDEN" | "USER_HIDDEN_LOCATION" | "USER_HIDDEN_TIME")[];
            partial?: boolean;
            /** Format: URI */
            collectionId?: string;
            licenseId?: string;
            dataSource?: string;
            linkings?: components["schemas"]["DwSingle_DocumentDWLinkings"];
            quality?: components["schemas"]["DwSingle_DocumentQuality"];
            /** Format: URI */
            sourceId?: string;
            namedPlaceId?: string;
            siteType?: string;
            siteStatus?: string;
            keywords?: string[];
            /** Format: yyyy-MM-dd */
            firstLoadDate?: string;
            /** Format: yyyy-MM-dd */
            loadDate?: string;
            /** Format: yyyy-MM-dd */
            createdDate?: string;
            /** Format: yyyy-MM-dd */
            modifiedDate?: string;
            notes?: string;
            annotations?: components["schemas"]["DwSingle_Annotation"][];
            completeListTaxonId?: string;
            completeListType?: string;
            editorUserIds?: string[];
            facts?: components["schemas"]["DwSingle_Fact"][];
            formId?: string;
            gatherings?: components["schemas"]["DwSingle_Gathering"][];
            media?: components["schemas"]["DwSingle_MediaObject"][];
            mediaCount?: number;
            namedPlace?: components["schemas"]["DwSingle_NamedPlaceEntity"];
            prefix?: string;
            referenceURL?: string;
            secured?: boolean;
            siteDead?: boolean;
            sourceTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
        };
        DwSingle_Gathering: {
            /** Format: URI */
            gatheringId?: string;
            gatheringOrder?: number;
            gatheringSection?: number;
            quality?: components["schemas"]["DwSingle_GatheringQuality"];
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            geo?: Record<string, never>;
            eventDate?: components["schemas"]["DwSingle_DateRange"];
            hourBegin?: number;
            hourEnd?: number;
            displayDateTime?: string;
            team?: string[];
            conversions?: components["schemas"]["DwSingle_GatheringConversions"];
            interpretations?: components["schemas"]["DwSingle_GatheringInterpretations"];
            stateLand?: boolean;
            accurateArea?: boolean;
            higherGeography?: string;
            country?: string;
            municipality?: string;
            biogeographicalProvince?: string;
            province?: string;
            locality?: string;
            notes?: string;
            coordinatesVerbatim?: string;
            facts?: components["schemas"]["DwSingle_Fact"][];
            linkings?: components["schemas"]["DwSingle_GatheringDWLinkings"];
            media?: components["schemas"]["DwSingle_MediaObject"][];
            mediaCount?: number;
            minutesBegin?: number;
            minutesEnd?: number;
            observerUserIds?: string[];
            taxonCensus?: components["schemas"]["DwSingle_TaxonCensus"][];
            units?: components["schemas"]["DwSingle_Unit"][];
        };
        DwSingle_Unit: {
            /** Format: URI */
            unitId?: string;
            unitOrder?: number;
            taxonVerbatim?: string;
            quality?: components["schemas"]["DwSingle_UnitQuality"];
            /** @enum {string} */
            reportedTaxonConfidence?: "SURE" | "UNSURE" | "SUBSPECIES_UNSURE";
            linkings?: components["schemas"]["DwSingle_UnitDWLinkings"];
            /** Format: URI */
            referencePublication?: string;
            abundanceString?: string;
            /** @enum {string} */
            abundanceUnit?: "OCCURS_DOES_NOT_OCCUR" | "INDIVIDUAL_COUNT" | "PAIRCOUNT" | "NESTS" | "BREEDING_SITES" | "FEEDING_SITES" | "COLONIES" | "QUEENS" | "FRUITBODIES" | "SPROUTS" | "HUMMOCKS" | "THALLI" | "FLOWERS" | "SPOTS" | "TRUNKS" | "SHELLS" | "DROPPINGS" | "FEEDING_MARKS" | "INDIRECT_MARKS" | "SQUARE_DM" | "SQUARE_M" | "RELATIVE_DENSITY";
            interpretations?: components["schemas"]["DwSingle_UnitInterpretations"];
            /** @enum {string} */
            superRecordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
            /** @enum {string} */
            recordBasis?: "PRESERVED_SPECIMEN" | "LIVING_SPECIMEN" | "FOSSIL_SPECIMEN" | "SUBFOSSIL_SPECIMEN" | "SUBFOSSIL_AMBER_INCLUSION_SPECIMEN" | "MICROBIAL_SPECIMEN" | "HUMAN_OBSERVATION_UNSPECIFIED" | "HUMAN_OBSERVATION_SEEN" | "HUMAN_OBSERVATION_HEARD" | "HUMAN_OBSERVATION_PHOTO" | "HUMAN_OBSERVATION_INDIRECT" | "HUMAN_OBSERVATION_HANDLED" | "HUMAN_OBSERVATION_VIDEO" | "HUMAN_OBSERVATION_RECORDED_AUDIO" | "MACHINE_OBSERVATION_UNSPECIFIED" | "MACHINE_OBSERVATION_PHOTO" | "MACHINE_OBSERVATION_VIDEO" | "MACHINE_OBSERVATION_AUDIO" | "MACHINE_OBSERVATION_GEOLOGGER" | "MACHINE_OBSERVATION_SATELLITE_TRANSMITTER" | "LITERATURE" | "MATERIAL_SAMPLE" | "MATERIAL_SAMPLE_AIR" | "MATERIAL_SAMPLE_SOIL" | "MATERIAL_SAMPLE_WATER";
            typeSpecimen?: boolean;
            det?: string;
            /** @enum {string} */
            sex?: "MALE" | "FEMALE" | "WORKER" | "UNKNOWN" | "NOT_APPLICABLE" | "GYNANDROMORPH" | "MULTIPLE" | "CONFLICTING";
            /** @enum {string} */
            lifeStage?: "ADULT" | "JUVENILE" | "IMMATURE" | "EGG" | "TADPOLE" | "PUPA" | "NYMPH" | "SUBIMAGO" | "LARVA" | "SNAG" | "EMBRYO" | "SUBADULT" | "MATURE" | "STERILE" | "FERTILE" | "SPROUT" | "DEAD_SPROUT" | "BUD" | "FLOWER" | "WITHERED_FLOWER" | "SEED" | "RIPENING_FRUIT" | "RIPE_FRUIT" | "SUBTERRANEAN" | "GALL" | "MARKS" | "TRIUNGULIN";
            wild?: boolean;
            alive?: boolean;
            local?: boolean;
            keywords?: string[];
            breedingSite?: boolean;
            plantStatusCode?: string;
            atlasCode?: string;
            atlasClass?: string;
            individualId?: string;
            notes?: string;
            annotationCount?: number;
            annotations?: components["schemas"]["DwSingle_Annotation"][];
            audioCount?: number;
            author?: string;
            externalMediaCount?: number;
            facts?: components["schemas"]["DwSingle_Fact"][];
            identificationBasis?: string[];
            identifications?: components["schemas"]["DwSingle_IdentificationEvent"][];
            imageCount?: number;
            individualCountFemale?: number;
            individualCountMale?: number;
            media?: components["schemas"]["DwSingle_MediaObject"][];
            mediaCount?: number;
            modelCount?: number;
            primarySpecimen?: boolean;
            /** Format: URI */
            reportedInformalTaxonGroup?: string;
            /** Format: URI */
            reportedTaxonId?: string;
            sampleCount?: number;
            samples?: components["schemas"]["DwSingle_Sample"][];
            samplingMethod?: string;
            sourceTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            types?: components["schemas"]["DwSingle_TypeSpecimen"][];
            videoCount?: number;
        };
        DwSingle_Sample: {
            /** Format: URI */
            sampleId?: string;
            /** Format: URI */
            collectionId?: string;
            keywords?: string[];
            type?: string;
            quality?: string;
            status?: string;
            material?: string;
            multiple?: boolean;
            sampleOrder?: number;
            notes?: string;
            facts?: components["schemas"]["DwSingle_Fact"][];
        };
        DwSingle_MediaObject: {
            /** @enum {string} */
            mediaType?: "IMAGE" | "AUDIO" | "VIDEO" | "MODEL";
            fullURL?: string;
            thumbnailURL?: string;
            author?: string;
            caption?: string;
            licenseId?: string;
            copyrightOwner?: string;
            fullResolutionMediaAvailable?: boolean;
            highDetailModelURL?: string;
            lowDetailModelURL?: string;
            mp3URL?: string;
            squareThumbnailURL?: string;
            /** Format: URI */
            type?: string;
            videoURL?: string;
            wavURL?: string;
        };
        DwSingle_Coordinates: {
            latMin?: number;
            latMax?: number;
            lonMin?: number;
            lonMax?: number;
        };
        DwSingle_DateRange: {
            /** Format: yyyy-MM-dd */
            begin?: string;
            /** Format: yyyy-MM-dd */
            end?: string;
        };
        DwSingle_Fact: {
            fact?: string;
            value?: string;
            integerValue?: number;
            decimalValue?: number;
        };
        DwSingle_TaxonCensus: {
            /** Format: URI */
            taxonId?: string;
            /** Format: URI */
            type?: string;
        };
        DwSingle_DocumentQuality: {
            issue?: components["schemas"]["DwSingle_Quality"];
        };
        DwSingle_GatheringQuality: {
            issue?: components["schemas"]["DwSingle_Quality"];
            timeIssue?: components["schemas"]["DwSingle_Quality"];
            locationIssue?: components["schemas"]["DwSingle_Quality"];
        };
        DwSingle_UnitQuality: {
            issue?: components["schemas"]["DwSingle_Quality"];
            documentGatheringUnitQualityIssues?: boolean;
        };
        DwSingle_Quality: {
            /** @enum {string} */
            issue?: "REPORTED_UNRELIABLE" | "MEDIA_ISSUE" | "INVALID_CREATED_DATE" | "INVALID_MODIFIED_DATE" | "COORDINATES_COUNTRY_MISMATCH" | "COORDINATES_MUNICIPALITY_MISMATCH" | "TOO_LARGE_AREA" | "INVALID_GEO" | "INVALID_YKJ_COORDINATES" | "INVALID_EUREF_COORDINATES" | "INVALID_WGS84_COORDINATES" | "DATE_END_BEFORE_BEGIN" | "DATE_END_GIVEN_WITHOUT_BEGIN" | "DATE_IN_FUTURE" | "DATE_TOO_FAR_IN_THE_PAST" | "INVALID_DATE" | "RECORD_BASIS_MISSING" | "INVALID_HOUR" | "INVALID_MINUTE" | "TIME_END_BEFORE_BEGIN" | "INVALID_COORDINATES" | "ETL_ISSUE";
            /** @enum {string} */
            source?: "AUTOMATED_FINBIF_VALIDATION" | "ORIGINAL_DOCUMENT" | "QUALITY_CONTROL";
            message?: string;
        };
        DwSingle_IdentificationEvent: {
            notes?: string;
            author?: string;
            det?: string;
            detDate?: string;
            facts?: components["schemas"]["DwSingle_Fact"][];
            /** Format: URI */
            id?: string;
            linkings?: components["schemas"]["DwSingle_IdentificationDwLinkings"];
            preferred?: boolean;
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
        };
        DwSingle_TypeSpecimen: {
            notes?: string;
            author?: string;
            basionymePublication?: string;
            facts?: components["schemas"]["DwSingle_Fact"][];
            /** Format: URI */
            id?: string;
            linkings?: components["schemas"]["DwSingle_IdentificationDwLinkings"];
            publication?: string;
            /** Format: URI */
            status?: string;
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
            typif?: string;
            typifDate?: string;
            /** Format: URI */
            verification?: string;
        };
        DwSingle_DocumentDWLinkings: {
            /** @enum {string} */
            collectionQuality?: "PROFESSIONAL" | "HOBBYIST" | "AMATEUR";
            editors?: components["schemas"]["DwSingle_Person"][];
        };
        DwSingle_GatheringInterpretations: {
            coordinateAccuracy?: number;
            /** @enum {string} */
            sourceOfCoordinates?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            countryDisplayname?: string;
            biogeographicalProvinceDisplayname?: string;
            municipalityDisplayname?: string;
            /** @enum {string} */
            sourceOfCountry?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            /** @enum {string} */
            sourceOfBiogeographicalProvince?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            /** @enum {string} */
            sourceOfFinnishMunicipality?: "COORDINATES" | "COORDINATE_CENTERPOINT" | "REPORTED_VALUE" | "FINNISH_MUNICIPALITY" | "OLD_FINNISH_MUNICIPALITY";
            /** Format: URI */
            biogeographicalProvince?: string;
            biogeographicalProvinces?: string[];
            /** Format: URI */
            country?: string;
            finnishMunicipalities?: string[];
            /** Format: URI */
            finnishMunicipality?: string;
        };
        DwSingle_GatheringConversions: {
            wgs84?: components["schemas"]["DwSingle_Coordinates"];
            wgs84CenterPoint?: components["schemas"]["DwSingle_SingleCoordinates"];
            eurefCenterPoint?: components["schemas"]["DwSingle_SingleCoordinates"];
            euref?: components["schemas"]["DwSingle_Coordinates"];
            ykj?: components["schemas"]["DwSingle_Coordinates"];
            ykj10kmCenter?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj1kmCenter?: components["schemas"]["DwSingle_SingleCoordinates"];
            century?: number;
            decade?: number;
            year?: number;
            month?: number;
            day?: number;
            dayOfYearBegin?: number;
            dayOfYearEnd?: number;
            wgs84WKT?: string;
            /** Format: URI */
            birdAssociationArea?: string;
            boundingBoxAreaInSquareMeters?: number;
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            eurefGeo?: Record<string, never>;
            eurefWKT?: string;
            linelengthInMeters?: number;
            seasonBegin?: number;
            seasonEnd?: number;
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            wgs84Geo?: Record<string, never>;
            wgs84Grid005?: components["schemas"]["DwSingle_SingleCoordinates"];
            wgs84Grid01?: components["schemas"]["DwSingle_SingleCoordinates"];
            wgs84Grid05?: components["schemas"]["DwSingle_SingleCoordinates"];
            wgs84Grid1?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj100km?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj100kmCenter?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj10km?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj1km?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj50km?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj50kmCenter?: components["schemas"]["DwSingle_SingleCoordinates"];
            /** @description GeoJSON object with custom "crs" required property that takes in values WGS84,EUREF,YKJ (WGS84 = EPSG:4326; EUREF = ETRS-TM35FIN EPSG:3067; YKJ = EPSG:2393) */
            ykjGeo?: Record<string, never>;
            ykjWKT?: string;
        };
        DwSingle_GatheringDWLinkings: {
            observers?: components["schemas"]["DwSingle_Person"][];
        };
        DwSingle_UnitDWLinkings: {
            taxon?: components["schemas"]["DwSingle_Taxon"];
            originalTaxon?: components["schemas"]["DwSingle_Taxon"];
        };
        DwSingle_UnitInterpretations: {
            /** Format: URI */
            annotatedTaxonId?: string;
            individualCount?: number;
            pairCount?: number;
            /** @enum {string} */
            invasiveControlEffectiveness?: "FULL" | "PARTIAL" | "NO_EFFECT" | "NOT_FOUND";
            collectionAndRecordQuality?: string;
            effectiveTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            invasiveControlled?: boolean;
            needsCheck?: boolean;
            needsIdentification?: boolean;
            /** @enum {string} */
            recordQuality?: "EXPERT_VERIFIED" | "COMMUNITY_VERIFIED" | "NEUTRAL" | "UNCERTAIN" | "ERRONEOUS";
            recordQualityNumeric?: number;
            /** @enum {string} */
            reliability?: "RELIABLE" | "UNDEFINED" | "UNRELIABLE";
        };
        DwSingle_SingleCoordinates: {
            lat?: number;
            lon?: number;
        };
        DwSingle_Person: {
            fullName?: string;
            /** Format: URI */
            id?: string;
            userId?: string;
        };
        DwSingle_Annotation: {
            addedTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            /** Format: URI */
            annotationByPerson?: string;
            annotationByPersonName?: string;
            /** Format: URI */
            annotationBySystem?: string;
            annotationBySystemName?: string;
            /** Format: URI */
            byRole?: string;
            created?: string;
            deleted?: boolean;
            /** Format: URI */
            deletedByPerson?: string;
            deletedByPersonName?: string;
            deletedDateTime?: string;
            /** Format: URI */
            id?: string;
            identification?: components["schemas"]["DwSingle_Identification"];
            notes?: string;
            occurrenceAtTimeOfAnnotation?: components["schemas"]["DwSingle_OccurrenceAtTimeOfAnnotation"];
            removedTags?: ("ADMIN_MARKED_SPAM" | "ADMIN_MARKED_COARSE" | "ADMIN_MARKED_NON_WILD" | "EXPERT_TAG_VERIFIED" | "EXPERT_TAG_UNCERTAIN" | "EXPERT_TAG_ERRONEOUS" | "COMMUNITY_TAG_VERIFIED" | "AUTO_VALIDATIONS_PASS" | "CHECKED_CANNOT_VERIFY" | "CHANGED_OWNER_MANUAL" | "CHANGED_DW_AUTO" | "CHECK" | "CHECK_COORDINATES" | "CHECK_DATETIME" | "CHECK_LOCATION" | "CHECK_OBSERVER" | "CHECK_TAXON" | "CHECK_DUPLICATE" | "CHECK_WILDNESS" | "CHECK_NEEDS_INFO" | "CHECK_SPAM" | "CHECK_BREEDING_INDEX" | "AUTO_DISTRIBUTION_CHECK" | "AUTO_PERIOD_CHECK" | "FORMADMIN_CENSUS_COUNT_ERROR" | "FORMADMIN_CENSUS_INNER_COUNT_ERROR" | "FORMADMIN_CENSUS_OTHER_ERROR" | "FORMADMIN_VERIFIED" | "FORMADMIN_UNCERTAIN" | "INVASIVE_FULL" | "INVASIVE_PARTIAL" | "INVASIVE_NO_EFFECT" | "INVASIVE_NOT_FOUND")[];
            valid?: boolean;
        };
        DwSingle_Identification: {
            notes?: string;
            author?: string;
            facts?: components["schemas"]["DwSingle_Fact"][];
            /** Format: URI */
            id?: string;
            linkings?: components["schemas"]["DwSingle_IdentificationDwLinkings"];
            taxon?: string;
            /** Format: URI */
            taxonID?: string;
            taxonSpecifier?: string;
            taxonSpecifierAuthor?: string;
        };
        DwSingle_OccurrenceAtTimeOfAnnotation: {
            countryVerbatim?: string;
            /** Format: yyyy-MM-dd */
            dateBegin?: string;
            /** Format: yyyy-MM-dd */
            dateEnd?: string;
            linkings?: components["schemas"]["DwSingle_IdentificationDwLinkings"];
            locality?: string;
            municipalityVerbatim?: string;
            /** Format: URI */
            taxonId?: string;
            taxonVerbatim?: string;
            wgs84centerPointLat?: number;
            wgs84centerPointLon?: number;
        };
        DwSingle_IdentificationDwLinkings: {
            taxon?: components["schemas"]["DwSingle_Taxon"];
        };
        DwSingle_RedListStatus: {
            /** Format: URI */
            status?: string;
            year?: number;
        };
        DwSingle_HabitatObject: {
            /** Format: URI */
            habitat?: string;
            habitatSpecificTypes?: string[];
            /** Format: URI */
            id?: string;
            order?: number;
        };
        DwSingle_NamedPlaceEntity: {
            alternativeId?: string;
            alternativeIds?: string;
            birdAssociationAreaDisplayName?: string;
            birdAssociationAreaId?: string;
            collectionId?: string;
            id?: string;
            municipalityDisplayName?: string;
            municipalityId?: string;
            name?: string;
            tags?: string[];
            wgs84CenterPoint?: components["schemas"]["DwSingle_SingleCoordinates"];
            ykj10km?: components["schemas"]["DwSingle_SingleCoordinates"];
        };
        DwQuery_Taxon: {
            /** Format: URI */
            id?: string;
            /** Format: URI */
            checklist?: string;
            scientificName?: string;
            scientificNameAuthorship?: string;
            scientificNameDisplayName?: string;
            cursiveName?: boolean;
            finnish?: boolean;
            /** Format: URI */
            taxonRank?: string;
            vernacularName?: Record<string, never>;
            nameFinnish?: string;
            nameSwedish?: string;
            nameEnglish?: string;
            informalTaxonGroups?: string[];
            taxonomicOrder?: number;
            latestRedListStatusFinland?: components["schemas"]["DwQuery_RedListStatus"];
            sensitive?: boolean;
            kingdomScientificName?: string;
            occurrenceCountFinland?: number;
            primaryHabitat?: components["schemas"]["DwQuery_HabitatObject"];
            administrativeStatuses?: string[];
            /** Format: URI */
            threatenedStatus?: string;
            taxonConceptIds?: string[];
        };
        DwSingle_Taxon: {
            /** Format: URI */
            id?: string;
            /** Format: URI */
            checklist?: string;
            scientificName?: string;
            scientificNameAuthorship?: string;
            scientificNameDisplayName?: string;
            cursiveName?: boolean;
            finnish?: boolean;
            /** Format: URI */
            taxonRank?: string;
            vernacularName?: Record<string, never>;
            nameFinnish?: string;
            nameSwedish?: string;
            nameEnglish?: string;
            informalTaxonGroups?: string[];
            taxonomicOrder?: number;
            latestRedListStatusFinland?: components["schemas"]["DwSingle_RedListStatus"];
            sensitive?: boolean;
            kingdomScientificName?: string;
            occurrenceCountFinland?: number;
            primaryHabitat?: components["schemas"]["DwSingle_HabitatObject"];
            administrativeStatuses?: string[];
            /** Format: URI */
            threatenedStatus?: string;
            taxonConceptIds?: string[];
        };
        DwError: {
            status?: number;
            message?: string;
        };
        TaxonSearchResponse: {
            /** @description Name that matched the search word */
            matchingName?: string;
            /**
             * @description Type of the name.
             * @enum {string}
             */
            nameType?: "MX.scientificName" | "MX.vernacularName" | "MX.hasSynonym" | "MX.hasBasionym" | "MX.alternativeVernacularName" | "MX.hasMisappliedName" | "MX.birdlifeCode" | "MX.obsoleteVernacularName" | "MX.euringCode" | "MX.hasSubjectiveSynonym" | "MX.hasAlternativeName" | "MX.hasOrthographicVariant" | "MX.hasObjectiveSynonym" | "MX.hasMisspelledName" | "MX.colloquialVernacularName" | "MX.hasUncertainSynonym" | "MX.hasHomotypicSynonym" | "MX.tradeName" | "MX.hasHeterotypicSynonym";
            /** @description Taxon identifier of the taxon that has the matching name; in the short Qname format, for example 'MX.123' */
            id?: string;
            /** @description Accepted scientific name of the taxon that has the matching name */
            scientificName?: string;
            /** @description Author of the above mentioned scientific name */
            scientificNameAuthorship?: string;
            /** @description Taxonomic rank of the taxon that has the matching name; in the short Qname format, for example 'MX.genus' */
            taxonRank?: string;
            /** @description Should the matching name be cursived */
            cursiveName?: boolean;
            /** @description Is the taxon that has the mathing name marked as a Finnish taxon */
            finnish?: boolean;
            /** @description Is the taxon that has the mathing name species level or lower, or a higher taxon */
            species?: boolean;
            vernacularName?: components["schemas"]["LocalizedText"];
            informalGroups?: {
                /** @description Identifier of the informal taxon group that the matching taxon belongs to); in the short Qname format, for example 'MVL.1' */
                id?: string;
                name?: components["schemas"]["LocalizedText"];
            }[];
            /** @description Scientific name of the kingdom that the matching taxon belongs to */
            kingdomScientificName?: string;
            /**
             * @description Type of the matching name
             * @enum {string}
             */
            type?: "exactMatches" | "partialMatches" | "likelyMatches";
        }[];
        TaxonSearchError: {
            error?: {
                /** @description HTTP Status Code */
                statusCode?: number;
                name?: string;
                message?: string;
            };
        };
        Taxon: {
            /** @description Qname identifier */
            qname?: string;
            /** @description Qname identifier */
            id?: string;
            /** @description Qname identifier */
            isPartOf?: string;
            /** @description Qname identifier */
            isPartOfNonHidden?: string;
            parents?: string[];
            nonHiddenParents?: string[];
            depth?: number;
            nonHiddenDepth?: number;
            parentsIncludeSelf?: string[];
            nonHiddenParentsIncludeSelf?: string[];
            hiddenTaxon?: boolean;
            /** @description Qname identifier */
            nameAccordingTo?: string;
            /** @description Qname identifier */
            taxonRank?: string;
            scientificName?: string;
            scientificNameAuthorship?: string;
            scientificNameDisplayName?: string;
            cursiveName?: boolean;
            typeSpecimenURI?: string;
            synonymNames?: string;
            basionyms?: components["schemas"]["SimpleTaxon"][];
            objectiveSynonyms?: components["schemas"]["SimpleTaxon"][];
            subjectiveSynonyms?: components["schemas"]["SimpleTaxon"][];
            homotypicSynonyms?: components["schemas"]["SimpleTaxon"][];
            heterotypicSynonyms?: components["schemas"]["SimpleTaxon"][];
            synonyms?: components["schemas"]["SimpleTaxon"][];
            misspelledNames?: components["schemas"]["SimpleTaxon"][];
            orthographicVariants?: components["schemas"]["SimpleTaxon"][];
            uncertainSynonyms?: components["schemas"]["SimpleTaxon"][];
            misappliedNames?: components["schemas"]["SimpleTaxon"][];
            alternativeNames?: components["schemas"]["SimpleTaxon"][];
            vernacularName?: components["schemas"]["LocalizedText"];
            alternativeVernacularName?: components["schemas"]["LocalizedText"][];
            obsoleteVernacularName?: components["schemas"]["LocalizedText"][];
            colloquialVernacularName?: components["schemas"]["LocalizedText"][];
            tradeName?: components["schemas"]["LocalizedText"][];
            informalTaxonGroups?: string[];
            /** @description Qname identifier */
            threatenedStatus?: string;
            redListEvaluationGroups?: string[];
            /** @description Qname identifier */
            occurrenceInFinland?: string;
            occurrenceInFinlandSpecimenURI?: string;
            typeOfOccurrenceInFinland?: string[];
            occurrenceInFinlandPublications?: string[];
            typeOfOccurrenceInFinlandNotes?: string;
            originalPublications?: string[];
            /** @description Qname identifier */
            originalDescription?: string;
            /** @description Qname identifier */
            nameDecidedBy?: string;
            nameDecidedDate?: string;
            administrativeStatuses?: string[];
            primaryHabitat?: components["schemas"]["HabitatObject"];
            secondaryHabitats?: components["schemas"]["HabitatObject"][];
            latestRedListStatusFinland?: components["schemas"]["RedListStatus"];
            redListStatusesInFinland?: components["schemas"]["RedListStatus"][];
            taxonExpert?: string[];
            taxonEditor?: string[];
            /** @description Qname identifier */
            invasiveSpeciesEstablishment?: string;
            multimedia?: components["schemas"]["Image"][];
            descriptions?: components["schemas"]["Content"];
            /** @description Qname identifier */
            secureLevel?: string;
            /** @description Qname identifier */
            breedingSecureLevel?: string;
            /** @description Qname identifier */
            winteringSecureLevel?: string;
            /** @description Qname identifier */
            nestSiteSecureLevel?: string;
            /** @description Qname identifier */
            naturaAreaSecureLevel?: string;
            sensitive?: boolean;
            autoNonWild?: boolean;
            occurrences?: components["schemas"]["Occurrence"][];
            habitatOccurrenceCounts?: components["schemas"]["HabitatOccurrenceCount"][];
            birdlifeCode?: string;
            euringCode?: string;
            euringNumber?: number;
            customReportFormLink?: string;
            taxonConceptIds?: string[];
            additionalIds?: string[];
            externalLinks?: components["schemas"]["LocalizedURL"][];
            finnish?: boolean;
            species?: boolean;
            finnishSpecies?: boolean;
            invasiveSpecies?: boolean;
            stableInFinland?: boolean;
            countOfSpecies?: number;
            countOfFinnishSpecies?: number;
            observationCount?: number;
            occurrenceCount?: number;
            observationCountFinland?: number;
            occurrenceCountFinland?: number;
            observationCountInvasiveFinland?: number;
            occurrenceCountInvasiveFinland?: number;
            bold?: components["schemas"]["BoldRecords"];
            hasBold?: boolean;
            hasParent?: boolean;
            hasChildren?: boolean;
            hasMultimedia?: boolean;
            hasDescriptions?: boolean;
            invasiveSpeciesMainGroups?: string[];
            taxonSets?: string[];
            notes?: string;
            taxonomicOrder?: number;
            parent?: {
                domain?: components["schemas"]["SimpleTaxon"];
                kingdom?: components["schemas"]["SimpleTaxon"];
                phylum?: components["schemas"]["SimpleTaxon"];
                subphylum?: components["schemas"]["SimpleTaxon"];
                division?: components["schemas"]["SimpleTaxon"];
                class?: components["schemas"]["SimpleTaxon"];
                subclass?: components["schemas"]["SimpleTaxon"];
                order?: components["schemas"]["SimpleTaxon"];
                suborder?: components["schemas"]["SimpleTaxon"];
                superfamily?: components["schemas"]["SimpleTaxon"];
                family?: components["schemas"]["SimpleTaxon"];
                subfamily?: components["schemas"]["SimpleTaxon"];
                tribe?: components["schemas"]["SimpleTaxon"];
                subtribe?: components["schemas"]["SimpleTaxon"];
                genus?: components["schemas"]["SimpleTaxon"];
                subgenus?: components["schemas"]["SimpleTaxon"];
                aggregate?: components["schemas"]["SimpleTaxon"];
                species?: components["schemas"]["SimpleTaxon"];
            };
            synonymOf?: components["schemas"]["SimpleTaxon"];
            latestRedListEvaluation?: components["schemas"]["Evaluation"];
            hasLatestRedListEvaluation?: boolean;
            primaryHabitatSearchStrings?: string[];
            anyHabitatSearchStrings?: string[];
        };
        SimpleTaxon: {
            id?: string;
            scientificName?: string;
            scientificNameAuthorship?: string;
            vernacularName?: components["schemas"]["LocalizedText"];
            taxonRank?: string;
            cursiveName?: boolean;
            notes?: string;
            bold?: components["schemas"]["BoldRecords"];
            hasBold?: boolean;
        };
        LocalizedText: {
            fi?: string;
            sv?: string;
            en?: string;
        };
        LocalizedURL: {
            locale?: string;
            uri?: string;
        };
        RedListStatus: {
            /** @description Qname identifier */
            status?: string;
            year?: number;
        };
        HabitatObject: {
            /** @description Qname identifier */
            habitat?: string;
            habitatSpecificTypes?: string[];
            /** @description Qname identifier */
            id?: string;
            order?: number;
        };
        Occurrence: {
            /** @description Qname identifier */
            area?: string;
            /** @description Qname identifier */
            id?: string;
            notes?: string;
            occurrenceCount?: number;
            specimenURI?: string;
            /** @description Qname identifier */
            status?: string;
            threatened?: boolean;
            year?: number;
        };
        HabitatOccurrenceCount: {
            habitat?: components["schemas"]["LocalizedText"];
            id?: string;
            occurrenceCount?: number;
        };
        BoldRecords: {
            barcodes?: number;
            binCount?: number;
            bins?: string[];
            publicRecords?: number;
            specimens?: number;
        };
        Evaluation: {
            evaluationYear?: number;
            /** @enum {string} */
            redListStatus?: "MX.iucnEX" | "MX.iucnEW" | "MX.iucnRE" | "MX.iucnCR" | "MX.iucnEN" | "MX.iucnVU" | "MX.iucnNT" | "MX.iucnLC" | "MX.iucnDD" | "MX.iucnNA" | "MX.iucnNE";
            /** @enum {string} */
            externalPopulationImpactOnRedListStatus?: "MKV.externalPopulationImpactOnRedListStatusEnumMinus1" | "MKV.externalPopulationImpactOnRedListStatusEnumMinus2" | "MKV.externalPopulationImpactOnRedListStatusEnumPlus1" | "MKV.externalPopulationImpactOnRedListStatusEnumPlus2";
            criteriaForStatus?: string;
            /** @enum {string} */
            possiblyRE?: "MX.iucnRE" | "MX.iucnEW" | "MX.iucnEX";
            reasonForStatusChange?: ("MKV.reasonForStatusChangeGenuine" | "MKV.reasonForStatusChangeGenuineBeforePreviousEvaluation" | "MKV.reasonForStatusChangeChangesInCriteria" | "MKV.reasonForStatusChangeMoreInformation" | "MKV.reasonForStatusChangeChangesInTaxonomy" | "MKV.reasonForStatusChangeError" | "MKV.reasonForStatusChangeErroneousInformation" | "MKV.reasonForStatusChangeOther")[];
            lastSightingNotes?: string;
            primaryHabitat?: components["schemas"]["HabitatObject"];
            secondaryHabitats?: components["schemas"]["HabitatObject"][];
            primaryHabitatSearchStrings?: string[];
            anyHabitatSearchStrings?: string[];
            endangermentReasons?: string[];
            primaryEndangermentReason?: string;
            threats?: string[];
            primaryThreat?: string;
            occurrences?: components["schemas"]["Occurrence"][];
            threatenedAtArea?: string[];
            calculatedRedListIndex?: number;
            calculatedCorrectedRedListIndex?: number;
            correctedStatusForRedListIndex?: string;
        };
        Content: components["schemas"]["Context"][];
        Context: {
            id?: string;
            title?: components["schemas"]["LocalizedText"];
            groups?: {
                group?: string;
                title?: components["schemas"]["LocalizedText"];
                variables?: {
                    variable?: string;
                    title?: components["schemas"]["LocalizedText"];
                    content?: components["schemas"]["LocalizedText"];
                }[];
            }[];
            speciesCardAuthors?: {
                variable?: string;
                title?: components["schemas"]["LocalizedText"];
                content?: components["schemas"]["LocalizedText"];
            };
        };
        TraitAPIError: {
            /** @description HTTP Status Code */
            status?: number;
            /** @description Error message */
            message?: string;
            /** @description Stacktrace */
            stacktrace?: string;
        };
        TraitAPIOKResponse: {
            /** @description ok */
            ok?: string;
        };
        TraitAPISearchResponse: {
            currentPage?: number;
            nextPage?: number;
            lastPage?: number;
            pageSize?: number;
            total?: number;
            results?: components["schemas"]["TraitSearchRow"][];
            errors?: {
                [key: string]: string | undefined;
            };
        };
        ValidationResponse: {
            pass?: boolean;
            errors?: {
                [key: string]: string | undefined;
            };
        };
        TraitTSVValidationResponse: {
            pass?: boolean;
            header?: components["schemas"]["ValidationResponse"];
            rows?: components["schemas"]["ValidationResponse"][];
        };
        TraitMultiValidationResponse: {
            pass?: boolean;
            rows?: components["schemas"]["ValidationResponse"][];
        };
        TraitGroup: {
            /** @description Qname identifier */
            id: string;
            name: string;
            description: string;
        };
        Trait: {
            /** @description Qname identifier */
            id: string;
            /** @description Qname identifier */
            group: string;
            dataEntryName: string;
            name: string;
            description: string;
            exampleValues?: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            baseUnit?: "TDF.umNM" | "TDF.umUM" | "TDF.umMM" | "TDF.umCM" | "TDF.umM" | "TDF.umKM" | "TDF.umG" | "TDF.umKG" | "TDF.umA" | "TDF.umS" | "TDF.umML" | "TDF.umL" | "TDF.umMOL" | "TDF.umMMOL" | "TDF.umUMOL" | "TDF.umHZ" | "TDF.umP" | "TDF.umPPT" | "TDF.umPPM" | "TDF.umC" | "TDF.umMM2" | "TDF.umCM2" | "TDF.umM2" | "TDF.umARE" | "TDF.umHA" | "TDF.umKM2" | "TDF.umMM3" | "TDF.umCM3" | "TDF.umM3" | "TDF.umGMOL" | "TDF.umMOLL" | "TDF.umCM2H";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            range: "xsd:string" | "xsd:decimal" | "xsd:integer" | "xsd:positiveInteger" | "xsd:nonNegativeInteger" | "xsd:boolean" | "MX.taxon";
            enumerations?: components["schemas"]["TraitEnumerationValue"][];
            reference?: string;
            identifiers?: string[];
        };
        TraitEnumerationValue: {
            /** @description Qname identifier */
            id: string;
            dataEntryName: string;
            name: string;
            description: string;
        };
        UnitOfMeasurement: {
            /** @description Qname identifier */
            id: string;
            unit: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            base: "TDF.umNM" | "TDF.umUM" | "TDF.umMM" | "TDF.umCM" | "TDF.umM" | "TDF.umKM" | "TDF.umG" | "TDF.umKG" | "TDF.umA" | "TDF.umS" | "TDF.umML" | "TDF.umL" | "TDF.umMOL" | "TDF.umMMOL" | "TDF.umUMOL" | "TDF.umHZ" | "TDF.umP" | "TDF.umPPT" | "TDF.umPPM" | "TDF.umC" | "TDF.umMM2" | "TDF.umCM2" | "TDF.umM2" | "TDF.umARE" | "TDF.umHA" | "TDF.umKM2" | "TDF.umMM3" | "TDF.umCM3" | "TDF.umM3" | "TDF.umGMOL" | "TDF.umMOLL" | "TDF.umCM2H";
            conversionFactor: number;
            isBaseUnit: boolean;
        };
        Dataset: {
            /** @description Qname identifier */
            id: string;
            name: string;
            description: string;
            citation: string;
            intellectualOwner: string;
            personResponsible: string;
            contactEmail: string;
            institutionCode?: string;
            methods: string;
            taxonomicCoverage: string;
            temporalCoverage: string;
            geographicCoverage: string;
            coverageBasis: string;
            finbifDOI?: string;
            gbifDOI?: string;
            additionalIdentifiers?: string[];
            published: boolean;
            shareToFinBIF: boolean;
            shareToGBIF: boolean;
        };
        DatasetPermissions: {
            /** @description Qname identifier */
            datasetId: string;
            userIds?: string[];
        };
        InputRow: {
            subject: components["schemas"]["Subject"];
            traits?: components["schemas"]["TraitValue"][];
        };
        Subject: {
            /** @description Qname identifier */
            id: string;
            /** @description Qname identifier */
            datasetId: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            type: "TDF.typeIndividual" | "TDF.typePopulationGroup" | "TDF.typeTaxon";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            basisOfRecord?: "MY.recordBasisPreservedSpecimen" | "MY.recordBasisHumanObservation" | "MY.recordBasisHumanObservationSeen" | "MY.recordBasisHumanObservationHeard" | "MY.recordBasisHumanObservationHandled" | "MY.recordBasisHumanObservationPhoto" | "MY.recordBasisHumanObservationAudio" | "MY.recordBasisHumanObservationVideo" | "MY.recordBasisHumanObservationIndirect" | "MY.recordBasisMachineObservation" | "MY.recordBasisMachineObservationPhoto" | "MY.recordBasisMachineObservationVideo" | "MY.recordBasisMachineObservationAudio" | "MY.recordBasisMachineObservationGeologger" | "MY.recordBasisMachineObservationSatelliteTransmitter" | "MY.recordBasisFossilSpecimen" | "MY.recordBasisSubfossilSpecimen" | "MY.recordBasisSubfossilSpecimenAmberInclusion" | "MY.recordBasisMaterialSample" | "MY.recordBasisMaterialSampleAir" | "MY.recordBasisMaterialSampleSoil" | "MY.recordBasisMaterialSampleWater" | "MY.recordBasisMicrobialSpecimen" | "MY.recordBasisLivingSpecimen" | "MY.recordBasisLiterature";
            /** @description Qname identifier */
            finbifOccurrenceId?: string;
            gbifOccurrenceId?: string;
            otherOccurrenceId?: string;
            kingdom?: string;
            scientificName?: string;
            author?: string;
            functionalGroupName?: string;
            /** @description Qname identifier */
            taxonId?: string;
            gbifTaxonId?: number;
            otherTaxonId?: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            sex?: "MY.sexM" | "MY.sexF" | "MY.sexW" | "MY.sexU" | "MY.sexN" | "MY.sexX" | "MY.sexE" | "MY.sexC";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            lifeStage?: "MY.lifeStageAdult" | "MY.lifeStageNymph" | "MY.lifeStageLarva" | "MY.lifeStageEgg" | "MY.lifeStagePupa" | "MY.lifeStageJuvenile" | "MY.lifeStageSubimago" | "MY.lifeStageImmature" | "MY.lifeStageFertile" | "MY.lifeStageSterile" | "MY.lifeStageTadpole" | "MY.lifeStageEmbryo" | "MY.lifeStageSubadult" | "MY.lifeStageMature" | "MY.lifeStagePullus" | "MY.lifeStageHatchedEgg" | "MY.lifeStageHatchedPupa" | "MY.lifeStageGall" | "MY.lifeStageMarks" | "MY.lifeStageTriungulin";
            ageYears?: number;
            individualCount?: number;
            /** Format: date */
            dateBegin?: string;
            /** Format: date */
            dateEnd?: string;
            yearBegin?: number;
            yearEnd?: number;
            seasonBegin?: number;
            seasonEnd?: number;
            lat?: number;
            lon?: number;
            latMin?: number;
            latMax?: number;
            lonMin?: number;
            lonMax?: number;
            coordinateAccuracy?: number;
            elevation?: number;
            higherGeography?: string;
            country?: string;
            municipality?: string;
            locality?: string;
            locationIdentifiers?: string;
            habitat?: string;
            occurrenceRemarks?: string;
            measurementDeterminedBy?: string;
            /** Format: date */
            measurementDeterminedDate?: string;
            /** Format: date */
            created?: string;
            /** Format: date */
            modified?: string;
            createdBy: string;
            modifiedBy?: string;
        };
        TraitValue: {
            /** @description Qname identifier */
            id: string;
            /** @description Qname identifier */
            traitId: string;
            value: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            unit?: "TDF.umNM" | "TDF.umUM" | "TDF.umMM" | "TDF.umCM" | "TDF.umM" | "TDF.umKM" | "TDF.umG" | "TDF.umKG" | "TDF.umA" | "TDF.umS" | "TDF.umML" | "TDF.umL" | "TDF.umMOL" | "TDF.umMMOL" | "TDF.umUMOL" | "TDF.umHZ" | "TDF.umP" | "TDF.umPPT" | "TDF.umPPM" | "TDF.umC" | "TDF.umMM2" | "TDF.umCM2" | "TDF.umM2" | "TDF.umARE" | "TDF.umHA" | "TDF.umKM2" | "TDF.umMM3" | "TDF.umCM3" | "TDF.umM3" | "TDF.umGMOL" | "TDF.umMOLL" | "TDF.umCM2H";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            statisticalMethod?: "TDF.statisticalMethodMin" | "TDF.statisticalMethodMax" | "TDF.statisticalMethodAvg" | "TDF.statisticalMethodMedian" | "TDF.statisticalMethodSD" | "TDF.statisticalMethodMode";
            measurementAccuracy?: number;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            objectTaxonLifeStage?: "MY.lifeStageAdult" | "MY.lifeStageNymph" | "MY.lifeStageLarva" | "MY.lifeStageEgg" | "MY.lifeStagePupa" | "MY.lifeStageJuvenile" | "MY.lifeStageSubimago" | "MY.lifeStageImmature" | "MY.lifeStageFertile" | "MY.lifeStageSterile" | "MY.lifeStageTadpole" | "MY.lifeStageEmbryo" | "MY.lifeStageSubadult" | "MY.lifeStageMature" | "MY.lifeStagePullus" | "MY.lifeStageHatchedEgg" | "MY.lifeStageHatchedPupa" | "MY.lifeStageGall" | "MY.lifeStageMarks" | "MY.lifeStageTriungulin";
            warnings?: boolean;
            measurementRemarks?: string;
            reference?: string;
        };
        TraitSearchRow: {
            /** @description Qname identifier */
            id?: string;
            subject?: components["schemas"]["TraitSearchSubject"];
            year?: number;
            month?: number;
            day?: number;
            eventDate?: string;
            geodeticDatum?: string;
            trait?: components["schemas"]["TraitSearchTrait"];
            traitGroup?: components["schemas"]["TraitSearchTraitGroup"];
            /**
             * @description Qname identifier
             * @enum {string}
             */
            statisticalMethod?: "TDF.statisticalMethodMin" | "TDF.statisticalMethodMax" | "TDF.statisticalMethodAvg" | "TDF.statisticalMethodMedian" | "TDF.statisticalMethodSD" | "TDF.statisticalMethodMode";
            value?: string;
            valueNumeric?: number;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            unit?: "TDF.umNM" | "TDF.umUM" | "TDF.umMM" | "TDF.umCM" | "TDF.umM" | "TDF.umKM" | "TDF.umG" | "TDF.umKG" | "TDF.umA" | "TDF.umS" | "TDF.umML" | "TDF.umL" | "TDF.umMOL" | "TDF.umMMOL" | "TDF.umUMOL" | "TDF.umHZ" | "TDF.umP" | "TDF.umPPT" | "TDF.umPPM" | "TDF.umC" | "TDF.umMM2" | "TDF.umCM2" | "TDF.umM2" | "TDF.umARE" | "TDF.umHA" | "TDF.umKM2" | "TDF.umMM3" | "TDF.umCM3" | "TDF.umM3" | "TDF.umGMOL" | "TDF.umMOLL" | "TDF.umCM2H";
            measurementAccuracy?: number;
            originalValue?: string;
            originalValueNumeric?: number;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            originalUnit?: "TDF.umNM" | "TDF.umUM" | "TDF.umMM" | "TDF.umCM" | "TDF.umM" | "TDF.umKM" | "TDF.umG" | "TDF.umKG" | "TDF.umA" | "TDF.umS" | "TDF.umML" | "TDF.umL" | "TDF.umMOL" | "TDF.umMMOL" | "TDF.umUMOL" | "TDF.umHZ" | "TDF.umP" | "TDF.umPPT" | "TDF.umPPM" | "TDF.umC" | "TDF.umMM2" | "TDF.umCM2" | "TDF.umM2" | "TDF.umARE" | "TDF.umHA" | "TDF.umKM2" | "TDF.umMM3" | "TDF.umCM3" | "TDF.umM3" | "TDF.umGMOL" | "TDF.umMOLL" | "TDF.umCM2H";
            originalMeasurementAccuracy?: number;
            subjectFinBIFTaxon?: components["schemas"]["TraitTaxon"];
            subjectGBIFTaxon?: components["schemas"]["TraitTaxon"];
            /**
             * @description Qname identifier
             * @enum {string}
             */
            objectTaxonLifeStage?: "MY.lifeStageAdult" | "MY.lifeStageNymph" | "MY.lifeStageLarva" | "MY.lifeStageEgg" | "MY.lifeStagePupa" | "MY.lifeStageJuvenile" | "MY.lifeStageSubimago" | "MY.lifeStageImmature" | "MY.lifeStageFertile" | "MY.lifeStageSterile" | "MY.lifeStageTadpole" | "MY.lifeStageEmbryo" | "MY.lifeStageSubadult" | "MY.lifeStageMature" | "MY.lifeStagePullus" | "MY.lifeStageHatchedEgg" | "MY.lifeStageHatchedPupa" | "MY.lifeStageGall" | "MY.lifeStageMarks" | "MY.lifeStageTriungulin";
            objectTaxonVerbatim?: string;
            objectFinBIFTaxon?: components["schemas"]["TraitTaxon"];
            objectGBIFTaxon?: components["schemas"]["TraitTaxon"];
            warnings?: boolean;
            measurementRemarks?: string;
            reference?: string;
            dataset?: components["schemas"]["TraitSearchDataset"];
            /**
             * @description Qname identifier
             * @enum {string}
             */
            license?: "MZ.intellectualRightsCC-BY-SA-4.0" | "MZ.intellectualRightsCC-BY-NC-4.0" | "MZ.intellectualRightsCC-BY-NC-SA-4.0" | "MZ.intellectualRightsCC-BY-4.0" | "MZ.intellectualRightsCC0-4.0" | "MZ.intellectualRightsODBL-1.0" | "MZ.intellectualRightsPD" | "MZ.intellectualRightsARR" | "MZ.intellectualRightsCC-BY-2.0" | "MZ.intellectualRightsCC-BY-SA-2.0" | "MZ.intellectualRightsCC-BY-SA-2.0-DE" | "MZ.intellectualRightsCC-BY-NC-2.0" | "MZ.intellectualRightsCC-BY-NC-SA-2.0" | "MZ.intellectualRightsCC-BY-NC-ND-2.0" | "MZ.intellectualRightsCC-BY-SA-2.5" | "MZ.intellectualRightsCC-BY-SA-2.5-SE" | "MZ.intellectualRightsCC-BY-3.0" | "MZ.intellectualRightsCC-BY-SA-3.0" | "MZ.intellectualRightsCC-BY-NC-SA-3.0" | "MZ.intellectualRightsCC-BY-ND-4.0" | "MZ.intellectualRightsCC-BY-NC-ND-4.0" | "MY.intellectualRightsCC-BY" | "MY.intellectualRightsCC0";
        };
        TraitTaxon: {
            id?: string;
            taxonomicOrder?: number;
            taxonRank?: string;
            scientificName?: string;
            cursiveName?: boolean;
            author?: string;
            higherTaxa?: components["schemas"]["HigherTaxa"];
            /**
             * @description Qname identifier
             * @enum {string}
             */
            iucnStatus?: "MX.iucnEX" | "MX.iucnEW" | "MX.iucnRE" | "MX.iucnCR" | "MX.iucnEN" | "MX.iucnVU" | "MX.iucnNT" | "MX.iucnLC" | "MX.iucnDD" | "MX.iucnNA" | "MX.iucnNE";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            primaryHabitat?: "MKV.habitatM" | "MKV.habitatMk" | "MKV.habitatMkk" | "MKV.habitatMkt" | "MKV.habitatMl" | "MKV.habitatMlt" | "MKV.habitatMlk" | "MKV.habitatMt" | "MKV.habitatMtl" | "MKV.habitatS" | "MKV.habitatSl" | "MKV.habitatSla" | "MKV.habitatSlr" | "MKV.habitatSlk" | "MKV.habitatSn" | "MKV.habitatSnk" | "MKV.habitatSnr" | "MKV.habitatSr" | "MKV.habitatSrk" | "MKV.habitatSrr" | "MKV.habitatSk" | "MKV.habitatSkk" | "MKV.habitatSkr" | "MKV.habitatV" | "MKV.habitatVi" | "MKV.habitatVik" | "MKV.habitatVim" | "MKV.habitatVis" | "MKV.habitatVih" | "MKV.habitatVie" | "MKV.habitatVip" | "MKV.habitatVs" | "MKV.habitatVsk" | "MKV.habitatVsr" | "MKV.habitatVa" | "MKV.habitatVj" | "MKV.habitatVp" | "MKV.habitatVk" | "MKV.habitatVl" | "MKV.habitatR" | "MKV.habitatRi" | "MKV.habitatRim" | "MKV.habitatRimt" | "MKV.habitatRiml" | "MKV.habitatRip" | "MKV.habitatRin" | "MKV.habitatRil" | "MKV.habitatRir" | "MKV.habitatRis" | "MKV.habitatRih" | "MKV.habitatRit" | "MKV.habitatRj" | "MKV.habitatRjm" | "MKV.habitatRjmt" | "MKV.habitatRjml" | "MKV.habitatRjp" | "MKV.habitatRjn" | "MKV.habitatRjl" | "MKV.habitatRjr" | "MKV.habitatRjs" | "MKV.habitatRjh" | "MKV.habitatRjt" | "MKV.habitatK" | "MKV.habitatKk" | "MKV.habitatKs" | "MKV.habitatKr" | "MKV.habitatKl" | "MKV.habitatKm" | "MKV.habitatT" | "MKV.habitatTk" | "MKV.habitatTn" | "MKV.habitatTu" | "MKV.habitatTp" | "MKV.habitatTl" | "MKV.habitatTll" | "MKV.habitatTlk" | "MKV.habitatTls" | "MKV.habitatTlr" | "MKV.habitatTl" | "MKV.habitatTs" | "MKV.habitatTj" | "MKV.habitatTv" | "MKV.habitatTa" | "MKV.habitatI" | "MKV.habitatIn" | "MKV.habitatIt" | "MKV.habitatIh" | "MKV.habitatIk" | "MKV.habitatIo" | "MKV.habitatIv" | "MKV.habitatIp" | "MKV.habitatIu" | "MKV.habitatIr" | "MKV.habitatU";
            habitatSpecifiers?: ("MKV.habitatSpecificTypeV" | "MKV.habitatSpecificTypeH" | "MKV.habitatSpecificTypeP" | "MKV.habitatSpecificTypeJ" | "MKV.habitatSpecificTypePAK" | "MKV.habitatSpecificTypeVAK" | "MKV.habitatSpecificTypeRA" | "MKV.habitatSpecificTypeKA" | "MKV.habitatSpecificTypeKE" | "MKV.habitatSpecificTypeCA")[];
            sensitive?: boolean;
        };
        TraitSearchSubject: {
            /** @description Qname identifier */
            id?: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            type?: "TDF.typeIndividual" | "TDF.typePopulationGroup" | "TDF.typeTaxon";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            basisOfRecord?: "MY.recordBasisPreservedSpecimen" | "MY.recordBasisHumanObservation" | "MY.recordBasisHumanObservationSeen" | "MY.recordBasisHumanObservationHeard" | "MY.recordBasisHumanObservationHandled" | "MY.recordBasisHumanObservationPhoto" | "MY.recordBasisHumanObservationAudio" | "MY.recordBasisHumanObservationVideo" | "MY.recordBasisHumanObservationIndirect" | "MY.recordBasisMachineObservation" | "MY.recordBasisMachineObservationPhoto" | "MY.recordBasisMachineObservationVideo" | "MY.recordBasisMachineObservationAudio" | "MY.recordBasisMachineObservationGeologger" | "MY.recordBasisMachineObservationSatelliteTransmitter" | "MY.recordBasisFossilSpecimen" | "MY.recordBasisSubfossilSpecimen" | "MY.recordBasisSubfossilSpecimenAmberInclusion" | "MY.recordBasisMaterialSample" | "MY.recordBasisMaterialSampleAir" | "MY.recordBasisMaterialSampleSoil" | "MY.recordBasisMaterialSampleWater" | "MY.recordBasisMicrobialSpecimen" | "MY.recordBasisLivingSpecimen" | "MY.recordBasisLiterature";
            /** @description Qname identifier */
            finbifOccurrenceId?: string;
            gbifOccurrenceId?: string;
            otherOccurrenceId?: string;
            kingdom?: string;
            scientificName?: string;
            author?: string;
            functionalGroupName?: string;
            otherTaxonId?: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            sex?: "MY.sexM" | "MY.sexF" | "MY.sexW" | "MY.sexU" | "MY.sexN" | "MY.sexX" | "MY.sexE" | "MY.sexC";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            lifeStage?: "MY.lifeStageAdult" | "MY.lifeStageNymph" | "MY.lifeStageLarva" | "MY.lifeStageEgg" | "MY.lifeStagePupa" | "MY.lifeStageJuvenile" | "MY.lifeStageSubimago" | "MY.lifeStageImmature" | "MY.lifeStageFertile" | "MY.lifeStageSterile" | "MY.lifeStageTadpole" | "MY.lifeStageEmbryo" | "MY.lifeStageSubadult" | "MY.lifeStageMature" | "MY.lifeStagePullus" | "MY.lifeStageHatchedEgg" | "MY.lifeStageHatchedPupa" | "MY.lifeStageGall" | "MY.lifeStageMarks" | "MY.lifeStageTriungulin";
            ageYears?: number;
            individualCount?: number;
            /** Format: date */
            dateBegin?: string;
            /** Format: date */
            dateEnd?: string;
            yearBegin?: number;
            yearEnd?: number;
            seasonBegin?: number;
            seasonEnd?: number;
            lat?: number;
            lon?: number;
            latMin?: number;
            latMax?: number;
            lonMin?: number;
            lonMax?: number;
            coordinateAccuracy?: number;
            elevation?: number;
            higherGeography?: string;
            country?: string;
            municipality?: string;
            locality?: string;
            locationIdentifiers?: string;
            habitat?: string;
            occurrenceRemarks?: string;
            measurementDeterminedBy?: string;
            /** Format: date */
            measurementDeterminedDate?: string;
            /** Format: date */
            created?: string;
            /** Format: date */
            modified?: string;
        };
        TraitSearchTrait: {
            /** @description Qname identifier */
            id?: string;
            dataEntryName?: string;
            name?: string;
            description?: string;
            /**
             * @description Qname identifier
             * @enum {string}
             */
            baseUnit?: "TDF.umNM" | "TDF.umUM" | "TDF.umMM" | "TDF.umCM" | "TDF.umM" | "TDF.umKM" | "TDF.umG" | "TDF.umKG" | "TDF.umA" | "TDF.umS" | "TDF.umML" | "TDF.umL" | "TDF.umMOL" | "TDF.umMMOL" | "TDF.umUMOL" | "TDF.umHZ" | "TDF.umP" | "TDF.umPPT" | "TDF.umPPM" | "TDF.umC" | "TDF.umMM2" | "TDF.umCM2" | "TDF.umM2" | "TDF.umARE" | "TDF.umHA" | "TDF.umKM2" | "TDF.umMM3" | "TDF.umCM3" | "TDF.umM3" | "TDF.umGMOL" | "TDF.umMOLL" | "TDF.umCM2H";
            /**
             * @description Qname identifier
             * @enum {string}
             */
            range?: "xsd:string" | "xsd:decimal" | "xsd:integer" | "xsd:positiveInteger" | "xsd:nonNegativeInteger" | "xsd:boolean" | "MX.taxon";
            reference?: string;
            identifiers?: string[];
        };
        TraitSearchTraitGroup: {
            name?: string;
        };
        TraitSearchDataset: {
            /** @description Qname identifier */
            id?: string;
            name?: string;
            description?: string;
            citation?: string;
            intellectualOwner?: string;
            personResponsible?: string;
            contactEmail?: string;
            methods?: string;
            coverageBasis?: string;
            finbifDOI?: string;
            gbifDOI?: string;
            additionalIdentifiers?: string[];
        };
        HigherTaxa: {
            domain?: string;
            kingdom?: string;
            phylum?: string;
            subphylum?: string;
            division?: string;
            class?: string;
            subclass?: string;
            order?: string;
            suborder?: string;
            superfamily?: string;
            family?: string;
            subfamily?: string;
            tribe?: string;
            subtribe?: string;
            genus?: string;
        };
        form: {
            /** Context for the MHL.form */
            "@context"?: string;
            /** Id for the MHL.form */
            id?: string;
            /** Type for the MHL.form */
            "@type"?: string;
            /** Base form */
            baseFormID?: string;
            /**
             * Category
             * @enum {string}
             */
            category?: "" | "MHL.categoryGeneric" | "MHL.categorySurvey" | "MHL.categoryTaxonomicGroup" | "MHL.categoryBirdMonitoringSchemes" | "MHL.categoryCitizenScience" | "MHL.categoryBiomonCompleteLists";
            /**
             * Collection ID
             * @description Id for the collection to where observation useing this form are connected
             */
            collectionID?: string;
            /**
             * Context
             * @description The schema context of the form (e.g. MY.document, MNP.namedPlace...)
             */
            context?: string;
            /** Description */
            description?: string;
            fields?: components["schemas"]["field"][];
            /**
             * Fields form ID
             * @description Use fields, uiSchema and translations from the form
             */
            fieldsFormID?: string;
            /**
             * Form language
             * @enum {string}
             */
            language?: "" | "en" | "fi" | "sv";
            /** Logo address */
            logo?: string;
            /** Name */
            name?: string;
            options?: components["schemas"]["formOptions"];
            /** Patch form data */
            patch?: Record<string, never>[];
            /** Short description */
            shortDescription?: string;
            /**
             * Short title
             * @description Shown at sidebar and & as browser title
             */
            shortTitle?: string;
            /** Supported language */
            supportedLanguage?: ("" | "en" | "fi" | "sv")[];
            /** Title */
            title?: string;
            /** Translations */
            translations?: Record<string, never>;
            /** Specification for ui schema */
            uiSchema?: Record<string, never>;
        };
        field: {
            /** Context for the MHLA.field */
            "@context"?: string;
            /** Id for the MHLA.field */
            id?: string;
            /** Type for the MHLA.field */
            "@type"?: string;
            /** Name */
            name?: string;
            fields?: components["schemas"]["field"][];
            /** filters */
            filters?: Record<string, never>;
            /** label */
            label?: string;
            /** Notice validators */
            notices?: Record<string, never>;
            /** Options */
            options?: Record<string, never>;
            /** Required field */
            required?: boolean;
            /** field type */
            type?: string;
            /** UI instructions to field */
            ui?: Record<string, never>;
            /** validators */
            validators?: Record<string, never>;
            /** value */
            value?: string;
            /** warning validators */
            warnings?: Record<string, never>;
        };
        formOptions: {
            /** Context for the MHL.formOptionsClass */
            "@context"?: string;
            /** Id for the MHL.formOptionsClass */
            id?: string;
            /** Type for the MHL.formOptionsClass */
            "@type"?: string;
            about?: components["schemas"]["multiLang"];
            /**
             * Document are lockable by admin
             * @description Form admin can lock documents. Locked documents can't be edited
             */
            adminLockable?: boolean;
            /**
             * Allow excel
             * @description Allows usage in spreadsheet upload component
             */
            allowExcel?: boolean;
            /**
             * Allow excel generation
             * @description If false, Vihko will not show the spreadsheet generation tool for the form. Defaults to true"
             */
            allowExcelGeneration?: boolean;
            /**
             * Allow templates
             * @description Allows creating templates from documents
             */
            allowTemplate?: boolean;
            /**
             * Footer cancel button label
             * @description Label for the cancel button at the form footer
             */
            cancelLabel?: string;
            /**
             * Dataset form
             * @description Has dataset about page
             */
            dataset?: boolean;
            /**
             * Disable form permissionrequest description
             * @description Theme form introduction page doesn't show description for the form permission request button
             */
            disableRequestDescription?: boolean;
            /**
             * Disabled
             * @description Prevent sending documents & named places
             */
            disabled?: boolean;
            /**
             * Display own submissions
             * @description Only if has named places. All documents for admin
             */
            displayOwnSubmissions?: boolean;
            /**
             * Documents are viewable for all users
             * @description Documents of the form's collectionID are viewable for all users with form permissions to the form's collectionID
             */
            documentsViewableForAll?: boolean;
            /**
             * Footer draft button label
             * @description Label for the draft button at the form footer
             */
            draftLabel?: string;
            /** Edit button label */
            editLabel?: string;
            /**
             * Consider unit without count empty
             * @description Units without count aren't considered in laji.fi viewer (including document viewers and datatables)
             */
            emptyOnNoCount?: boolean;
            /**
             * Exclude from global excel tools
             * @description Excludes from the Vihko excel tools
             */
            excludeFromGlobalExcel?: boolean;
            footer?: components["schemas"]["formFooter"];
            /**
             * Own submissions page title
             * @description Label for the own submissions list at the header of document form
             */
            formOwnSubmissionsLabel?: string;
            /**
             * Form permissions page description
             * @description Shown at form permission intro page. Allows HTML
             */
            formPermissionDescription?: string;
            /** Sub forms */
            forms?: string[];
            /**
             * Has admins
             * @description The form has administrators. Administrators can handle user access permissions and admin roles for all forms with the collectionID of the form.
             */
            hasAdmins?: boolean;
            /**
             * Hide cancel button
             * @description Hides the cancel button at form footer
             */
            hideCancelButton?: boolean;
            /** hideDraftButton */
            hideDraftButton?: boolean;
            /**
             * Hide save button
             * @description Hides the save/edit button at form footer
             */
            hideSaveButton?: boolean;
            /**
             * Hide TES
             * @description Terms of Service is hidden at the header of observation form
             */
            hideTES?: boolean;
            /**
             * Hide draft button
             * @description Hides the draft button at form footer
             */
            hideTempButton?: boolean;
            instructions?: components["schemas"]["multiLang"];
            /**
             * Use mobile UI
             * @description Form UI has a greeting page for convenient mobile usage
             */
            mobile?: boolean;
            namedPlaceOptions?: components["schemas"]["formNamedPlaceOptions"];
            /**
             * Navigation title
             * @description The title label for theme form sidebar
             */
            navigationTitle?: string;
            /**
             * Own submissions row actions
             * @description Available actions for own submissions (only on the own submissions page). Defaults to ['edit', 'view', 'download', 'stats', 'delete']
             */
            ownSubmissionsActions?: string[];
            /**
             * Own submissions title
             * @description Shown at sidebar link and title of all submissions page
             */
            ownSubmissionsAdminTitle?: string;
            /**
             * Own submissions table column
             * @description Columns for own submissions (only on the own submissions page). Defaults to ['dateEdited', 'dateObserved', 'taxon', 'namedPlaceName', 'observer', 'id']
             */
            ownSubmissionsColumns?: string[];
            /**
             * Own submissions title
             * @description Shown at sidebar link and title of all submissions page
             */
            ownSubmissionsTitle?: string;
            /**
             * Periods
             * @description Periods that the "NoExistingGatheringsInNamedPlace" validation uses
             */
            periods?: string[];
            /** Prepopulate form data with data from informal taxon group */
            prepopulateWithInformalTaxonGroups?: string[];
            /** Prepopulate form data with data from taxon sets */
            prepopulateWithTaxonSets?: string;
            prepopulatedDocument?: components["schemas"]["document"];
            /**
             * Print type
             * @enum {string}
             */
            printType?: "" | "MHL.printTypeLineTransect";
            /**
             * Restrict access
             * @description Users need to have permission to access the form
             * @enum {string}
             */
            restrictAccess?: "" | "MHL.restrictAccessStrict" | "MHL.restrictAccessLoose";
            /**
             * Type of result service
             * @enum {string}
             */
            resultServiceType?: "" | "MHL.resultServiceTypeLineTransect" | "MHL.resultServiceTypeNafi" | "MHL.resultServiceTypeBirdPointCount" | "MHL.resultServiceTypeWinterBirdCount" | "MHL.resultServiceTypeSykeInsectProjects" | "MHL.resultServiceTypeInvasiveControl" | "MHL.resultServiceTypeCompleteLists" | "MHL.resultServiceTypeWaterBirdCount";
            /**
             * Save error message
             * @description Message shown when document save failed
             */
            saveErrorMessage?: string;
            /**
             * Footer save button label
             * @description Label for the save button at the form footer
             */
            saveLabel?: string;
            /**
             * Save success message
             * @description Message shown when document was successfully saved
             */
            saveSuccessMessage?: string;
            /**
             * Save draft success message
             * @description Message shown when document draft was successfully saved
             */
            saveTempSuccessMessage?: string;
            season?: components["schemas"]["formSeason"];
            /**
             * Secondary copy
             * @description Makes the documents reported with the form secondary
             */
            secondaryCopy?: boolean;
            /**
             * Short title from collection name
             * @description Overrides MHL.shortTitle usage
             */
            shortTitleFromCollectionName?: boolean;
            /**
             * Sidebar label for form
             * @description Sub forms are shown only if they have this property
             */
            sidebarFormLabel?: string;
            /**
             * Simple form
             * @description Has only a form page, no sidebar
             */
            simple?: boolean;
            /**
             * Strict
             * @description Documents can't have data not defined in form fields. Defaults to true.
             */
            strict?: boolean;
            /**
             * Footer draft button label
             * @description Label for the draft button at the form footer
             */
            tempLabel?: string;
            /**
             * Use named places
             * @description Makes the form use named places
             */
            useNamedPlaces?: boolean;
            /**
             * Use schema comments as help texts
             * @description Uses schema comments as form help texts
             */
            useSchemaCommentsAsHelpTexts?: boolean;
            /**
             * Document viewer type
             * @enum {string}
             */
            viewerType?: "" | "MHL.viewerTypeLineTransect" | "MHL.viewerTypeBirdPointCount";
            /** warnEditingOldDocument */
            warnEditingOldDocument?: boolean;
            /**
             * Duration of editing old document warning
             * @description Duration in ISO 8601 duration format. Defaults to P1W (one week)
             */
            warnEditingOldDocumentDuration?: boolean;
        };
        multiLang: {
            en?: string;
            fi?: string;
            sv?: string;
        };
        formFooter: {
            /** Context for the MHL.formFooterClass */
            "@context"?: string;
            /** Id for the MHL.formFooterClass */
            id?: string;
            /** Type for the MHL.formFooterClass */
            "@type"?: string;
            /**
             * Description
             * @description Text to show for footer
             */
            footerDescription?: string;
            /**
             * Logos
             * @description Key is an image URI, value is the URI of the page clicking the image opens
             */
            footerLogos?: Record<string, never>;
        };
        formNamedPlaceOptions: {
            /** Context for the MHL.formNamedPlaceOptionsClass */
            "@context"?: string;
            /** Id for the MHL.formNamedPlaceOptionsClass */
            id?: string;
            /** Type for the MHL.formNamedPlaceOptionsClass */
            "@type"?: string;
            /**
             * Show copy link for admin
             * @description Named place viewer shows button to copy the URL for the named place viewer
             */
            adminShowCopyLink?: boolean;
            /**
             * Allow adding public named places
             * @description Form users can create new named places for the form
             */
            allowAddingPublic?: boolean;
            /**
             * Bird association area help
             * @description Help text for bird association filter
             */
            birdAssociationAreaHelp?: string;
            /**
             * Choose page description
             * @description Description shown at named place choose page. Allows HTML.
             */
            chooseDescription?: string;
            /**
             * Copy latest document to named place
             * @description The latest document is copied to named place's prepopulatedDocument. if documents date is same or after the current prepopulated document's date, or if prepopulated document doesn't have date. Date is checked from gatheringEvent or from gatherings
             */
            copyLatestDocumentToNamedPlace?: boolean;
            /**
             * Create new description
             * @description Description shown above named place form when creating new named place. Allows HTML.
             */
            createDescription?: string;
            /**
             * Create new button label
             * @description Label for new named place creation button at named place choose page
             */
            createNewButtonLabel?: string;
            /**
             * Text prepending create new button
             * @description Label for text before new named place creation button at named place choose page
             */
            createNewButtonPrependingTextLabel?: string;
            /**
             * Use local document viewer for own submissions
             * @description Theme own submissions page uses local document viewer (that shows more accurate data)
             */
            documentListUseLocalDocumentViewer?: boolean;
            /**
             * Document viewer forced fields
             * @description Forces local document viewer to show these fields
             */
            documentViewerForcedFields?: string[];
            /**
             * Document viewer gathering geometry JSON path
             * @description The path of geometry that document viewer should show
             */
            documentViewerGatheringGeometryJSONPath?: string[];
            /**
             * Document viewer zoom to data
             * @description Document viewer zooms to data instead of locked zoom level
             */
            documentViewerZoomToData?: boolean;
            /**
             * Earlier document label (ADMIN)
             * @description Admin label for named place viewer's document list
             */
            earlierLabel?: string;
            /**
             * Edit page description
             * @description Description shown at top of page when editing named place
             */
            editDescription?: string;
            /**
             * Filter named places by bird association area
             * @description The named place UI allows filtering by bird association area
             */
            filterByBirdAssociationArea?: boolean;
            /**
             * Filter named places by municipality
             * @description The named place UI allows filtering by municipality
             */
            filterByMunicipality?: boolean;
            /**
             * Filter named places by tags
             * @description The named place UI allows filtering by tags
             */
            filterByTags?: boolean;
            /**
             * Document header fields of place
             * @description When recording a document for a named place, the named place's data of these fields will be shown at the top of the page (defaults to ["alternativeIDs", "name", "municipality"]
             */
            headerFields?: string[];
            /**
             * Hide map tab
             * @description On named place chooser view, map tab is hidden
             */
            hideMapTab?: boolean;
            /**
             * Include descendant collections
             * @description True by default. The named places of this form includes the places of descendant collections also.
             */
            includeDescendantCollections?: boolean;
            /**
             * Include units in named place query
             * @description Named places will be fetched with units included (hard coded to work only for HR.2049)
             */
            includeUnits?: boolean;
            /**
             * Info fields for viewer
             * @description Fields that named place viewer shows (if not defined will be digged from uiSchema["ui:options"].fieldsScopes[form collectionID])
             */
            infoFields?: string[];
            /**
             * Last census label
             * @description Label for named place viewer last census
             */
            lastCensusLabel?: string;
            /**
             * List column names
             * @description Overrides labels for named place list column headers
             */
            listColumnNameMapping?: {
                [key: string]: string | undefined;
            };
            /**
             * Columns in list
             * @description List of columns visible in the list view
             */
            listColumns?: string[];
            /** Columns multisort */
            listColumnsMultisort?: boolean;
            /**
             * List label
             * @description Label for named place chooser list tab
             */
            listLabel?: string;
            /** Cluster the map points */
            mapCluster?: boolean;
            /**
             * Map overlays
             * @description Overlays that named place chooser map should show
             */
            mapOverlayNames?: string[];
            /**
             * Map tilelayer
             * @description Tilelayer name that named place chooser map should show
             */
            mapTileLayerName?: string;
            /**
             * Earlier document label (USER)
             * @description User label for named place viewer's document list
             */
            myEarlierLabel?: string;
            /**
             * Form ID
             * @description Form ID of named place form (defaults to MHL.36)
             */
            namedPlaceFormID?: string;
            /**
             * Named place list fields
             * @description Fields that named places list shows.
             */
            namedPlaceList?: string[];
            /**
             * Prepopulated document initialization
             * @description When a new named place is created, the prepopulatedDocument will be populated according to this.
             */
            prepopulatedDocumentFields?: Record<string, never>;
            /**
             * Print button label
             * @description Label for print button of named place viewer
             */
            printLabel?: string;
            /** Release reservation label */
            releaseLabel?: string;
            /** Reservable label */
            reservableLabel?: string;
            /**
             * Reservation expiration
             * @description Places are reservable if defined. Value defines when the reservation should expire in ISO-8601. Example: ${year}-10-12
             */
            reservationUntil?: string;
            /** Reserved label */
            reservedLabel?: string;
            /**
             * Show list colors legend
             * @description Named place list shows legend for the row colors
             */
            showLegendList?: boolean;
            /**
             * Start with map tab
             * @description Named place chooser view starts with map tab instead of list
             */
            startWithMap?: boolean;
            /**
             * use accepted document
             * @description Instead of populating observation form with prepopulatedDocument, it is populated with acceptedDocument. Admin can change the acceptedDocument from observation list
             */
            useAcceptedDocument?: boolean;
            /**
             * Use place label
             * @description Named place viewer label for button for recording new observation
             */
            useLabel?: string;
            /**
             * Zoom to data
             * @description Named place chooser map is initialized with data fitted in view.
             */
            zoomToData?: boolean;
        };
        document: {
            /** Context for the Submissions */
            "@context"?: string;
            /** Id for the Submissions */
            id?: string;
            /** Type for the Submissions */
            "@type"?: string;
            /**
             * Secure level
             * @description Secure level (salaus-/karkeistustaso) for the data
             * @enum {string}
             */
            secureLevel?: "" | "MX.secureLevelNone" | "MX.secureLevelKM1" | "MX.secureLevelKM5" | "MX.secureLevelKM10" | "MX.secureLevelKM25" | "MX.secureLevelKM50" | "MX.secureLevelKM100" | "MX.secureLevelHighest" | "MX.secureLevelNoShow";
            /**
             * DNA sample location
             * @description Leave empty if no sample taken, or if the sample is recorded separately
             */
            DNASampleLocation?: string;
            /**
             * IPEN
             * @description IPEN Number for the accession
             */
            IPEN?: string;
            /**
             * URL
             * @description URL where more information is available about the specimen
             */
            URL?: string;
            /** Acknowledged warnings */
            acknowledgedWarnings?: Record<string, never>[];
            /**
             * Acquired from
             * @description From who/where the specimen was acquired (if not recorded as a transaction)
             */
            acquiredFrom?: string;
            /**
             * Acquired from organization
             * @description Organization where the accession was acquired from. If the organization is not on the list, add it first.
             */
            acquiredFromOrganization?: string;
            /**
             * Acquisition date
             * @description Date (d.m.yyyy) or year (yyyy) on which the specimen was acquired to the collection. Empty means an old specimen acquired on an unknown date.
             */
            acquisitionDate?: string;
            /**
             * Additional ID's
             * @description Other identifiers this specimen has, in format 'type:identifier'. For example: 'mzhtypes:123' (old MAZ-type number)
             */
            additionalIDs?: string[];
            /**
             * BOLD
             * @description BOLD identifier, usually BOLD Sample ID. You can include additonal comment by separating them with colon, e.g. "AY123456:comments here"
             */
            bold?: string[];
            /** Document caption */
            caption?: string;
            /**
             * Clad book id
             * @description Clad book id number or such
             */
            cladBookID?: string;
            /**
             * Clad specimen id
             * @description Clad specimen id: usually color description and a number
             */
            cladSpecimenID?: string;
            /**
             * Clad data verbatim
             * @description Verbatim specimen data from clad book
             */
            cladVerbatim?: string;
            /**
             * Collection
             * @description The collection which this specimen belongs to
             */
            collectionID?: string;
            /**
             * Condition (defects)
             * @description Notes on the defects of the specimen (missing parts or such). Empty value means same as "good" or "hyv" - that there is nothing special to mention about the condition.
             */
            condition?: string;
            /**
             * Cultivation information
             * @description Annuality/perenniality or other specialities about cultivation in our conditions.
             */
            cultivationInformation?: string;
            /** Data origin */
            dataOrigin?: ("" | "MY.dataOriginPaperForm" | "MY.dataOriginWebForm" | "MY.dataOriginSpreadsheetFile")[];
            /**
             * Data source
             * @description Where the data about this specimen or observation is from, in addition to labels. Eg. reference to a publication, field notes or an expedition.
             */
            dataSource?: string;
            /**
             * Tags
             * @description The tags this specimen has
             */
            datasetID?: string[];
            /** Datatype */
            datatype?: string;
            /** Device ID */
            deviceID?: string;
            documentIdentifications?: components["schemas"]["documentIdentification"][];
            /**
             * Specimen location
             * @description Location of the specimen so that museum personnel can find it. E.g. taxon under which it is stored (if not clear from the identification), or shelf number
             */
            documentLocation?: string;
            /**
             * Duplicates
             * @description Description where duplicates (specimens of the same individual) are located or have been sent to and by which ID's.
             */
            duplicatesIn?: string;
            /**
             * Notes about this edit
             * @description Reason for this edit or notes about it.
             */
            editNotes?: string;
            /** Editor */
            editor?: string;
            /**
             * Date transcribed
             * @description Date the data was first transcribed into electronic format or paper registry
             */
            entered?: string;
            /**
             * Event
             * @description Free-text diary-style information about what has been done to the specimen and when.
             */
            event?: string[];
            /**
             * Exsiccatum
             * @description Name of the exsiccatum this specimen belongs to and possible exsiccatum number.
             */
            exsiccatum?: string;
            /**
             * Form id
             * @description Id of the form that was used for the document
             */
            formID?: string;
            gatheringEvent?: components["schemas"]["gatheringEvent"];
            /**
             * Genbank
             * @description Genbank identifier. You can include additonal comment by separating them with colon, e.g. "AY123456:comments here"
             */
            genbank?: string[];
            /** hasGathering */
            hasGathering?: string[];
            /** Use document as template */
            isTemplate?: boolean;
            /** Keywords */
            keywords?: string[];
            /**
             * Verbatim labels
             * @description All text from labels word-for-word, including spelling errors. Separate each label on its own row, starting from topmost label.
             */
            labelsVerbatim?: string;
            /**
             * Language
             * @description Language the data is (mainly) written in, if applicable.
             */
            language?: string;
            /**
             * Collecting number
             * @description Collecting number (field identifier, keruunumero) for the specimen
             */
            legID?: string;
            /** Locked */
            locked?: boolean;
            /** Named place */
            namedPlaceID?: string;
            /**
             * Notes
             * @description Additional information to the data in each section.
             */
            notes?: string;
            /** Observation ID */
            observationID?: string;
            /**
             * Original catalogue number
             * @description Original catalogue number or other  original identifier of the specimen. E.g. H9000000
             */
            originalSpecimenID?: string;
            /**
             * Planned location
             * @description Garden area where this accession is planned to be located.
             */
            plannedLocation?: string;
            /**
             * Preservation
             * @description Main method of preservation. If parts of the specimen are preserved in different ways, you can choose several methods.
             */
            preservation?: ("" | "MY.preservationPressed" | "MY.preservationDry" | "MY.preservationCriticalPointDrying" | "MY.preservationPinned" | "MY.preservationGlued" | "MY.preservationLiquid" | "MY.preservationEthanol" | "MY.preservationEthanolPure" | "MY.preservationEthanol70" | "MY.preservationEthanol80" | "MY.preservationEthanol80Pure" | "MY.preservationEthanol96" | "MY.preservationEthanolMinus20C" | "MY.preservationEthanolDenatured" | "MY.preservationEthanolFormalin" | "MY.preservationEthanolExFormalin" | "MY.preservationFormalin" | "MY.preservationBouinSolution" | "MY.preservationPampelsFluid" | "MY.preservationGlycerol" | "MY.preservationParaffin" | "MY.preservationMercuricChloride" | "MY.preservationCryopreserved" | "MY.preservationFrozen" | "MY.preservationFrozenMinus80C" | "MY.preservationFreezeDried" | "MY.preservationGoldPlated" | "MY.preservationActiveCulture" | "MY.preservationLiving" | "MY.preservationSlide" | "MY.preservationSlideCanadaBalsam" | "MY.preservationSlideEuparal" | "MY.preservationSlidePolyviol" | "MY.preservationStuffed" | "MY.preservationCast" | "MY.preservationPlastinated" | "MY.preservationFrozenMinus80CAndEthanolMinus20C")[];
            /**
             * Primary data location
             * @description Location of the primary data if not Kotka.
             */
            primaryDataLocation?: string;
            /**
             * Nonpublic notes
             * @description Notes shown within the system for users signed in but not shown publicly anywhere. Use only for notes that absolutely need to be hidden from public view.
             */
            privateNotes?: string;
            /**
             * Publications
             * @description Publication references or doi's that refer to this specimen
             */
            publication?: string[];
            /** Raw OCR data */
            rawOCRData?: string;
            /**
             * Relationship
             * @description Relationship to another taxon OR specimen. Choose relationship type as prefix and give taxon name or specimen identifier thereafter, e.g. "parasite: Parasiticus specius" OR "host:http://tun.fi/JAA.123"
             */
            relationship?: string[];
            /**
             * Specimen history
             * @description The history of the specimen, for example how it was acquired or in which museums it has been before.
             */
            sampleHistory?: string;
            /**
             * Separated from specimen
             * @description ID of the specimen from which this has been separated
             */
            separatedFrom?: string;
            /**
             * Separated to specimen(s)
             * @description ID's of those new specimens that have been separated from this specimen
             */
            separatedTo?: string[];
            /** Serial number */
            serialNumber?: string;
            /** Source system id */
            sourceID?: string;
            /**
             * Status
             * @description Empty value means same as "ok" - that there is not anything special about the status of the specimen.
             * @enum {string}
             */
            status?: "" | "MY.statusOk" | "MY.statusMissing" | "MY.statusUnrecoverable" | "MY.statusLost" | "MY.statusDonated" | "MY.statusDeposited" | "MY.statusDeaccessioned" | "MY.statusDiscarded" | "MY.statusSpent" | "MY.statusDestroyed" | "MY.statusUndefined" | "MY.statusAxenic" | "MY.statusNonAxenic" | "MY.statusNotAvailable" | "MY.statusDead" | "MY.statusNoVoucherRetained";
            /** Temporary document */
            temp?: boolean;
            /** Template description */
            templateDescription?: string;
            /** Template name */
            templateName?: string;
            /**
             * Transcriber's notes
             * @description Additional information regarding the data entry or transcription process, e.g. unclarities, explanations for interpretations,
             */
            transcriberNotes?: string;
            /**
             * Transfer agreement
             * @description Common name of agreement concerning the transfer, if any.
             */
            transferAgreement?: string;
            /**
             * Unreliable fields
             * @description List of those fields that contain unreliable data. The list is created automatically.
             */
            unreliableFields?: string;
            /**
             * Verification status
             * @description Information about the quality of the specimen data. Possible to select several.
             */
            verificationStatus?: ("" | "MY.verificationStatusOk" | "MY.verificationStatusVerify" | "MY.verificationStatusComplete" | "MY.verificationStatusGeoreference" | "MY.verificationStatusDet" | "MY.verificationStatusCheckID" | "MY.verificationStatusVerifyCoordinates")[];
            /**
             * Voucher specimen ID
             * @description Identifier of the herbarium voucher specimen or information about it if the identifier is unknown.
             */
            voucherSpecimenID?: string;
            /** Creator */
            creator?: string;
            /**
             * Created
             * Format: date-time
             */
            dateCreated?: string;
            /**
             * Edited
             * Format: date-time
             */
            dateEdited?: string;
            /** Editors */
            editors?: string[];
            /** Images */
            images?: string[];
            /**
             * Owner of record
             * @description Team or organisation that owns the record and can edit it.
             */
            owner?: string;
            /**
             * Publicity restrictions
             * @description PUBLIC: all data can be published; PROTECTED: exact locality is hidden (100*100km square); PRIVATE: most of the data is hidden. Empty value means same as public.
             * @enum {string}
             */
            publicityRestrictions?: "" | "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
            /** Scheduled for deletion */
            scheduledForDeletion?: boolean;
            gatherings: components["schemas"]["gathering"][];
        };
        documentIdentification: {
            /** Context for the Document identification */
            "@context"?: string;
            /** Id for the Document identification */
            id?: string;
            /** Type for the Document identification */
            "@type"?: string;
            /**
             * Det.
             * @description Name of the identifier (person) preferably in format "lastname, firstname"
             */
            det?: string;
            /**
             * Det. date
             * @description Date or year when the identification was done, preferably in format "d.m.Y" or "Y"
             */
            detDate?: string;
        };
        gatheringEvent: {
            /** Context for the Global gathering event */
            "@context"?: string;
            /** Id for the Global gathering event */
            id?: string;
            /** Type for the Global gathering event */
            "@type"?: string;
            /** No units in census */
            acknowledgeNoUnitsInCensus?: boolean;
            /**
             * Artificial light
             * @enum {string}
             */
            artificialLight?: "" | "MY.artificialLightEnum1" | "MY.artificialLightEnum2" | "MY.artificialLightEnum3" | "MY.artificialLightEnum4" | "MY.artificialLightEnum5";
            /** Breaks kept in minutes */
            breaksDuringCensusInMinutes?: number;
            /** Weather (etc) hindered the census */
            censusHinderedByEnviromentalFactors?: boolean;
            /** Fog hindered the census */
            censusHinderedByFog?: boolean;
            /** Rain hindered the census */
            censusHinderedByRain?: boolean;
            /** Wind hindered the census */
            censusHinderedByWind?: boolean;
            /** Was the census prematurely aborted? */
            censusPrematurelyAborted?: boolean;
            /**
             * Cloudiness
             * @enum {string}
             */
            cloudCover?: "" | "MY.cloudCoverOktaEnumUnknown" | "MY.cloudCoverOktaEnum0" | "MY.cloudCoverOktaEnum1" | "MY.cloudCoverOktaEnum2" | "MY.cloudCoverOktaEnum3" | "MY.cloudCoverOktaEnum4" | "MY.cloudCoverOktaEnum5" | "MY.cloudCoverOktaEnum6" | "MY.cloudCoverOktaEnum7" | "MY.cloudCoverOktaEnum8";
            /**
             * End cloud cover
             * @enum {string}
             */
            cloudCoverEnd?: "" | "MY.cloudCoverOktaEnumUnknown" | "MY.cloudCoverOktaEnum0" | "MY.cloudCoverOktaEnum1" | "MY.cloudCoverOktaEnum2" | "MY.cloudCoverOktaEnum3" | "MY.cloudCoverOktaEnum4" | "MY.cloudCoverOktaEnum5" | "MY.cloudCoverOktaEnum6" | "MY.cloudCoverOktaEnum7" | "MY.cloudCoverOktaEnum8";
            /**
             * Start cloud cover
             * @enum {string}
             */
            cloudCoverStart?: "" | "MY.cloudCoverOktaEnumUnknown" | "MY.cloudCoverOktaEnum0" | "MY.cloudCoverOktaEnum1" | "MY.cloudCoverOktaEnum2" | "MY.cloudCoverOktaEnum3" | "MY.cloudCoverOktaEnum4" | "MY.cloudCoverOktaEnum5" | "MY.cloudCoverOktaEnum6" | "MY.cloudCoverOktaEnum7" | "MY.cloudCoverOktaEnum8";
            completeList?: components["schemas"]["completeList"];
            /** Start date */
            dateBegin?: string;
            /** End date */
            dateEnd?: string;
            gatheringFact?: components["schemas"]["gatheringFact"];
            geometry?: components["schemas"]["geometry"];
            /** GPS used */
            gpsUsed?: boolean;
            /**
             * Leg
             * @description Name of the collector(s), in format 'Lastname, Firstname; Lastname Firstname'
             */
            leg?: string[];
            /** Display names publically? */
            legPublic?: boolean;
            /**
             * Kyttjtunnus
             * @description Alkuperislhteen kyttjtunnus
             */
            legUserID?: string[];
            /** Info about this route */
            namedPlaceNotes?: string;
            /** Next monitoring year */
            nextMonitoringYear?: number;
            /**
             * Notes
             * @description Additional information to the data in each section.
             */
            notes?: string;
            /**
             * Rain intensity
             * @enum {string}
             */
            rainIntensity?: "" | "MY.rainIntensityEnumNoRain" | "MY.rainIntensityEnumLightRain" | "MY.rainIntensityEnumModerateRain" | "MY.rainIntensityEnumHeavyRain" | "MY.rainIntensityEnumTorrentialRain";
            /** Adhered route direction */
            routeDirectionAdhered?: boolean;
            /** Spotting scope */
            spottingScopeUsed?: boolean;
            /** Start distance from NE corner (m) */
            startDistanceFromNECorner?: string;
            /** Start point deviation (m) */
            startPointDeviation?: number;
            taxonCensus?: components["schemas"]["taxonCensus"][];
            /** Temperature in celsius */
            temperature?: number;
            /** End temperature / C */
            temperatureEnd?: number;
            /** Start temperature / C */
            temperatureStart?: number;
            /** End time */
            timeEnd?: string;
            /** Start time */
            timeStart?: string;
        };
        completeList: {
            /** Context for the MY.completeListClass */
            "@context"?: string;
            /** Id for the MY.completeListClass */
            id?: string;
            /** Type for the MY.completeListClass */
            "@type"?: string;
            /** Species */
            completeListTaxonID?: string;
            /**
             * Species list completeness
             * @enum {string}
             */
            completeListType?: "" | "MY.completeListTypeCompleteWithBreedingStatus" | "MY.completeListTypeComplete" | "MY.completeListTypeIncomplete";
        };
        gatheringFact: {
            /** Context for the Keruutapahtuman faktat */
            "@context"?: string;
            /** Id for the Keruutapahtuman faktat */
            id?: string;
            /** Type for the Keruutapahtuman faktat */
            "@type"?: string;
            /**
             * I placed the sound recorder to the terrain
             * @enum {string}
             */
            batCollector?: "" | "MY.batCollectorAlone" | "MY.batCollectorWithProjectGroupMember" | "MY.batCollectorSomeoneElse";
            /** Binoculars */
            binocularsUsed?: boolean;
            /** Census area/ha */
            censusAreaHectares?: number;
            /** Estimated of other expenses in euros */
            invasiveControlOtherExpensesInEuros?: number;
            /** Work hours spent during the control */
            invasiveControlWorkHours?: number;
            /** Biotope counted */
            lineTransectSegmentCounted?: boolean;
            /** Biotope's end meter amount from the start of the line */
            lineTransectSegmentMetersEnd?: number;
            /** Biotope's start meter amount from the start of the line */
            lineTransectSegmentMetersStart?: number;
            /**
             * Site classification
             * @enum {string}
             */
            lolifeSiteClassification?: "" | "MY.lolifeSiteClassificationExcellent" | "MY.lolifeSiteClassificationSuboptimal" | "MY.lolifeSiteClassificationPossible" | "MY.lolifeSiteClassificationCurrentlyUnsuitable" | "MY.lolifeSiteClassificationPermanentlyUnsuitable";
            /** Classification comments */
            lolifeSiteClassificationComments?: string;
            /** Observed area/ha */
            observedAreaHectares?: number;
            /**
             * Biotooppi
             * @enum {string}
             */
            pointCountHabitat?: "" | "MY.pointCountHabitat0" | "MY.pointCountHabitat1" | "MY.pointCountHabitat2" | "MY.pointCountHabitat3" | "MY.pointCountHabitat4" | "MY.pointCountHabitat5" | "MY.pointCountHabitat6" | "MY.pointCountHabitat7" | "MY.pointCountHabitat8" | "MY.pointCountHabitat9" | "MY.pointCountHabitat10" | "MY.pointCountHabitat11" | "MY.pointCountHabitat12" | "MY.pointCountHabitat13" | "MY.pointCountHabitat14" | "MY.pointCountHabitat15" | "MY.pointCountHabitat16" | "MY.pointCountHabitat17";
            /** Shoreline length/m */
            shorelineLengthMeters?: number;
            /** Spotting scope */
            spottingScopeUsed?: boolean;
            /** Sunniness % */
            sunniness?: number;
            /**
             * Windiness
             * @enum {string}
             */
            sykeButterFlyCensusWind?: "" | "MY.sykeButterFlyCensusWindEnumUnknown" | "MY.sykeButterFlyCensusWindEnum0" | "MY.sykeButterFlyCensusWindEnum1" | "MY.sykeButterFlyCensusWindEnum2" | "MY.sykeButterFlyCensusWindEnum3" | "MY.sykeButterFlyCensusWindEnum4" | "MY.sykeButterFlyCensusWindEnum5" | "MY.sykeButterFlyCensusWindEnum6";
            /**
             * End windiness
             * @enum {string}
             */
            sykeButterFlyCensusWindEnd?: "" | "MY.sykeButterFlyCensusWindEnumUnknown" | "MY.sykeButterFlyCensusWindEnum0" | "MY.sykeButterFlyCensusWindEnum1" | "MY.sykeButterFlyCensusWindEnum2" | "MY.sykeButterFlyCensusWindEnum3" | "MY.sykeButterFlyCensusWindEnum4" | "MY.sykeButterFlyCensusWindEnum5" | "MY.sykeButterFlyCensusWindEnum6";
            /**
             * Start windiness
             * @enum {string}
             */
            sykeButterFlyCensusWindStart?: "" | "MY.sykeButterFlyCensusWindEnumUnknown" | "MY.sykeButterFlyCensusWindEnum0" | "MY.sykeButterFlyCensusWindEnum1" | "MY.sykeButterFlyCensusWindEnum2" | "MY.sykeButterFlyCensusWindEnum3" | "MY.sykeButterFlyCensusWindEnum4" | "MY.sykeButterFlyCensusWindEnum5" | "MY.sykeButterFlyCensusWindEnum6";
            /**
             * Census period
             * @enum {string}
             */
            waterbirdCensusPeriod?: "" | "MY.waterbirdCensusPeriodEnum1" | "MY.waterbirdCensusPeriodEnum2" | "MY.waterbirdCensusPeriodEnumJuvenile" | "MY.waterbirdCensusPeriodEnumAdditional" | "MY.waterbirdCensusPeriodEnumCombined";
            /**
             * Habitat
             * @enum {string}
             */
            waterbirdHabitat?: "" | "MY.waterbirdHabitatEnum1" | "MY.waterbirdHabitatEnum2" | "MY.waterbirdHabitatEnum3" | "MY.waterbirdHabitatEnum4" | "MY.waterbirdHabitatEnum5" | "MY.waterbirdHabitatEnum6" | "MY.waterbirdHabitatEnum7" | "MY.waterbirdHabitatEnum8" | "MY.waterbirdHabitatEnum9" | "MY.waterbirdHabitatEnum10";
            /** Atlas grid */
            ykjSquareNumber?: string;
            /** Urpiaisten ruokailut lepll */
            ACAFLAonAlder?: number;
            /** Urpiaisten ruokailut koivulla */
            ACAFLAonBirch?: number;
            /** Urpiaisten ruokailut maassa */
            ACAFLAonGround?: number;
            /** Urpiaisten ruokailut mnnyll */
            ACAFLAonPine?: number;
            /** Urpiaisten ruokailut kuusella */
            ACAFLAonSpruce?: number;
            /** Vihervarpusten ruokailut lepll */
            CARSPIonAlder?: number;
            /** Vihervarpusten ruokailut koivulla */
            CARSPIonBirch?: number;
            /** Vihervarpusten ruokailut maassa */
            CARSPIonGround?: number;
            /** CARSPIonPine */
            CARSPIonPine?: number;
            /** Vihervarpusten ruokailut kuusella */
            CARSPIonSpruce?: number;
            /** Kpylintujen ruokailut lepll */
            LOXIAonAlder?: number;
            /** Kpylintujen ruokailut koivulla */
            LOXIAonBirch?: number;
            /** Kpylintujen ruokailut maassa */
            LOXIAonGround?: number;
            /** Kpylintujen ruokailut mnnyll */
            LOXIAonPine?: number;
            /** Kpylintujen ruokailut kuusella */
            LOXIAonSpruce?: number;
            /**
             * Tilhi
             * @enum {string}
             */
            abundanceBOMGAR?: "" | "WBC.speciesAbundanceEnum0" | "WBC.speciesAbundanceEnum1" | "WBC.speciesAbundanceEnum2" | "WBC.speciesAbundanceEnum3";
            /**
             * Taviokuurna
             * @enum {string}
             */
            abundancePINENU?: "" | "WBC.speciesAbundanceEnum0" | "WBC.speciesAbundanceEnum1" | "WBC.speciesAbundanceEnum2" | "WBC.speciesAbundanceEnum3";
            /**
             * Rkttirastas
             * @enum {string}
             */
            abundanceTURPIL?: "" | "WBC.speciesAbundanceEnum0" | "WBC.speciesAbundanceEnum1" | "WBC.speciesAbundanceEnum2" | "WBC.speciesAbundanceEnum3";
            /** Lintulautoja (kpl) */
            birdFeederCount?: number;
            /** Kaatopaikan lintulaudat */
            birdFeederCountBiotopeA?: number;
            /** Kaupunkiasutuksen lintulaudat */
            birdFeederCountBiotopeB?: number;
            /** Maaseutuasutuksen lintulaudat */
            birdFeederCountBiotopeC?: number;
            /** Pellon lintulaudat */
            birdFeederCountBiotopeD?: number;
            /** Metsn lintulaudat */
            birdFeederCountBiotopeE?: number;
            /** Lintulaudat muu biotooppi */
            birdFeederCountBiotopeF?: number;
            /** Hakkuuaukean lintulaudat */
            birdFeederCountBiotopeG?: number;
            /** Ruovikon lintulaudat */
            birdFeederCountBiotopeH?: number;
            /**
             * Pilvisyys ja sade
             * @enum {string}
             */
            cloudAndRain?: "" | "WBC.cloudAndRainEnum0" | "WBC.cloudAndRainEnum1" | "WBC.cloudAndRainEnum2" | "WBC.cloudAndRainEnum3" | "WBC.cloudAndRainEnum4";
            /** Mit biotooppiin Muu (F) kuuluu */
            descriptionBiotopeF?: string;
            /** Ruokintapaikkoja (kpl) */
            feedingStationCount?: number;
            /** feedingStationCountBiotopeA */
            feedingStationCountBiotopeA?: number;
            /** Kaupunkiasutuksen ruokintapaikat */
            feedingStationCountBiotopeB?: number;
            /** Maaseutuasutuksen ruokintapaikat */
            feedingStationCountBiotopeC?: number;
            /** Pellon ruokintapaikat */
            feedingStationCountBiotopeD?: number;
            /** Metsn ruokintapaikat */
            feedingStationCountBiotopeE?: number;
            /** Ruokintapaikat muu biotooppi */
            feedingStationCountBiotopeF?: number;
            /** Ruovikon ruokintapaikat */
            feedingStationCountBiotopeG?: number;
            /** Ruovikon ruokintapaikat */
            feedingStationCountBiotopeH?: number;
            /**
             * Jpeite
             * @enum {string}
             */
            iceCover?: "" | "WBC.iceCoverEnum0" | "WBC.iceCoverEnum1" | "WBC.iceCoverEnum2" | "WBC.iceCoverEnum3" | "WBC.iceCoverEnum4";
            /** Keskilmptila (asteen tarkkuus) */
            meanTemperature?: number;
            /** Laskijoiden lukumr */
            observerCount?: number;
            /** Havainnoijanumero */
            observerID?: number;
            /**
             * Mnnynkpyj laskenta-aikaan
             * @enum {string}
             */
            pineConesAtCensus?: "" | "WBC.berriesAndConesEnum0" | "WBC.berriesAndConesEnum1" | "WBC.berriesAndConesEnum2" | "WBC.berriesAndConesEnum3" | "WBC.berriesAndConesEnum4" | "WBC.berriesAndConesEnum5" | "WBC.berriesAndConesEnum6";
            /** Reitin numero */
            routeID?: number;
            /** Reitin pituus (m) */
            routeLength?: number;
            /** Route length dump */
            routeLengthBiotopeA?: number;
            /** Route length urban */
            routeLengthBiotopeB?: number;
            /** Route length countryside */
            routeLengthBiotopeC?: number;
            /** Route length field */
            routeLengthBiotopeD?: number;
            /** Route length forest */
            routeLengthBiotopeE?: number;
            /** Route length other biotope */
            routeLengthBiotopeF?: number;
            /** Route length cutting open */
            routeLengthBiotopeG?: number;
            /** Route length reed */
            routeLengthBiotopeH?: number;
            /** Reitin muutokset (m) */
            routeLengthChange?: number;
            /** Reitin muutokset kaatopaikka */
            routeLengthChangeBiotopeA?: number;
            /** Reitin muutokset kaupunkiasutus */
            routeLengthChangeBiotopeB?: number;
            /** Reitin muutokset maaseutuasutus */
            routeLengthChangeBiotopeC?: number;
            /** Reitin muutokset pelto */
            routeLengthChangeBiotopeD?: number;
            /** Reitin muutokset mets */
            routeLengthChangeBiotopeE?: number;
            /** Reitin muutokset muu biotooppi */
            routeLengthChangeBiotopeF?: number;
            /** Reitin muutokset hakkuuaukea */
            routeLengthChangeBiotopeG?: number;
            /** Reitin muutokset ruovikko */
            routeLengthChangeBiotopeH?: number;
            /**
             * Puissa oleva lumi ja jkarsta
             * @enum {string}
             */
            snowAndIceOnTrees?: "" | "WBC.snowAndIceOnTreesEnum0" | "WBC.snowAndIceOnTreesEnum1" | "WBC.snowAndIceOnTreesEnum2" | "WBC.snowAndIceOnTreesEnum3";
            /**
             * Lumipeite
             * @enum {string}
             */
            snowCover?: "" | "WBC.snowCoverEnum0" | "WBC.snowCoverEnum1" | "WBC.snowCoverEnum2" | "WBC.snowCoverEnum3" | "WBC.snowCoverEnum4" | "WBC.snowCoverEnum5" | "WBC.snowCoverEnum6" | "WBC.snowCoverEnum7" | "WBC.snowCoverEnum8";
            /**
             * Pihlajanmarjoja laskenta-aikaan
             * @enum {string}
             */
            sorbusBerriesAtCensus?: "" | "WBC.berriesAndConesEnum0" | "WBC.berriesAndConesEnum1" | "WBC.berriesAndConesEnum2" | "WBC.berriesAndConesEnum3" | "WBC.berriesAndConesEnum4" | "WBC.berriesAndConesEnum5" | "WBC.berriesAndConesEnum6";
            /**
             * Pihlajanmarjoja alkusyksyll
             * @enum {string}
             */
            sorbusBerriesEarlyFall?: "" | "WBC.berriesAndConesEnum0" | "WBC.berriesAndConesEnum1" | "WBC.berriesAndConesEnum2" | "WBC.berriesAndConesEnum3" | "WBC.berriesAndConesEnum4" | "WBC.berriesAndConesEnum5" | "WBC.berriesAndConesEnum6";
            /**
             * Kuusenkpyj laskenta-aikaan
             * @enum {string}
             */
            spruceConesAtCensus?: "" | "WBC.berriesAndConesEnum0" | "WBC.berriesAndConesEnum1" | "WBC.berriesAndConesEnum2" | "WBC.berriesAndConesEnum3" | "WBC.berriesAndConesEnum4" | "WBC.berriesAndConesEnum5" | "WBC.berriesAndConesEnum6";
            /**
             * Maassa olevan lumen laatu
             * @enum {string}
             */
            typeOfSnowCover?: "" | "WBC.typeOfSnowCoverEnum0" | "WBC.typeOfSnowCoverEnum1" | "WBC.typeOfSnowCoverEnum2";
            /**
             * Nkyvyys
             * @enum {string}
             */
            visibility?: "" | "WBC.visibilityEnum0" | "WBC.visibilityEnum1" | "WBC.visibilityEnum2" | "WBC.visibilityEnum3" | "WBC.visibilityEnum4";
            /**
             * Vesistt
             * @enum {string}
             */
            waterbodies?: "" | "WBC.waterbodiesEnum0" | "WBC.waterbodiesEnum1" | "WBC.waterbodiesEnum2" | "WBC.waterbodiesEnum3" | "WBC.waterbodiesEnum4" | "WBC.waterbodiesEnum5";
            /**
             * Kulkutapa
             * @enum {string}
             */
            wayOfTravel?: "" | "WBC.wayOfTravelEnum0" | "WBC.wayOfTravelEnum1" | "WBC.wayOfTravelEnum2" | "WBC.wayOfTravelEnum3" | "WBC.wayOfTravelEnum9";
            /** Kulkutavan kuvaus */
            wayOfTravelNotes?: string;
            /**
             * Tuuli
             * @enum {string}
             */
            wind?: "" | "WBC.windEnum0" | "WBC.windEnum1" | "WBC.windEnum2" | "WBC.windEnum3" | "WBC.windEnum4";
        };
        geometry: ({
            /** @enum {string} */
            type: "Point";
            coordinates: number[];
            bbox?: number[];
        } | {
            /** @enum {string} */
            type: "LineString";
            coordinates: number[][];
            bbox?: number[];
        } | {
            /** @enum {string} */
            type: "Polygon";
            coordinates: number[][][];
            bbox?: number[];
        } | {
            /** @enum {string} */
            type: "MultiPoint";
            coordinates: number[][];
            bbox?: number[];
        } | {
            /** @enum {string} */
            type: "MultiLineString";
            coordinates: number[][][];
            bbox?: number[];
        } | {
            /** @enum {string} */
            type: "MultiPolygon";
            coordinates: number[][][][];
            bbox?: number[];
        }) | {
            /** @enum {string} */
            type: "GeometryCollection";
            geometries: ({
                /** @enum {string} */
                type: "Point";
                coordinates: number[];
                bbox?: number[];
            } | {
                /** @enum {string} */
                type: "LineString";
                coordinates: number[][];
                bbox?: number[];
            } | {
                /** @enum {string} */
                type: "Polygon";
                coordinates: number[][][];
                bbox?: number[];
            } | {
                /** @enum {string} */
                type: "MultiPoint";
                coordinates: number[][];
                bbox?: number[];
            } | {
                /** @enum {string} */
                type: "MultiLineString";
                coordinates: number[][][];
                bbox?: number[];
            } | {
                /** @enum {string} */
                type: "MultiPolygon";
                coordinates: number[][][][];
                bbox?: number[];
            })[];
            bbox?: number[];
        };
        taxonCensus: {
            /** Context for the Completeness of census */
            "@context"?: string;
            /** Id for the Completeness of census */
            id?: string;
            /** Type for the Completeness of census */
            "@type"?: string;
            /** Censused taxon */
            censusTaxonID?: string;
            /**
             * Censused taxon set
             * @enum {string}
             */
            censusTaxonSetID?: "" | "MX.taxonSetSykeButterflyCensusPapilionoidea" | "MX.taxonSetSykeButterflyCensusOther" | "MX.taxonSetWaterbirdWaterbirds" | "MX.taxonSetWaterbirdWaders" | "MX.taxonSetWaterbirdGulls" | "MX.taxonSetWaterbirdPasserines" | "MX.taxonSetWaterbirdAmphibia" | "MX.taxonSetSykeBumblebee" | "MVL.1201" | "MX.taxonSetSykeBumblebeeOther" | "MX.taxonSetBirdAtlasCommon" | "MX.taxonSetBiomonCompleteListOdonata" | "MX.taxonSetBiomonCompleteListButterflies" | "MX.taxonSetBiomonCompleteListMoths" | "MX.taxonSetBiomonCompleteListBombus" | "MX.taxonSetBiomonCompleteListAmphibiaReptilia" | "MX.taxonSetBiomonCompleteListLargeFlowers" | "MX.taxonSetBiomonCompleteListSubarcticPlants" | "MX.taxonSetBiomonCompleteListMacrolichens" | "MX.taxonSetBiomonCompleteListBracketFungi" | "MX.taxonSetBiomonCompleteListPracticalFungi" | "MX.taxonSetSykeMacrozoobenthos";
            /**
             * Completeness of census
             * @enum {string}
             */
            taxonCensusType: "MY.taxonCensusTypeCounted" | "MY.taxonCensusTypeEstimated" | "MY.taxonCensusTypeNotCounted";
        };
        gathering: {
            /** Context for the Gathering event */
            "@context"?: string;
            /** Id for the Gathering event */
            id?: string;
            /** Type for the Gathering event */
            "@type"?: string;
            /**
             * AFE grid
             * @description AFE grid name
             */
            AFEQuadrat?: string;
            /**
             * UTM grid
             * @description UTM grid name
             */
            UTMQuadrat?: string;
            /** No units in census */
            acknowledgeNoUnitsInCensus?: boolean;
            /**
             * Administrative province
             * @description Regions, rayons, provinces and other administrative areas. Separate multiple names with commas, from generic to specific. (E.g. Etel-Suomen lni, Uusimaa)
             */
            administrativeProvince?: string;
            /**
             * Alt in meters
             * @description Altitude form sea level in meters, single value or range (E.g. 90, or 80-100). No GPS altitude here.
             */
            alt?: string;
            /** Area details */
            areaDetail?: string;
            /**
             * Associated observation taxa
             * @description Write associated observation taxa names here, separated by a semicolon (;). E.g.: "Betula pendula; Betula pubescens; Poaceae". These will form their own units of the type observation.
             */
            associatedObservationTaxa?: string;
            /**
             * Associated specimen taxa
             * @description Write associated specimen taxa names here, separated by a semicolon (;). E.g.: "Betula pendula; Betula pubescens; Poaceae". These will form their own units of the type Preserved specimen.
             */
            associatedSpecimenTaxa?: string;
            /**
             * Habitat
             * @description Bat habitat
             */
            batHabitat?: ("" | "MY.batHabitatYardCityCentre" | "MY.batHabitatYardSuburbs" | "MY.batHabitatYardRural" | "MY.batHabitatRoadSide" | "MY.batHabitatStandOfTreesCloseToBuildings" | "MY.batHabitatParkWIthFewTrees" | "MY.batHabitatParkAbundantInTrees" | "MY.batHabitatSparseForest" | "MY.batHabitatDenseForest" | "MY.batHabitatEdgeOfShoreCoppice" | "MY.batHabitatLakeShore" | "MY.batHabitatSeaShore" | "MY.batHabitatArchipelago" | "MY.batHabitatStreamOrRiverBank" | "MY.batHabitatOldBuildingOrRuins" | "MY.batHabitatCountryside")[];
            /** Binoculars */
            binocularsUsed?: boolean;
            /**
             * Biogeographical province
             * @description Formal abbreviation. For Finnish elimaakunnat, use Finnish abbreviation.
             */
            biologicalProvince?: string;
            /** Weather (etc) hindered the census */
            censusHinderedByEnviromentalFactors?: boolean;
            /** Fog hindered the census */
            censusHinderedByFog?: boolean;
            /** Rain hindered the census */
            censusHinderedByRain?: boolean;
            /** Wind hindered the census */
            censusHinderedByWind?: boolean;
            /**
             * Collecting event name
             * @description Name of an expedition or such.
             */
            collectingEventName?: string;
            /** Prevention measures */
            controlActivitiesNotes?: string;
            /**
             * Coordinate notes
             * @description Free-text notes about the coordinates.
             */
            coordinateNotes?: string;
            /**
             * Error radius in meters
             * @description Maximum error of coordinates in meters
             */
            coordinateRadius?: string;
            /**
             * Coord source
             * @description Use for NEW SPECIMENS: Where the coordinates have been acquired
             * @enum {string}
             */
            coordinateSource?: "" | "MY.coordinateSourceGps" | "MY.coordinateSourcePeruskartta" | "MY.coordinateSourcePapermap" | "MY.coordinateSourceKotkamap" | "MY.coordinateSourceKarttapaikka" | "MY.coordinateSourceRetkikartta" | "MY.coordinateSourceGoogle" | "MY.coordinateSourceLajifi" | "MY.coordinateSourceOther" | "MY.coordinateSourceUnknown";
            /**
             * Coordinate system
             * @description More information about the coordinate systems: https://wiki.helsinki.fi/display/digit/Entering+specimen+data
             * @enum {string}
             */
            coordinateSystem?: "" | "MY.coordinateSystemYkj" | "MY.coordinateSystemWgs84" | "MY.coordinateSystemWgs84dms" | "MY.coordinateSystemKkj" | "MY.coordinateSystemEtrs-tm35fin" | "MY.coordinateSystemDd" | "MY.coordinateSystemDms";
            /** Finnish uniform grid coordinates */
            coordinatesGridYKJ?: string;
            /**
             * Verbatim coordinates from label or other original source
             * @description Coordinates, possible coordinate system and error radius word-to-word as they appear on the label or other original source, errors and all.
             */
            coordinatesVerbatim?: string;
            /**
             * Country
             * @description Country name in English, or 2-letter country code, or name from label
             */
            country?: string;
            /**
             * County
             * @description County (piirikunta, kreivikunta etc.)
             */
            county?: string;
            /** Start date */
            dateBegin?: string;
            /** End date */
            dateEnd?: string;
            /**
             * Verbatim date from original source
             * @description Date just as it appears on the label or other original source, no interpretation, errors and all
             */
            dateVerbatim?: string;
            /**
             * Depth in meters
             * @description Depth in meters, single value or range (E.g. 0.9, or 0.8-1.0)
             */
            depth?: string;
            /** dynamicProperties */
            dynamicProperties?: string;
            /** Event Date */
            eventDate?: string;
            /**
             * Forest vegetation zone
             * @description Finnish forest vegetation zone
             * @enum {string}
             */
            forestVegetationZone?: "" | "MY.forestVegetationZone1a" | "MY.forestVegetationZone1b" | "MY.forestVegetationZone2a" | "MY.forestVegetationZone2b" | "MY.forestVegetationZone3a" | "MY.forestVegetationZone3b" | "MY.forestVegetationZone3c" | "MY.forestVegetationZone4a" | "MY.forestVegetationZone4b" | "MY.forestVegetationZone4c" | "MY.forestVegetationZone4d";
            gatheringFact?: components["schemas"]["gatheringFact"];
            /**
             * Gathering event type
             * @enum {string}
             */
            gatheringType?: "" | "MY.gatheringTypeForagingArea" | "MY.gatheringTypeBreedingAndRestingArea" | "MY.gatheringTypeCavityTree" | "MY.gatheringTypeDroppingsTree" | "MY.gatheringTypeNestTree" | "MY.gatheringTypeLolifeAccess" | "MY.gatheringTypeLolifeCoreZone" | "MY.gatheringTypeLolifeHabitatZone" | "MY.gatheringTypeLolifeApplicableZone" | "MY.gatheringTypeWaterbirdPoint" | "MY.gatheringTypeWaterbirdRound";
            geometry?: components["schemas"]["geometry"];
            /**
             * Georeferencing source
             * @description Use for OLD SPECIMENS: What source was used to get coordinates based on locality names
             * @enum {string}
             */
            georeferenceSource?: "" | "MY.georeferenceSourceKotka" | "MY.georeferenceSourceKarttapaikka" | "MY.georeferenceSourcePaikkatietoikkuna" | "MY.georeferenceSourceKarjalankartat" | "MY.georeferenceSourceRetkikartta" | "MY.georeferenceSourceGoogle" | "MY.georeferenceSourcePeruskartta" | "MY.georeferenceSourcePapermap" | "MY.georeferenceSourceOtherpaper" | "MY.georeferenceSourceOtherweb" | "MY.georeferenceSourceCatalogue" | "MY.georeferenceSourceBiogeomancer" | "MY.georeferenceSourceGeolocate" | "MY.georeferenceSourceOther" | "MY.georeferenceSourceUnknown";
            /** Habitat */
            habitat?: ("" | "MY.habitatEnumValue1" | "MY.habitatEnumValue2" | "MY.habitatEnumValue3" | "MY.habitatEnumValue4" | "MY.habitatEnumValue5" | "MY.habitatEnumValue6" | "MY.habitatEnumValue7" | "MY.habitatEnumValue8" | "MY.habitatEnumValue9" | "MY.habitatEnumValue10" | "MY.habitatEnumValue11" | "MY.habitatEnumValue12" | "MY.habitatEnumValue13" | "MY.habitatEnumValue14" | "MY.habitatEnumValue15" | "MY.habitatEnumValue16" | "MY.habitatEnumValue17" | "MY.habitatEnumValue18" | "MY.habitatEnumValue19" | "MY.habitatEnumValue20" | "MY.habitatEnumValue21" | "MY.habitatEnumValue22" | "MY.habitatEnumValue23" | "MY.habitatEnumValue24" | "MY.habitatEnumValue25" | "MY.habitatEnumValue26" | "MY.habitatEnumValue27" | "MY.habitatEnumValue28" | "MY.habitatEnumValue29" | "MY.habitatEnumValue30" | "MY.habitatEnumValue31" | "MY.habitatEnumValue32" | "MY.habitatEnumValue33" | "MY.habitatEnumValue34" | "MY.habitatEnumValue35" | "MY.habitatEnumValue36" | "MY.habitatEnumValue87" | "MY.habitatEnumValue37" | "MY.habitatEnumValue38" | "MY.habitatEnumValue39" | "MY.habitatEnumValue40" | "MY.habitatEnumValue41" | "MY.habitatEnumValue42" | "MY.habitatEnumValue43" | "MY.habitatEnumValue44" | "MY.habitatEnumValue45" | "MY.habitatEnumValue46" | "MY.habitatEnumValue47" | "MY.habitatEnumValue48" | "MY.habitatEnumValue49" | "MY.habitatEnumValue50" | "MY.habitatEnumValue51" | "MY.habitatEnumValue52" | "MY.habitatEnumValue53" | "MY.habitatEnumValue54" | "MY.habitatEnumValue55" | "MY.habitatEnumValue56" | "MY.habitatEnumValue57" | "MY.habitatEnumValue58" | "MY.habitatEnumValue59" | "MY.habitatEnumValue60" | "MY.habitatEnumValue61" | "MY.habitatEnumValue62" | "MY.habitatEnumValue63" | "MY.habitatEnumValue64" | "MY.habitatEnumValue65" | "MY.habitatEnumValue66" | "MY.habitatEnumValue67" | "MY.habitatEnumValue68" | "MY.habitatEnumValue69" | "MY.habitatEnumValue70" | "MY.habitatEnumValue71" | "MY.habitatEnumValue72" | "MY.habitatEnumValue73" | "MY.habitatEnumValue74" | "MY.habitatEnumValue75" | "MY.habitatEnumValue76" | "MY.habitatEnumValue77" | "MY.habitatEnumValue78" | "MY.habitatEnumValue79" | "MY.habitatEnumValue80" | "MY.habitatEnumValue81" | "MY.habitatEnumValue82" | "MY.habitatEnumValue83" | "MY.habitatEnumValue84" | "MY.habitatEnumValue85" | "MY.habitatEnumValue86" | "MY.habitatEnumValue88" | "MY.habitatEnumValue89" | "MY.habitatEnumValue90" | "MY.habitatEnumValue91" | "MY.habitatEnumValue92" | "MY.habitatEnumValue93" | "MY.habitatEnumValue94")[];
            /** Additional information of habitat */
            habitatAttributes?: ("" | "MY.habitatAttributesEnumValue1" | "MY.habitatAttributesEnumValue2" | "MY.habitatAttributesEnumValue3" | "MY.habitatAttributesEnumValue4" | "MY.habitatAttributesEnumValue5" | "MY.habitatAttributesEnumValue6" | "MY.habitatAttributesEnumValue7" | "MY.habitatAttributesEnumValue8" | "MY.habitatAttributesEnumValue9" | "MY.habitatAttributesEnumValue10" | "MY.habitatAttributesEnumValue11" | "MY.habitatAttributesEnumValue12" | "MY.habitatAttributesEnumValue13" | "MY.habitatAttributesEnumValue14" | "MY.habitatAttributesEnumValue15" | "MY.habitatAttributesEnumValue16" | "MY.habitatAttributesEnumValue17" | "MY.habitatAttributesEnumValue18" | "MY.habitatAttributesEnumValue19" | "MY.habitatAttributesEnumValue20" | "MY.habitatAttributesEnumValue21" | "MY.habitatAttributesEnumValue22")[];
            /**
             * Habitat classification
             * @description Formal habitat name or abbreviation. If several, separate with semicolons (E.g. 'OMT; OMaT').
             */
            habitatClassification?: string;
            /**
             * Habitat description
             * @description Informal description of the habitat.
             */
            habitatDescription?: string;
            /** hasUnit */
            hasUnit?: string[];
            /**
             * Higher geography
             * @description If country is not known or not applicable, for example continent, ocean or large island
             */
            higherGeography?: string;
            /** Esiintymn koko / laajuus tiedossa */
            invasiveControlAreaKnown?: boolean;
            /** Is the occurrence a direct threat to e.g. endangered species, biotopes or humans? */
            invasiveControlDangerous?: boolean;
            /** Description of threats */
            invasiveControlDangerousDescription?: string;
            /**
             * Control level
             * @enum {string}
             */
            invasiveControlEffectiveness?: "" | "MY.invasiveControlEffectivenessFull" | "MY.invasiveControlEffectivenessPartial" | "MY.invasiveControlEffectivenessNone" | "MY.invasiveControlEffectivenessNotFound";
            /** Notes of control level */
            invasiveControlEffectivenessNotes?: string;
            /** Control methods */
            invasiveControlMethods?: ("" | "MY.invasiveControlMethodsMechanical" | "MY.invasiveControlMethodsChemical" | "MY.invasiveControlMethodsBiological" | "MY.invasiveControlMethodsOther")[];
            /** Description of control methods */
            invasiveControlMethodsDescription?: string;
            /** Are follow-up controls needed? */
            invasiveControlOpen?: boolean;
            /** Description of follow-up controls? */
            invasiveControlOpenDescription?: string;
            /** Estimated of other expenses in euros */
            invasiveControlOtherExpensesInEuros?: number;
            /** Control target taxon */
            invasiveControlTaxon?: string[];
            /**
             * Is part of
             * @description Which parent or larger collection this is part of.
             */
            isPartOf?: string;
            /** Keywords */
            keywords?: string[];
            /**
             * Lat (N)
             * @description Latitude. For southern latitudes, use negative value.
             */
            latitude?: string;
            /**
             * Leg
             * @description Name of the collector(s), in format 'Lastname, Firstname; Lastname Firstname'
             */
            leg?: string[];
            /**
             * Kyttjtunnus
             * @description Alkuperislhteen kyttjtunnus
             */
            legUserID?: string[];
            /**
             * Verbatim leg from orginal source
             * @description Leg just as it appears in the label or other original source, no interpretation, errors and all.
             */
            legVerbatim?: string;
            /**
             * Locality names
             * @description Official name of the locality in basic form. Separate multiple names with commas, from generic to specific. No informal description here.
             */
            locality?: string;
            /**
             * Locality description
             * @description Informal description of the exact locality, e.g. '5 km NE of city X, under stone bridge'
             */
            localityDescription?: string;
            /**
             * Locality ID
             * @description An unique identifier or code for the locality, if the locality has one (e.g. from SAPO-ontology).
             */
            localityID?: string;
            /**
             * Verbatim locality from label or other original source
             * @description Locality word-to-word as it appears on the label or other original source, errors and all
             */
            localityVerbatim?: string;
            /**
             * Lon (E)
             * @description Longitude. For western longitudes, use negative value.
             */
            longitude?: string;
            /**
             * Moth sampling method
             * @enum {string}
             */
            mothSamplingMethod?: "" | "MY.mothSamplingMethodJA500" | "MY.mothSamplingMethodLHG" | "MY.mothSamplingMethodLS" | "MY.mothSamplingMethodMAARY" | "MY.mothSamplingMethodPR125" | "MY.mothSamplingMethodPR250";
            /**
             * Municipality
             * @description Municipality, commune, town, city or civil parish
             */
            municipality?: string;
            /** Named place */
            namedPlaceID?: string;
            /**
             * Notes
             * @description Additional information to the data in each section.
             */
            notes?: string;
            /**
             * Number of sampled individuals
             * @description For garden accessions/seed bank, number of individuals from which seeds were collected
             */
            numberOfSampledIndividuals?: string;
            /** Observation days */
            observationDays?: number;
            /** Observation minutes */
            observationMinutes?: number;
            /**
             * % of plant population giving seeds
             * @description For garden accessions/seed bank, what proportion of the population sampled was giving seeds
             */
            percentageGivingSeeds?: number;
            /**
             * Predominant tree
             * @enum {string}
             */
            predominantTree?: "" | "MX.37819" | "MX.37812" | "MX.37992" | "MX.38004" | "MX.38590" | "MX.38686" | "MX.38563" | "MX.38527" | "MX.41344" | "MX.38016" | "MX.39331" | "MX.37990" | "MX.38008" | "MX.38010" | "MX.37975" | "MX.37976" | "MX.39122" | "MX.37815";
            /** projectTitle */
            projectTitle?: string;
            /** province */
            province?: string;
            /**
             * Relative humidity
             * @description Relative humidity %
             */
            relativeHumidity?: number;
            /**
             * Size of sampling area (m2)
             * @description For garden accessions/seed bank, estimated size of the area sampled, in square meters
             */
            samplingAreaSizeInSquareMeters?: number;
            /**
             * Sampling method
             * @description Main method for (usually intentional) sampling
             * @enum {string}
             */
            samplingMethod?: "" | "MY.samplingMethodCarnet" | "MY.samplingMethodFeromonetrap" | "MY.samplingMethodNet" | "MY.samplingMethodDrag" | "MY.samplingMethodWindowtrap" | "MY.samplingMethodDigging" | "MY.samplingMethodFishNet" | "MY.samplingMethodHand" | "MY.samplingMethodReared" | "MY.samplingMethodEpupa" | "MY.samplingMethodExovo" | "MY.samplingMethodElarva" | "MY.samplingMethodFishTrap" | "MY.samplingMethodYellowWindowTrap" | "MY.samplingMethodYellowpan" | "MY.samplingMethodTriangleDrag" | "MY.samplingMethodPitfall" | "MY.samplingMethodEclectortrap" | "MY.samplingMethodDungTrap" | "MY.samplingMethodBoard" | "MY.samplingMethodYellowtrap" | "MY.samplingMethodMistnet" | "MY.samplingMethodSweeping" | "MY.samplingMethodSoilsample" | "MY.samplingMethodWashing" | "MY.samplingMethodMalaise" | "MY.samplingMethodPantrap" | "MY.samplingMethodSeine" | "MY.samplingMethodAngleFishing" | "MY.samplingMethodTrampling" | "MY.samplingMethodBeamTrawl" | "MY.samplingMethodTrap" | "MY.samplingMethodDropping" | "MY.samplingMethodTrunkWindowTrap" | "MY.samplingMethodElectrofishing" | "MY.samplingMethodSifting" | "MY.samplingMethodDiverInsectTrap" | "MY.samplingMethodDiving" | "MY.samplingMethodBait" | "MY.samplingMethodBaittrap" | "MY.samplingMethodTrawling" | "MY.samplingMethodLight" | "MY.samplingMethodLightTrap" | "MY.samplingMethodWaterBucket" | "MY.samplingMethodAquaticNet" | "MY.samplingMethodAquaticEmergenceTrap" | "MY.samplingMethodWaterSieve" | "MY.samplingMethodOther";
            /** Sampling method notes */
            samplingMethodNotes?: string;
            /** Section */
            section?: number;
            /** Skipped */
            skipped?: boolean;
            /** Spotting scope */
            spottingScopeUsed?: boolean;
            /**
             * Substrate
             * @description Type of substrate or name of substrate species.
             */
            substrate?: string;
            taxonCensus?: components["schemas"]["taxonCensus"][];
            /** Temperature in celsius */
            temperature?: number;
            /** End time */
            timeEnd?: string;
            /** Start time */
            timeStart?: string;
            /** Trap count */
            trapCount?: number;
            /** Weather */
            weather?: string;
            /** WGS84 Latitude */
            wgs84Latitude?: string;
            /** WGS84 Longitude */
            wgs84Longitude?: string;
            /** Images */
            images?: string[];
            /**
             * Publicity restrictions
             * @description PUBLIC: all data can be published; PROTECTED: exact locality is hidden (100*100km square); PRIVATE: most of the data is hidden. Empty value means same as public.
             * @enum {string}
             */
            publicityRestrictions?: "" | "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
            units?: components["schemas"]["unit"][];
        };
        unit: {
            /** Context for the Specimen */
            "@context"?: string;
            /** Id for the Specimen */
            id?: string;
            /** Type for the Specimen */
            "@type"?: string;
            /**
             * DBH in centimeters
             * @description Diameter at breast height, in centimeters
             */
            DBH?: string;
            /**
             * DNA sample location
             * @description Leave empty if no sample taken, or if the sample is recorded separately
             */
            DNASampleLocation?: string;
            /** Amount */
            abundanceString?: string;
            /**
             * Abundance unit
             * @enum {string}
             */
            abundanceUnit?: "" | "MY.abundanceUnitIndividualCount" | "MY.abundanceUnitPairCount" | "MY.abundanceUnitNest" | "MY.abundanceUnitBreedingSite" | "MY.abundanceUnitFeedingSite" | "MY.abundanceUnitColony" | "MY.abundanceUnitFruitbody" | "MY.abundanceUnitSprout" | "MY.abundanceUnitHummock" | "MY.abundanceUnitThallus" | "MY.abundanceUnitFlower" | "MY.abundanceUnitSpot" | "MY.abundanceUnitTrunk" | "MY.abundanceUnitQueen" | "MY.abundanceUnitShell" | "MY.abundanceUnitDroppings" | "MY.abundanceUnitMarks" | "MY.abundanceUnitIndirect" | "MY.abundanceUnitSquareDM" | "MY.abundanceUnitSquareM" | "MY.abundanceUnitRelativeDensity" | "MY.abundanceUnitOccursDoesNotOccur";
            /**
             * Additional ID's
             * @description Other identifiers this specimen has, in format 'type:identifier'. For example: 'mzhtypes:123' (old MAZ-type number)
             */
            additionalIDs?: string[];
            /** Adult individual count */
            adultIndividualCount?: number;
            /**
             * Age
             * @description Estimated or known age in calendar years, years, days or other relevant unit.
             */
            age?: string;
            /**
             * Age notes
             * @description E.g. how age was determined, by whom and when.
             */
            ageNotes?: string;
            /** Alive */
            alive?: boolean;
            /** Ankle */
            ankleInMillimeters?: string[];
            /** Occurrence area (m) */
            areaInSquareMeters?: number;
            /**
             * Breeding index
             * @enum {string}
             */
            atlasCode?: "" | "MY.atlasCodeEnum1" | "MY.atlasCodeEnum2" | "MY.atlasCodeEnum3" | "MY.atlasCodeEnum4" | "MY.atlasCodeEnum5" | "MY.atlasCodeEnum6" | "MY.atlasCodeEnum61" | "MY.atlasCodeEnum62" | "MY.atlasCodeEnum63" | "MY.atlasCodeEnum64" | "MY.atlasCodeEnum65" | "MY.atlasCodeEnum66" | "MY.atlasCodeEnum7" | "MY.atlasCodeEnum71" | "MY.atlasCodeEnum72" | "MY.atlasCodeEnum73" | "MY.atlasCodeEnum74" | "MY.atlasCodeEnum75" | "MY.atlasCodeEnum8" | "MY.atlasCodeEnum81" | "MY.atlasCodeEnum82";
            /**
             * Bat behavior
             * @enum {string}
             */
            batBehavior?: "" | "MY.batBehaviorHibernating" | "MY.batBehaviorRoosting" | "MY.batBehaviorHunting";
            /** Beak */
            beakInMillimeters?: string[];
            /**
             * Bird age
             * @enum {string}
             */
            birdAge?: "" | "MY.birdAgePp" | "MY.birdAgePm" | "MY.birdAgeFl" | "MY.birdAgePlus1kv" | "MY.birdAge1Kv" | "MY.birdAgePlus2Kv" | "MY.birdAge2kv" | "MY.birdAgePlus3Kv" | "MY.birdAge3Kv" | "MY.birdAgePlus4Kv" | "MY.birdAge4Kv" | "MY.birdAgePlus5Kv" | "MY.birdAge5Kv" | "MY.birdAgePlus6Kv" | "MY.birdAge6Kv" | "MY.birdAgePlus7Kv" | "MY.birdAge7Kv" | "MY.birdAgePlus8Kv" | "MY.birdAge8Kv";
            /** Bird behavior */
            birdBehavior?: string[];
            /**
             * Bird plumage
             * @enum {string}
             */
            birdPlumage?: "" | "MY.birdPlumageAd" | "MY.birdPlumageEijp" | "MY.birdPlumageImm" | "MY.birdPlumageJp" | "MY.birdPlumageJuv" | "MY.birdPlumageNpuk" | "MY.birdPlumagePull" | "MY.birdPlumageSubad" | "MY.birdPlumageTp" | "MY.birdPlumageVp" | "MY.birdPlumagePep" | "MY.birdPlumageSs";
            /** Breeding */
            breeding?: boolean;
            /** Brood size */
            broodSize?: number;
            /**
             * Cause of Death
             * @description Cause of death, if not intentionally trapped on sampled
             */
            causeOfDeath?: string;
            /** Checklist */
            checklistID?: string;
            /**
             * Chemical properties
             * @description Results of chemical reaction tests etc.
             */
            chemistry?: string;
            /**
             * Count
             * @description Numeric or other description on the amount of individuals (or sprouts, fruiting bodies or such) in the specimen. Sexes and juveniles can be specified like so: 1m2f3j (=1 male, 2 females, 3 juveniles)
             */
            count?: string;
            /**
             * Decay stage
             * @description Estimation of decay stage (lahoaste in Finnish) on the scale of 1 to 5 and/or description
             */
            decayStage?: string;
            /**
             * Distance
             * @enum {string}
             */
            distance?: "" | "MY.distanceOverFlight" | "MY.distanceNear" | "MY.distanceQuiteFar" | "MY.distanceFar" | "MY.distanceVeryFar";
            /**
             * Earliest epoch or lowest series
             * @description For palaeontological specimens, earliest possible geochronologic epoch or lowest chronostratigraphic series attributable to the stratigraphic horizon from which the specimen was collected
             * @enum {string}
             */
            earliestEpochOrLowestSeries?: "" | "MY.epochOrSeriesCambrian" | "MY.epochOrSeriesCarboniferous" | "MY.epochOrSeriesCretaceous" | "MY.epochOrSeriesDevonian" | "MY.epochOrSeriesEdiacaran" | "MY.epochOrSeriesJurassic" | "MY.epochOrSeriesOrdovician" | "MY.epochOrSeriesPermian" | "MY.epochOrSeriesQuaternary" | "MY.epochOrSeriesRecent" | "MY.epochOrSeriesSilurian" | "MY.epochOrSeriesTertiary" | "MY.epochOrSeriesTriassic";
            /** Female individual count */
            femaleIndividualCount?: number;
            /**
             * Fruit type
             * @description Fruit type of the collected fruits, used for botanical garden accessions/seed bank.
             * @enum {string}
             */
            fruitType?: "" | "MY.fruitTypeAchene" | "MY.fruitTypeBerry" | "MY.fruitTypeCapsule" | "MY.fruitTypeCaryopsis" | "MY.fruitTypeCone" | "MY.fruitTypeDrupe" | "MY.fruitTypeFollicle" | "MY.fruitTypeLegume" | "MY.fruitTypeNut" | "MY.fruitTypeOther" | "MY.fruitTypePome" | "MY.fruitTypeSchizocarp" | "MY.fruitTypeSiliqua";
            /**
             * Genotype
             * @description Genotype of the microbial strain
             */
            genotype?: string;
            /** Gonad */
            gonadInMillimeters?: string[];
            /**
             * Growth medium name
             * @description Microbial culture growth medium name, usually from a standard
             */
            growthMediumName?: string;
            /**
             * Other conditions for growth
             * @description Other growth conditions for the microbial culture, light etc.
             */
            growthOtherConditions?: string;
            /**
             * Growth temperature
             * @description Microbial culture growth temperature
             */
            growthTemperature?: string;
            /** hasIdentification */
            hasIdentification?: string[];
            /** hasSubUnit */
            hasSubUnit?: string[];
            /** Host species */
            hostID?: string;
            /** Host species */
            hostInformalNameString?: string;
            /**
             * Tracks
             * @enum {string}
             */
            indirectObservationType?: "" | "MY.indirectObservationTypeFeces" | "MY.indirectObservationTypeSnowTracks" | "MY.indirectObservationTypeUrine" | "MY.indirectObservationTypeFeasting" | "MY.indirectObservationTypeFoodStock" | "MY.indirectObservationTypeNone";
            /** Individual count */
            individualCount?: number;
            /**
             * Infestation
             * @description Description of the infestation status of the collected seeds, used for botanical garden accessions/seed bank.
             */
            infestation?: string;
            /** Species */
            informalNameString?: string;
            /** Informal taxon group */
            informalTaxonGroup?: string;
            /**
             * Informal taxon groups
             * @description Valitut eliryhmt
             */
            informalTaxonGroups?: string[];
            /**
             * Infrasubspecific subdivision
             * @description Pathovars, serovars and other infrasubspecific subdivisions of microbes.
             */
            infrasubspecificSubdivision?: string;
            /**
             * Is part of
             * @description Which parent or larger collection this is part of.
             */
            isPartOf?: string;
            /** Juvenile individual count */
            juvenileIndividualCount?: number;
            /** Keywords */
            keywords?: string[];
            /** Larva count */
            larvaIndividualCount?: number;
            /**
             * Latest epoch or highest series
             * @description For palaeontological specimens, latest possible geochronologic epoch or highest chronostratigraphic series attributable to the stratigraphic horizon from which the specimen was collected.
             * @enum {string}
             */
            latestEpochOrHighestSeries?: "" | "MY.epochOrSeriesCambrian" | "MY.epochOrSeriesCarboniferous" | "MY.epochOrSeriesCretaceous" | "MY.epochOrSeriesDevonian" | "MY.epochOrSeriesEdiacaran" | "MY.epochOrSeriesJurassic" | "MY.epochOrSeriesOrdovician" | "MY.epochOrSeriesPermian" | "MY.epochOrSeriesQuaternary" | "MY.epochOrSeriesRecent" | "MY.epochOrSeriesSilurian" | "MY.epochOrSeriesTertiary" | "MY.epochOrSeriesTriassic";
            /** Length */
            lengthInMillimeters?: string[];
            /**
             * Life stage
             * @description Life stage of the specimen. If multiple present, select the one which was present at the time of collecting. Use Life stage description field for extra information.
             * @enum {string}
             */
            lifeStage?: "" | "MY.lifeStageAdult" | "MY.lifeStageNymph" | "MY.lifeStageLarva" | "MY.lifeStageEgg" | "MY.lifeStagePupa" | "MY.lifeStageJuvenile" | "MY.lifeStageSubimago" | "MY.lifeStageImmature" | "MY.lifeStageFertile" | "MY.lifeStageSterile" | "MY.lifeStageTadpole" | "MY.lifeStageEmbryo" | "MY.lifeStageSubadult" | "MY.lifeStageMature" | "MY.lifeStagePullus" | "MY.lifeStageHatchedEgg" | "MY.lifeStageHatchedPupa" | "MY.lifeStageGall" | "MY.lifeStageMarks" | "MY.lifeStageTriungulin";
            /**
             * Life stage description
             * @description Free-text notes or addtional information about the life stage. If multiple values present, describe them here.
             */
            lifeStageDescription?: string;
            /** Likely migrant (doesn't breed) */
            likelyMigrant?: boolean;
            /**
             * Macroscopic characters
             * @description Macroscopic features and measurements, if not recorded separately into measurement fields.
             */
            macroscopy?: string;
            /** Male individual count */
            maleIndividualCount?: number;
            measurement?: components["schemas"]["measurement"];
            /**
             * Risk group
             * @description According to German TRBA August 2015, which is more comprehensive than the EU or Finnish list for bacterial risk groups
             * @enum {string}
             */
            microbiologicalRiskGroup?: "" | "MY.microbiologicalRiskGroup1" | "MY.microbiologicalRiskGroup2" | "MY.microbiologicalRiskGroup3" | "MY.microbiologicalRiskGroup4";
            /**
             * Microscopic characters
             * @description Microscopic features and measurements, if not recorded separately into measurement fields.
             */
            microscopy?: string;
            /**
             * Moving direction
             * @enum {string}
             */
            movingDirection?: "" | "MY.movingDirectionN" | "MY.movingDirectionNNE" | "MY.movingDirectionNE" | "MY.movingDirectionENE" | "MY.movingDirectionE" | "MY.movingDirectionESE" | "MY.movingDirectionSE" | "MY.movingDirectionSSE" | "MY.movingDirectionS" | "MY.movingDirectionSSW" | "MY.movingDirectionSW" | "MY.movingDirectionWSW" | "MY.movingDirectionW" | "MY.movingDirectionWNW" | "MY.movingDirectionNW" | "MY.movingDirectionNNW";
            /** Moving status */
            movingStatus?: string[];
            /**
             * Mutant
             * @description Information on mutant microbial strain.
             */
            mutant?: string;
            /**
             * Native status
             * @enum {string}
             */
            nativeStatus?: "" | "MY.native" | "MY.nonNative";
            /** Nest/cavity count */
            nestCount?: number;
            /** Nest notes */
            nestNotes?: string;
            /** Diameter of the tree (cm) */
            nestTreeDiameterInCentimeters?: number;
            /**
             * Nest type
             * @enum {string}
             */
            nestType?: "" | "MY.nestTypeTreeCavity" | "MY.nestTypeTwig" | "MY.nestTypeNestBox" | "MY.nestTypeBuilding" | "MY.nestTypeGroundCavity" | "MY.nestTypeOther";
            /**
             * Notes
             * @description Additional information to the data in each section.
             */
            notes?: string;
            /** Pair count */
            pairCount?: number;
            /** Own interpretation/pairs */
            pairCountOpinion?: number;
            /**
             * Plant life stage
             * @enum {string}
             */
            plantLifeStage?: "" | "MY.plantLifeStageSterile" | "MY.plantLifeStageFertile" | "MY.plantLifeStageSeed" | "MY.plantLifeStageSprout" | "MY.plantLifeStageBud" | "MY.plantLifeStageFlower" | "MY.plantLifeStageWitheredFlower" | "MY.plantLifeStageRipeningFruit" | "MY.plantLifeStageRipeFruit" | "MY.plantLifeStageDeadSprout" | "MY.plantLifeStageSubterranean";
            /**
             * Plant status code
             * @description Status code for the plant (wild, alien etc.)
             * @enum {string}
             */
            plantStatusCode?: "" | "MY.plantStatusCodeL" | "MY.plantStatusCodeA" | "MY.plantStatusCodeAV" | "MY.plantStatusCodeAOV" | "MY.plantStatusCodeAN" | "MY.plantStatusCodeANV" | "MY.plantStatusCodeANS" | "MY.plantStatusCodeT" | "MY.plantStatusCodeTV" | "MY.plantStatusCodeTOV" | "MY.plantStatusCodeTNV" | "MY.plantStatusCodeTNS" | "MY.plantStatusCodeV" | "MY.plantStatusCodeOV" | "MY.plantStatusCodeN" | "MY.plantStatusCodeNV" | "MY.plantStatusCodeNS" | "MY.plantStatusCodeE" | "MY.plantStatusCodeTE" | "MY.plantStatusCodeTVE" | "MY.plantStatusCodeTOVE" | "MY.plantStatusCodeTNVE" | "MY.plantStatusCodeTNSE" | "MY.plantStatusCodeTN" | "MY.plantStatusCodeTNE" | "MY.plantStatusCodeR" | "MY.plantStatusCodeC" | "MY.plantStatusCodeH" | "MY.plantStatusCodeG" | "MY.plantStatusCodeF";
            /**
             * Abundance in the field
             * @description Abundance of the taxon in the field
             */
            populationAbundance?: string;
            /**
             * Preparations
             * @description Preparations/preparates made from the specimen, if not recorded as separate Preparations/samples in the designated section
             */
            preparations?: string;
            /**
             * Preservation
             * @description Main method of preservation. If parts of the specimen are preserved in different ways, you can choose several methods.
             */
            preservation?: ("" | "MY.preservationPressed" | "MY.preservationDry" | "MY.preservationCriticalPointDrying" | "MY.preservationPinned" | "MY.preservationGlued" | "MY.preservationLiquid" | "MY.preservationEthanol" | "MY.preservationEthanolPure" | "MY.preservationEthanol70" | "MY.preservationEthanol80" | "MY.preservationEthanol80Pure" | "MY.preservationEthanol96" | "MY.preservationEthanolMinus20C" | "MY.preservationEthanolDenatured" | "MY.preservationEthanolFormalin" | "MY.preservationEthanolExFormalin" | "MY.preservationFormalin" | "MY.preservationBouinSolution" | "MY.preservationPampelsFluid" | "MY.preservationGlycerol" | "MY.preservationParaffin" | "MY.preservationMercuricChloride" | "MY.preservationCryopreserved" | "MY.preservationFrozen" | "MY.preservationFrozenMinus80C" | "MY.preservationFreezeDried" | "MY.preservationGoldPlated" | "MY.preservationActiveCulture" | "MY.preservationLiving" | "MY.preservationSlide" | "MY.preservationSlideCanadaBalsam" | "MY.preservationSlideEuparal" | "MY.preservationSlidePolyviol" | "MY.preservationStuffed" | "MY.preservationCast" | "MY.preservationPlastinated" | "MY.preservationFrozenMinus80CAndEthanolMinus20C")[];
            /**
             * Primary specimen
             * @description Can be used to highlight one unit as primary specimen/observation if there are many in one document. Only one unit per document can be marked as primary.
             */
            primarySpecimen?: boolean;
            /**
             * Provenance
             * @description Origin or source of the garden accession
             * @enum {string}
             */
            provenance?: "" | "MY.provenanceUnknown" | "MY.provenanceCultivated" | "MY.provenanceCultivatedUnsure" | "MY.provenanceCultivatedPropagatedFromWildSource" | "MY.provenanceWildSource" | "MY.provenanceWildSourceUnsure" | "MY.provenanceEscapedCultivated" | "MY.provenancePropagule";
            /**
             * Record type
             * @description Type of record, most commonly preserved specimen for museum specimens and observation for associated observations ("seuralaislajihavainto").
             * @enum {string}
             */
            recordBasis?: "" | "MY.recordBasisPreservedSpecimen" | "MY.recordBasisHumanObservation" | "MY.recordBasisHumanObservationSeen" | "MY.recordBasisHumanObservationHeard" | "MY.recordBasisHumanObservationHandled" | "MY.recordBasisHumanObservationPhoto" | "MY.recordBasisHumanObservationAudio" | "MY.recordBasisHumanObservationVideo" | "MY.recordBasisHumanObservationIndirect" | "MY.recordBasisMachineObservation" | "MY.recordBasisMachineObservationPhoto" | "MY.recordBasisMachineObservationVideo" | "MY.recordBasisMachineObservationAudio" | "MY.recordBasisMachineObservationGeologger" | "MY.recordBasisMachineObservationSatelliteTransmitter" | "MY.recordBasisFossilSpecimen" | "MY.recordBasisSubfossilSpecimen" | "MY.recordBasisSubfossilSpecimenAmberInclusion" | "MY.recordBasisMaterialSample" | "MY.recordBasisMaterialSampleAir" | "MY.recordBasisMaterialSampleSoil" | "MY.recordBasisMaterialSampleWater" | "MY.recordBasisMicrobialSpecimen" | "MY.recordBasisLivingSpecimen" | "MY.recordBasisLiterature";
            /**
             * Record parts
             * @description What parts of the record are / have been in storage.
             */
            recordParts?: ("" | "MY.recordPartsBones" | "MY.recordPartsAntler" | "MY.recordPartsHead" | "MY.recordPartsSkull" | "MY.recordPartsSkin" | "MY.recordPartsWing" | "MY.recordPartsTail" | "MY.recordPartsTissue" | "MY.recordPartsFeather" | "MY.recordPartsEgg" | "MY.recordPartsIntestine" | "MY.recordPartsGonad" | "MY.recordPartsSeed" | "MY.recordPartsNest" | "MY.recordPartsFaeces" | "MY.recordPartsFeedingMarks" | "MY.recordPartsTracks" | "MY.recordPartsScale" | "MY.recordPartsFin" | "MY.recordPartsFull" | "MY.recordPartsPart" | "MY.recordPartsActiveCulture" | "MY.recordPartsCutting" | "MY.recordPartsVegetativePart" | "MY.recordPartsFreezeDried" | "MY.recordPartsDryIce" | "MY.recordPartsDNA" | "MY.recordPartsShell" | "MY.recordPartsWholePlant" | "MY.recordPartsTissueCulture" | "MY.recordPartsMount" | "My.recordPartsSkullAndBones")[];
            /**
             * Ring
             * @description Bird or bat ring number, code, colour code or such
             */
            ring?: string;
            /**
             * Sampling method
             * @description Main method for (usually intentional) sampling
             * @enum {string}
             */
            samplingMethod?: "" | "MY.samplingMethodCarnet" | "MY.samplingMethodFeromonetrap" | "MY.samplingMethodNet" | "MY.samplingMethodDrag" | "MY.samplingMethodWindowtrap" | "MY.samplingMethodDigging" | "MY.samplingMethodFishNet" | "MY.samplingMethodHand" | "MY.samplingMethodReared" | "MY.samplingMethodEpupa" | "MY.samplingMethodExovo" | "MY.samplingMethodElarva" | "MY.samplingMethodFishTrap" | "MY.samplingMethodYellowWindowTrap" | "MY.samplingMethodYellowpan" | "MY.samplingMethodTriangleDrag" | "MY.samplingMethodPitfall" | "MY.samplingMethodEclectortrap" | "MY.samplingMethodDungTrap" | "MY.samplingMethodBoard" | "MY.samplingMethodYellowtrap" | "MY.samplingMethodMistnet" | "MY.samplingMethodSweeping" | "MY.samplingMethodSoilsample" | "MY.samplingMethodWashing" | "MY.samplingMethodMalaise" | "MY.samplingMethodPantrap" | "MY.samplingMethodSeine" | "MY.samplingMethodAngleFishing" | "MY.samplingMethodTrampling" | "MY.samplingMethodBeamTrawl" | "MY.samplingMethodTrap" | "MY.samplingMethodDropping" | "MY.samplingMethodTrunkWindowTrap" | "MY.samplingMethodElectrofishing" | "MY.samplingMethodSifting" | "MY.samplingMethodDiverInsectTrap" | "MY.samplingMethodDiving" | "MY.samplingMethodBait" | "MY.samplingMethodBaittrap" | "MY.samplingMethodTrawling" | "MY.samplingMethodLight" | "MY.samplingMethodLightTrap" | "MY.samplingMethodWaterBucket" | "MY.samplingMethodAquaticNet" | "MY.samplingMethodAquaticEmergenceTrap" | "MY.samplingMethodWaterSieve" | "MY.samplingMethodOther";
            /** Sampling method notes */
            samplingMethodNotes?: string;
            /**
             * Seed maturity
             * @description Maturity of the collected seeds, used for botanical garden accessions/seed bank.
             * @enum {string}
             */
            seedMaturity?: "" | "MY.seedMaturityImmature" | "MY.seedMaturityMature" | "MY.seedMaturityMixed";
            /**
             * Seed morphology
             * @description Seed morphology of the collected seeds, used for botanical garden accessions/seed bank.
             * @enum {string}
             */
            seedMorphology?: "" | "MY.seedMorphologyBent" | "MY.seedMorphologyBroad" | "MY.seedMorphologyCapitate" | "MY.seedMorphologyFolded" | "MY.seedMorphologyLateral" | "MY.seedMorphologyLinearFullyDeveloped" | "MY.seedMorphologyLinearUnderdeveloped" | "MY.seedMorphologyPeripheral" | "MY.seedMorphologyRudimentary" | "MY.seedMorphologySpatulateFullyDeveloped" | "MY.seedMorphologySpatulateUnderdeveloped" | "MY.seedMorphologyUndifferentiated" | "MY.seedMorphologyInvesting";
            /**
             * Sex
             * @description Sex of the individual(s)
             * @enum {string}
             */
            sex?: "" | "MY.sexM" | "MY.sexF" | "MY.sexW" | "MY.sexU" | "MY.sexN" | "MY.sexX" | "MY.sexE" | "MY.sexC";
            /**
             * Sex notes
             * @description E.g. how sex was determined, by whom and when.
             */
            sexNotes?: string;
            /** Shorthand */
            shortHandText?: string;
            /**
             * Smell
             * @enum {string}
             */
            smell?: "" | "MY.smellNotSmelled" | "MY.smellNoSmelled" | "MY.smellWeak" | "MY.smellModerate" | "MY.smellStrong";
            /** Smell notes */
            smellNotes?: string;
            /** Verbatim stratigraphy from original source */
            stratigraphyVerbatim?: string;
            /**
             * Type of substrate
             * @enum {string}
             */
            substrateClassification?: "" | "MY.substrateGround" | "MY.substrateGroundLowShrubs" | "MY.substrateGroundLichens" | "MY.substrateGroundHerbs" | "MY.substrateGroundMosses" | "MY.substrateGroundSphagnum" | "MY.substrateGroundGrassy" | "MY.substrateGroundNeedleLitter" | "MY.substrateGroundLeafLitter" | "MY.substrateGroundMixedLitter" | "MY.substrateGroundSandySoil" | "MY.substrateGroundGravelSoil" | "MY.substrateGroundClayeySoil" | "MY.substrateGroundHeathHumus" | "MY.substrateGroundMull" | "MY.substrateGroundPeat" | "MY.substrateGroundBurnedSoil" | "MY.substrateLivingTree" | "MY.substrateLivingTreeTrunk" | "MY.substrateLivingTreeBase" | "MY.substrateLivingTreeRoots" | "MY.substrateLivingTreeBranch" | "MY.substrateLivingTreeDeadBranch" | "MY.substrateLivingTreeDeadLimb" | "MY.substrateLivingTreeLeaf" | "MY.substrateLivingTreeNeedle" | "MY.substrateDeadWood" | "MY.substrateDeadWoodStandingTreeTrunk" | "MY.substrateDeadWoodStandingTreeBranch" | "MY.substrateDeadWoodStandingTreeBase" | "MY.substrateDeadWoodFallenTreeTrunk" | "MY.substrateDeadWoodFallenTreeBranch" | "MY.substrateDeadWoodUpturnedRoots" | "MY.substrateDeadWoodDeadRoots" | "MY.substrateDeadWoodStump" | "MY.substrateDeadWoodFallenBranch" | "MY.substrateDeadWoodCone" | "MY.substrateDeadWoodTwigs" | "MY.substrateDeadWoodBark" | "MY.substrateDeadWoodSawdust" | "MY.substrateDeadWoodPieceOfWood" | "MY.substrateDeadWoodLoggingResidue" | "MY.substrateDeadWoodLog" | "MY.substrateDeadWoodDriftwood" | "MY.substrateDeadWoodConstructionWood" | "MY.substrateDung" | "MY.substrateCompost" | "MY.substrateLivingShoot" | "MY.substrateDeadShoot" | "MY.substrateLivingFungus" | "MY.substrateDeadFungus" | "MY.substrateLivingAnimal" | "MY.substrateDeadAnimal" | "MY.substrateRockSurface" | "MY.substrateDeadNeedle" | "MY.substrateDeadLeaf";
            /**
             * Woody substrate, decay stage
             * @enum {string}
             */
            substrateDecayStage?: "" | "MY.substrateDecayStageEnum1" | "MY.substrateDecayStageEnum2" | "MY.substrateDecayStageEnum3" | "MY.substrateDecayStageEnum4" | "MY.substrateDecayStageEnum5";
            /** Substrate notes */
            substrateNotes?: string;
            /** Substrate species */
            substrateSpecies?: string;
            /** Substrate species */
            substrateSpeciesID?: string;
            /** Substrate species */
            substrateSpeciesInformalNameString?: string;
            /** Woody substrate, additional information */
            substrateTreeClassification?: ("" | "MY.substrateTreeClassificationEnum1" | "MY.substrateTreeClassificationEnum2" | "MY.substrateTreeClassificationEnum3" | "MY.substrateTreeClassificationEnum4" | "MY.substrateTreeClassificationEnum5" | "MY.substrateTreeClassificationEnum6")[];
            /** Tail */
            tailInMillimeters?: string[];
            /**
             * Taste
             * @enum {string}
             */
            taste?: "" | "MY.tasteNotTasted" | "MY.tasteNoTaste" | "MY.tasteWeak" | "MY.tasteModerate" | "MY.tasteStrong";
            /** Taste notes */
            tasteNotes?: string;
            /**
             * Confidence of determination
             * @enum {string}
             */
            taxonConfidence?: "" | "MY.taxonConfidenceSure" | "MY.taxonConfidenceUnsure" | "MY.taxonConfidenceSubspeciesUnsure";
            /** Twitched */
            twitched?: boolean;
            unitFact?: components["schemas"]["unitFact"];
            unitGathering?: components["schemas"]["unitGathering"];
            /** Specimen type */
            unitType?: string[];
            /** Weight */
            weightInGrams?: string[];
            /**
             * Native status
             * @enum {string}
             */
            wild?: "" | "MY.wildWild" | "MY.wildUnknown" | "MY.wildNonWild";
            /** Wing length (mm) */
            wingInMillimeters?: string[];
            /** Recordings */
            audio?: string[];
            /** Images */
            images?: string[];
            /**
             * Publicity restrictions
             * @description PUBLIC: all data can be published; PROTECTED: exact locality is hidden (100*100km square); PRIVATE: most of the data is hidden. Empty value means same as public.
             * @enum {string}
             */
            publicityRestrictions?: "" | "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
            identifications?: components["schemas"]["identification"][];
            typeSpecimens?: components["schemas"]["typeSpecimen"][];
        };
        measurement: {
            /** Context for the MY.measurementClass */
            "@context"?: string;
            /** Id for the MY.measurementClass */
            id?: string;
            /** Type for the MY.measurementClass */
            "@type"?: string;
            /** DNA concentration (ng/microliter) */
            DNAConcentrationNgPerMicroliter?: number[];
            /** DNA purity (ratio of absorbance 260/280 nm) */
            DNARatioOfAbsorbance260And280?: number[];
            /** DNA volume (microliters) */
            DNAVolumeMicroliters?: number[];
            /** Beak (mm) */
            beakMillimeters?: number[];
            /** Body (cm) */
            bodyCentimeters?: number[];
            /** Body (mm) */
            bodyMillimeters?: number[];
            /** Ear length (mm) */
            earLengthMillimeters?: number[];
            /** Embryo count */
            embryoCount?: number[];
            /** Follicle diameter (mm) */
            follicleDiameterMillimeters?: number[];
            /** Foot length (mm) */
            footLengthMillimeters?: number[];
            /** Forearm (mm) */
            forearmMillimeters?: number[];
            /** Gonad (mm) */
            gonadMillimeters?: number[];
            /**
             * Is part of
             * @description Which parent or larger collection this is part of.
             */
            isPartOf?: string;
            /** Tail (cm) */
            tailCentimeters?: number[];
            /** Tail (mm) */
            tailMillimeters?: number[];
            /** Tarsus length (mm) */
            tarsusLengthMillimeters?: number[];
            /** Length (cm) */
            totalLengthCentimeters?: number[];
            /** Length (mm) */
            totalLengthMillimeters?: number[];
            /** Uterine scar count */
            uterineScarCount?: number[];
            /** Weight (g) */
            weightGrams?: number[];
            /** Weight (kg) */
            weightKilograms?: number[];
            /** Wing max (mm) */
            wingMaxMillimeters?: number[];
            /** Wing (mm) */
            wingMillimeters?: number[];
            /** Wing min (mm) */
            wingMinMillimeters?: number[];
        };
        unitFact: {
            /** Context for the Nytteen / havainnon faktat */
            "@context"?: string;
            /** Id for the Nytteen / havainnon faktat */
            id?: string;
            /** Type for the Nytteen / havainnon faktat */
            "@type"?: string;
            /** Adult individual count */
            adultIndividualCount?: number;
            /** Taxon ID selected from autocomplete */
            autocompleteSelectedTaxonID?: string;
            /**
             * Micro habitat
             * @enum {string}
             */
            glowWormMicrohabitat?: "" | "MY.glowWormMicrohabitatEnum1" | "MY.glowWormMicrohabitatEnum2" | "MY.glowWormMicrohabitatEnum3" | "MY.glowWormMicrohabitatEnum4" | "MY.glowWormMicrohabitatEnum5" | "MY.glowWormMicrohabitatEnum6" | "MY.glowWormMicrohabitatEnumOther";
            /** Parven koko */
            individualCountFlock?: number;
            /** Yksilmr sisll */
            individualCountInner?: number;
            /** Yksilmr alueen ulkopuolella */
            individualCountOuter?: number;
            /** Juvenile individual count */
            juvenileIndividualCount?: number;
            /**
             * Observations quality
             * @enum {string}
             */
            lineTransectObsType?: "" | "MY.lineTransectObsTypeSong" | "MY.lineTransectObsTypeOtherSound" | "MY.lineTransectObsTypeSeen" | "MY.lineTransectObsTypeSeenMale" | "MY.lineTransectObsTypeSeenFemale" | "MY.lineTransectObsTypeFlyingOverhead" | "MY.lineTransectObsTypeFlock" | "MY.lineTransectObsTypeFlockFlyingOverhead" | "MY.lineTransectObsTypeSeenPair" | "MY.lineTransectObsTypeSeenBrood" | "MY.lineTransectObsTypeSeenNest" | "MY.lineTransectObsTypeUnknown";
            /**
             * Field Area
             * @enum {string}
             */
            lineTransectRouteFieldType?: "" | "MY.lineTransectRouteFieldTypeInner" | "MY.lineTransectRouteFieldTypeOuter";
            /**
             * Droppings count
             * @enum {string}
             */
            lolifeDroppingsCount?: "" | "MY.lolifeDroppingsCount0" | "MY.lolifeDroppingsCount1" | "MY.lolifeDroppingsCount2" | "MY.lolifeDroppingsCount25" | "MY.lolifeDroppingsCount3" | "MY.lolifeDroppingsCount4";
            /**
             * Papanoiden laatu
             * @enum {string}
             */
            lolifeDroppingsQuality?: "" | "MY.lolifeDroppingsQuality1" | "MY.lolifeDroppingsQuality2";
            /**
             * Droppings type
             * @enum {string}
             */
            lolifeDroppingsType?: "" | "MY.lolifeDroppingsTypeRock" | "MY.lolifeDroppingsTypeTree" | "MY.lolifeDroppingsTypeTreeGroup" | "MY.lolifeDroppingsTypeOther";
            /**
             * Tree species
             * @enum {string}
             */
            lolifeNestTree?: "" | "MX.38590" | "MX.37812" | "MX.37999" | "MX.37993" | "MX.38010" | "MX.38008" | "MY.lolifeNestTreeOther";
            /** Parimr sisll */
            pairCountInner?: number;
            /** Parimr alueen ulkopuolella */
            pairCountOuter?: number;
            /** Parvien koot */
            pointCountFlock?: string;
            /** Is the plant growing next to running water? */
            runningWaterInVicinity?: boolean;
            /**
             * Female observed
             * @enum {string}
             */
            waterbirdFemale?: "" | "MY.waterbirdFemaleEnumYes" | "MY.waterbirdFemaleEnumNo" | "MY.waterbirdFemaleEnumLonelyPanicking";
            /**
             * Juvenile age class
             * @enum {string}
             */
            waterbirdJuvenileAgeClass?: "" | "MY.waterbirdJuvenileAgeClassIa" | "MY.waterbirdJuvenileAgeClassIb" | "MY.waterbirdJuvenileAgeClassIc" | "MY.waterbirdJuvenileAgeClassIIa" | "MY.waterbirdJuvenileAgeClassIIb" | "MY.waterbirdJuvenileAgeClassIIc" | "MY.waterbirdJuvenileAgeClassIIIa" | "MY.waterbirdJuvenileAgeClassUnknown";
            /** Count accurate? */
            waterbirdJuvenileCountAccurate?: boolean;
            /** Make an interpretation based on this census */
            waterbirdObserverOpinionSelectedCensus?: boolean;
            /**
             * Reasoning for own interpretation
             * @enum {string}
             */
            waterbirdPairCountOpinionReasoning?: "" | "MY.waterbirdPairCountOpinionReasoningEnum1" | "MY.waterbirdPairCountOpinionReasoningEnum2" | "MY.waterbirdPairCountOpinionReasoningEnum3" | "MY.waterbirdPairCountOpinionReasoningEnumOther";
            /** Individual count dump */
            individualCountBiotopeA?: number;
            /** Individual count urban */
            individualCountBiotopeB?: number;
            /** Individual count countryside */
            individualCountBiotopeC?: number;
            /** Individual count field */
            individualCountBiotopeD?: number;
            /** Individual count forest */
            individualCountBiotopeE?: number;
            /** Individual count other biotope */
            individualCountBiotopeF?: number;
            /** Individual count cutting open */
            individualCountBiotopeG?: number;
            /** Individual count reed */
            individualCountBiotopeH?: number;
        };
        unitGathering: {
            /** Context for the Havainnon keruutiedot */
            "@context"?: string;
            /** Id for the Havainnon keruutiedot */
            id?: string;
            /** Type for the Havainnon keruutiedot */
            "@type"?: string;
            /** Start date */
            dateBegin?: string;
            /** End date */
            dateEnd?: string;
            geometry?: components["schemas"]["geometry"];
            /**
             * Habitat description
             * @description Informal description of the habitat.
             */
            habitatDescription?: string;
            /** Habitat */
            habitatIUCN?: string;
            /**
             * Substrate
             * @description Type of substrate or name of substrate species.
             */
            substrate?: string;
        };
        identification: {
            /** Context for the Identification */
            "@context"?: string;
            /** Id for the Identification */
            id?: string;
            /** Type for the Identification */
            "@type"?: string;
            /** herbo:sortOrder */
            "herbo:sortOrder"?: number;
            /**
             * Associated observation taxa
             * @description Write associated observation taxa names here, separated by a semicolon (;). E.g.: "Betula pendula; Betula pubescens; Poaceae". These will form their own units of the type observation.
             */
            associatedObservationTaxa?: string;
            /**
             * Taxon author
             * @description Author for the taxon
             */
            author?: string;
            /**
             * Det.
             * @description Name of the identifier (person) preferably in format "lastname, firstname"
             */
            det?: string;
            /**
             * Det. date
             * @description Date or year when the identification was done, preferably in format "d.m.Y" or "Y"
             */
            detDate?: string;
            /**
             * Det method
             * @enum {string}
             */
            detMethod?: "" | "MY.detMethodFreshSample" | "MY.detMethodMicroscopy" | "MY.detMethodPhoto";
            /**
             * Det verbatim from the label or other original source
             * @description Name of the identifier and date of identification in original format (e.g. from the label), errors and all
             */
            detVerbatim?: string;
            /**
             * Genus qualifier
             * @description Additional qualifier or specifier at genus level (e.g. aff., cf.)
             */
            genusQualifier?: string;
            /** Identification basis */
            identificationBasis?: ("" | "MY.identificationBasisDNA" | "MY.identificationBasisGenitals" | "MY.identificationBasisGenitalPreparate" | "MY.identificationBasisSpores" | "MY.identificationBasisHandled" | "MY.identificationBasisChemical" | "MY.identificationBasisHeard" | "MY.identificationBasisMicroscope" | "MY.identificationBasisSeen" | "MY.identificationBasisPreservedSpecimen" | "MY.identificationBasisFreshSpecimen" | "MY.identificationBasisMedia")[];
            /**
             * Identification notes
             * @description Additional information on the identification, basis or such
             */
            identificationNotes?: string;
            /**
             * Infra author
             * @description Author for the taxon below species level/infra epithet
             */
            infraAuthor?: string;
            /**
             * Infra name
             * @description Taxon name for the epithet below species level
             */
            infraEpithet?: string;
            /**
             * Infra rank
             * @description Taxonomic level of the epithet below species level
             * @enum {string}
             */
            infraRank?: "" | "MY.infraRankSsp" | "MY.infraRankVar" | "MY.infraRankBeta" | "MY.infraRankB" | "MY.infraRankForma" | "MY.infraRankHybrid" | "MY.infraRankAnamorph" | "MY.infraRankAggregate" | "MY.infraRankAberration" | "MY.infraRankCultivar" | "MY.infraRankMorpha" | "MY.infraRankUnknown" | "MY.infraRankNothosubspecies" | "MY.infraRankCultivarGroup" | "MY.infraRankFsp";
            /**
             * Infrasubspecific subdivision
             * @description Pathovars, serovars and other infrasubspecific subdivisions of microbes.
             */
            infrasubspecificSubdivision?: string;
            /**
             * Is part of
             * @description Which parent or larger collection this is part of.
             */
            isPartOf?: string;
            /** Is taxon group */
            isTaxonGroup?: boolean;
            /**
             * Preferred identification
             * @description This can be used to select one of the identifications as 'recommended', which is the used as default when displaying information about the specimen.
             */
            preferredIdentification?: string;
            /**
             * Taxon concept (sec)
             * @description Publication reference for the taxon concept, that was used in identification
             */
            sec?: string;
            /**
             * Species qualifier
             * @description Additional qualifier at species level (e.g. aff., cf., sp. n., coll.)
             */
            speciesQualifier?: string;
            /**
             * Species
             * @description Taxon name
             */
            taxon?: string;
            /**
             * Taxon alternative ID
             * @description ID for the taxon if has some other than an MX code
             */
            taxonID?: string;
            /**
             * Taxon rank
             * @description Taxonomic level for the identification
             * @enum {string}
             */
            taxonRank?: "" | "MX.superdomain" | "MX.domain" | "MX.kingdom" | "MX.subkingdom" | "MX.infrakingdom" | "MX.superphylum" | "MX.phylum" | "MX.subphylum" | "MX.infraphylum" | "MX.superdivision" | "MX.division" | "MX.subdivision" | "MX.infradivision" | "MX.superclass" | "MX.class" | "MX.subclass" | "MX.infraclass" | "MX.parvclass" | "MX.superorder" | "MX.order" | "MX.suborder" | "MX.infraorder" | "MX.parvorder" | "MX.superfamily" | "MX.family" | "MX.subfamily" | "MX.tribe" | "MX.subtribe" | "MX.supergenus" | "MX.genus" | "MX.nothogenus" | "MX.subgenus" | "MX.section" | "MX.subsection" | "MX.series" | "MX.subseries" | "MX.infragenericTaxon" | "MX.aggregate" | "MX.speciesAggregate" | "MX.species" | "MX.nothospecies" | "MX.infraspecificTaxon" | "MX.subspecificAggregate" | "MX.subspecies" | "MX.nothosubspecies" | "MX.variety" | "MX.subvariety" | "MX.form" | "MX.subform" | "MX.hybrid" | "MX.anamorph" | "MX.ecotype" | "MX.populationGroup" | "MX.intergenericHybrid" | "MX.infragenericHybrid" | "MX.cultivar" | "MX.group" | "MX.grex";
            /** Taxon specifier */
            taxonSpecifier?: string;
            /** Taxon URI */
            taxonURI?: string;
            /**
             * Taxon verbatim
             * @description Taxon name in original format (e.g. from the label), errors and all
             */
            taxonVerbatim?: string;
            /**
             * Publicity restrictions
             * @description PUBLIC: all data can be published; PROTECTED: exact locality is hidden (100*100km square); PRIVATE: most of the data is hidden. Empty value means same as public.
             * @enum {string}
             */
            publicityRestrictions?: "" | "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
            /** sortOrder */
            sortOrder?: number;
        };
        typeSpecimen: {
            /** Context for the Identification */
            "@context"?: string;
            /** Id for the Identification */
            id?: string;
            /** Type for the Identification */
            "@type"?: string;
            /**
             * Is part of
             * @description Which parent or larger collection this is part of.
             */
            isPartOf?: string;
            /**
             * Type author
             * @description Author of the type species
             */
            typeAuthor?: string;
            /**
             * Original description publication
             * @description Publication reference for original description or basionyme
             */
            typeBasionymePubl?: string;
            /**
             * Type notes
             * @description Additional information on the type
             */
            typeNotes?: string;
            /**
             * Type publication
             * @description Publication reference for type publication
             */
            typePubl?: string;
            /**
             * Type series ID
             * @description ID for the type series, if part of one
             */
            typeSeriesID?: string;
            /**
             * Type name
             * @description Name of the type species
             */
            typeSpecies?: string;
            /**
             * Type of type
             * @description Is this holotype, paratype, syntype etc...
             * @enum {string}
             */
            typeStatus?: "" | "MY.typeStatusType" | "MY.typeStatusHolotype" | "MY.typeStatusSyntype" | "MY.typeStatusParatype" | "MY.typeStatusLectotype" | "MY.typeStatusParalectotype" | "MY.typeStatusNeotype" | "MY.typeStatusAllotype" | "MY.typeStatusNeoallotype" | "MY.typeStatusIsotype" | "MY.typeStatusEpitype" | "MY.typeStatusIsolectotype" | "MY.typeStatusIsoepitype" | "MY.typeStatusIsoneotype" | "MY.typeStatusIsoparatype" | "MY.typeStatusIsosyntype" | "MY.typeStatusOriginalMaterial" | "MY.typeStatusCotype" | "MY.typeStatusTopotype" | "MY.typeStatusHomotype" | "MY.typeStatusNo" | "MY.typeStatusPossible" | "MY.typeStatusObscure" | "MY.typeStatusTypeStrain" | "MY.typeStatusPathovarReferenceStrain";
            /**
             * Type ssp name
             * @description Name of the type subspecies
             */
            typeSubspecies?: string;
            /**
             * Type ssp author
             * @description Author of the type subspecies
             */
            typeSubspeciesAuthor?: string;
            /**
             * Type verification
             * @description Verification whether this really is a type?
             * @enum {string}
             */
            typeVerification?: "" | "MY.typeVerificationVerified" | "MY.typeVerificationUnverified" | "MY.typeVerificationProbable" | "MY.typeVerificationDoubtful";
            /**
             * Typefier
             * @description Name of the person who chose the type, preferably in the format "Lastname, firstname"
             */
            typif?: string;
            /**
             * Typifier date
             * @description Date when the specimen was chosen as a type
             */
            typifDate?: string;
            /**
             * Publicity restrictions
             * @description PUBLIC: all data can be published; PROTECTED: exact locality is hidden (100*100km square); PRIVATE: most of the data is hidden. Empty value means same as public.
             * @enum {string}
             */
            publicityRestrictions?: "" | "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
        };
        formSeason: {
            /** Context for the MHL.formSeasonClass */
            "@context"?: string;
            /** Id for the MHL.formSeasonClass */
            id?: string;
            /** Type for the MHL.formSeasonClass */
            "@type"?: string;
            /**
             * end
             * @description End of season
             */
            end?: string;
            /**
             * Start
             * @description Start of season
             */
            start?: string;
        };
        notification: {
            /** Context for the MHN.notification */
            "@context"?: string;
            /** Id for the MHN.notification */
            id?: string;
            /** Type for the MHN.notification */
            "@type"?: string;
            annotation?: components["schemas"]["annotation"];
            /**
             * Created
             * Format: date-time
             */
            created: string;
            /** Friend request from */
            friendRequest?: string;
            /** Friend request accepted by */
            friendRequestAccepted?: string;
            /**
             * Notification reason
             * @enum {string}
             */
            notificationReason?: "" | "MHN.notificationReasonOwnDocumentAnnotated" | "MHN.notificationReasonAnnotatedDocumentAnnotated";
            /** Seen */
            seen?: boolean;
            /** Notification is for */
            toPerson: string;
        };
        annotation: {
            /** Context for the MAN.annotation */
            "@context"?: string;
            /** Id for the MAN.annotation */
            id?: string;
            /** Type for the MAN.annotation */
            "@type"?: string;
            /** Added tags */
            addedTags?: string[];
            /** Person Id */
            annotationByPerson?: string;
            /** System Id */
            annotationBySystem?: string;
            /**
             * My evaluation of the observation
             * @enum {string}
             */
            annotationClass?: "" | "MAN.annotationClassReliable" | "MAN.annotationClassLikely" | "MAN.annotationClassNeutral" | "MAN.annotationClassSuspicious" | "MAN.annotationClassUnreliable" | "MAN.annotationClassAcknowledged" | "MAN.annotationClassSpam";
            /**
             * Annotators role
             * @enum {string}
             */
            byRole?: "" | "MMAN.expert" | "MMAN.basic" | "MMAN.owner" | "MMAN.formAdmin" | "MMAN.ictAdmin";
            /** Census annotation */
            censusAnnotation?: ("" | "MAN.countError" | "MAN.innerCountError" | "MAN.otherError")[];
            /**
             * Creation time
             * Format: date-time
             */
            created?: string;
            /** Created timestamp */
            createdTimestamp?: number;
            /** Deleted timestamp */
            deletedTimestamp?: number;
            identification?: components["schemas"]["identification"];
            /**
             * Annotation type for invasive control
             * @enum {string}
             */
            invasiveControlEffectiveness?: "" | "MY.invasiveControlEffectivenessFull" | "MY.invasiveControlEffectivenessPartial" | "MY.invasiveControlEffectivenessNone" | "MY.invasiveControlEffectivenessNotFound";
            /** Line transect annotation */
            lineTransectAnnotation?: ("" | "MAN.birdCountError" | "MAN.innerCountError" | "MAN.otherError")[];
            /** Comment */
            notes?: string;
            occurrenceAtTimeOfAnnotation?: components["schemas"]["annotationOccurrence"];
            /** Suggested identification */
            opinion?: string;
            /** Removed tags */
            removedTags?: string[];
            /** Root ID */
            rootID: string;
            /** Target Id */
            targetID?: string;
            /**
             * My evaluation of the observation
             * @enum {string}
             */
            type?: "" | "MAN.typeOpinion" | "MAN.typeInvasiveControlEffectiveness" | "MAN.typeUnidentifiable" | "MAN.typeAdmin";
            /** Deleted by system */
            createdBySystem?: string;
            /** Soft delete */
            deleted?: boolean;
            /** Deleted by person */
            deletedByPerson?: string;
            /**
             * Deleted at
             * Format: date-time
             */
            deletedDateTime?: string;
        };
        annotationOccurrence: {
            /** Context for the MAN.annotationOccurrenceClass */
            "@context"?: string;
            /** Id for the MAN.annotationOccurrenceClass */
            id?: string;
            /** Type for the MAN.annotationOccurrenceClass */
            "@type"?: string;
            /** Country verbatim */
            countryVerbatim?: string;
            /** Date begin */
            dateBegin?: string;
            /** Date end */
            dateEnd?: string;
            /** Locality */
            locality?: string;
            /** Municipality verbatim */
            municipalityVerbatim?: string;
            /** Taxon ID */
            taxonId?: string;
            /** Taxon verbatim */
            taxonVerbatim?: string;
            /** Latitude (center point) */
            wgs84centerPointLat?: number;
            /** Longitude (center point) */
            wgs84centerPointLon?: number;
        };
        SensitivePerson: {
            id: string;
            fullName?: string;
            group?: string;
            "@context": string;
        };
        SensitiveProfile: {
            userID: string;
            profileDescription: string;
            image: string;
        };
        collection: {
            /** Context for the Collection */
            "@context"?: string;
            /** Id for the Collection */
            id?: string;
            /** Type for the Collection */
            "@type"?: string;
            /**
             * Secure level
             * @description Secure level (salaus-/karkeistustaso) for the data
             * @enum {string}
             */
            secureLevel?: "" | "MX.secureLevelNone" | "MX.secureLevelKM1" | "MX.secureLevelKM5" | "MX.secureLevelKM10" | "MX.secureLevelKM25" | "MX.secureLevelKM50" | "MX.secureLevelKM100" | "MX.secureLevelHighest" | "MX.secureLevelNoShow";
            /**
             * Unofficial abbreviation
             * @description Unofficial abbreviation (or acronym) for this collection
             */
            abbreviation?: string;
            /** Identifier of this dataset/collection in other databases */
            additionalIdentifier?: string[];
            /**
             * Allowed for DW statistics
             * @description Admin field. Is it allowed to use collection with data warehouse /statistic endpoints.
             */
            allowedForDwStatistics?: boolean;
            /** Bounding box latitude max (WGS84) */
            boundingBoxLatMax?: string;
            /** Bounding box latitude min (WGS84) */
            boundingBoxLatMin?: string;
            /** Bounding box longitude max (WGS84) */
            boundingBoxLonMax?: string;
            /** Bounding box longitude min (WGS84) */
            boundingBoxLonMin?: string;
            /**
             * Citation recommendation
             * @description Example how to cite this collection in a scientific article, if using organization, name and abbreviation is not enough.
             */
            citation?: string;
            /**
             * Specimen collection code
             * @description Collection code for natural history specimen collection, such as H-BR
             */
            collectionCode?: string;
            collectionLocation?: components["schemas"]["multiLang"];
            collectionName: components["schemas"]["multiLang"];
            /**
             * Collection quality
             * @description Quality classification for the collection.
             * @enum {string}
             */
            collectionQuality: "MY.collectionQualityEnum3" | "MY.collectionQualityEnum2" | "MY.collectionQualityEnum1";
            /**
             * Size (approx.)
             * @description How many specimens, records or such does the collection contain? Fill in approximate number, describe more in notes if necessary.
             */
            collectionSize?: string;
            /**
             * Type
             * @description Type of the collection (specimen, monitoring etc).
             * @enum {string}
             */
            collectionType: "MY.collectionTypeSpecimens" | "MY.collectionTypeLiving" | "MY.collectionTypeMonitoring" | "MY.collectionTypeObservations" | "MY.collectionTypePublicationdata" | "MY.collectionTypePublication" | "MY.collectionTypeMixed" | "MY.collectionTypeOther" | "MY.collectionTypeGardenArea" | "MY.collectionTypeIndoorGardenArea" | "MY.collectionTypeOutdoorGardenArea" | "MY.collectionTypeGardenSublocation" | "MY.collectionTypeTrait";
            concealmentBasis?: components["schemas"]["multiLang"];
            /**
             * Contact email
             * @description Personal or general (e.g. group of people in the organisation) email address to reach the person(s) responsible.
             */
            contactEmail: string;
            coverageBasis?: components["schemas"]["multiLang"];
            dataLocation?: components["schemas"]["multiLang"];
            /**
             * Notes about the data
             * @description Diary-like notes about the data, with date/time. For example "2020-08-19: Changed country names Fnland to Finland", or "Specimens collected during 2019 are missing coordinates due to malfunctioning GPS"
             */
            dataNotes?: string;
            /**
             * Data quality
             * @description Quality estimation for the data in this collection
             * @enum {string}
             */
            dataQuality?: "" | "MY.dataQuality1" | "MY.dataQuality2" | "MY.dataQuality3" | "MY.dataQuality4" | "MY.dataQuality5" | "MY.dataQualityNA";
            dataQualityDescription?: components["schemas"]["multiLang"];
            /**
             * Embargo in years
             * @description Embargo period in years after which data is opened
             */
            dataQuarantinePeriod?: number;
            dataUseTerms?: components["schemas"]["multiLang"];
            description: components["schemas"]["multiLang"];
            /**
             * % digitized (approx.)
             * @description How many percent of the collection is in digital form, e.g. in a database or Excel file? Fill in approximate number, describe more in notes if necessary.
             */
            digitizedSize?: string;
            /** DOI provided by FinBIF */
            doi?: string;
            /**
             * Download request handler
             * @description Admin field. The identifier of the person responsible for handling requests for restricted data for this set (typically same person who's responsible for the collection)
             */
            downloadRequestHandler?: string[];
            /**
             * Notes about this edit
             * @description Reason for this edit or notes about it.
             */
            editNotes?: string;
            /**
             * Collection DOI from GBIF
             * @description Admin field. DOI received from GBIF after the collection has been published.
             */
            gbifDoi?: string;
            geographicCoverage?: components["schemas"]["multiLang"];
            /**
             * Institution code
             * @description Institution code for natural history specimen collection holding institution, such as H, MHZ or TUR
             */
            institutionCode?: string;
            intellectualDescription?: components["schemas"]["multiLang"];
            /**
             * Publisher name (en)
             * @description Name of the institution or organisation publishing the data.
             */
            intellectualOwner?: string;
            /**
             * License for use
             * @description License which is used when publishing data that belongs to this collection.
             * @enum {string}
             */
            intellectualRights: "MY.intellectualRightsCC-BY" | "MY.intellectualRightsCC0" | "MY.intellectualRightsPD" | "MY.intellectualRightsARR";
            /**
             * Internal use only
             * @description Is the data to be used only within Kotka?
             */
            internalUseOnly?: boolean;
            /**
             * Is part of
             * @description Which parent or larger collection this is part of.
             */
            isPartOf?: string;
            /**
             * Language
             * @description Language the data is (mainly) written in, if applicable.
             */
            language?: string;
            longName?: components["schemas"]["multiLang"];
            /** Person responsible for this metadata */
            metadataCreator?: string;
            /**
             * Status of this metadata
             * @description Indication of how comprehensive the information on this form is.
             * @enum {string}
             */
            metadataStatus?: "" | "MY.metadataStatusPreliminary" | "MY.metadataStatusSatisfactory" | "MY.metadataStatusComprehensive" | "MY.metadataStatusHidden";
            methods?: components["schemas"]["multiLang"];
            /**
             * Notes
             * @description Additional information to the data in each section.
             */
            notes?: string;
            onlineUrl?: components["schemas"]["multiLang"];
            /**
             * Person responsible
             * @description Person(s) responsible for the collection (Lastname, Firstname; Lastname, Firstname).
             */
            personResponsible: string;
            /**
             * Accessibility to public
             * @description Used for botanic garden collections. Is the collection/garden area accessible to public or not.
             */
            publicAccess?: boolean;
            publicationDescription?: components["schemas"]["multiLang"];
            /**
             * Publication terms
             * @description How can Luomus publish the data, if it is owned by third party?
             * @enum {string}
             */
            publicationTerms?: "" | "MY.publicationTermsFree" | "MY.publicationTermsOfficial" | "MY.publicationTermsInternal" | "MY.publicationTermsNone";
            publisherShortname?: components["schemas"]["multiLang"];
            /** Share to FEO */
            shareToFEO?: string;
            /**
             * Share to GBIF
             * @description Admin field. Can the data be shared to GBIF or not: Given collection ID means data is shared under that collection.
             */
            shareToGbif?: string;
            taxonomicCoverage?: components["schemas"]["multiLang"];
            temporalCoverage?: components["schemas"]["multiLang"];
            /**
             * Amount of type specimens (approx.)
             * @description How many TYPE specimens does the collection contain?  Fill in approximate number, describe more in notes if necessary.
             */
            typesSize?: string;
            /** Creator */
            creator?: string;
            /**
             * Created
             * Format: date-time
             */
            dateCreated?: string;
            /**
             * Edited
             * Format: date-time
             */
            dateEdited?: string;
            /** Editor */
            editor?: string;
            /**
             * Owner of record
             * @description Team or organisation that owns the record and can edit it.
             */
            owner?: string;
            /**
             * Publicity restrictions
             * @description PUBLIC: all data can be published; PROTECTED: exact locality is hidden (100*100km square); PRIVATE: most of the data is hidden. Empty value means same as public.
             * @enum {string}
             */
            publicityRestrictions?: "" | "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
        };
        namedPlace: {
            /** Context for the MNP.namedPlace */
            "@context"?: string;
            /** Id for the MNP.namedPlace */
            id?: string;
            /** Type for the MNP.namedPlace */
            "@type"?: string;
            acceptedDocument?: components["schemas"]["document"];
            /**
             * Accessibility
             * @enum {string}
             */
            accessibility?: "" | "MNP.accessibilityEasy" | "MNP.accessibilityModerate" | "MNP.accessibilityDifficult";
            active?: components["schemas"]["dateRange"];
            /** Alternative IDs */
            alternativeIDs?: string[];
            /**
             * Biogeographical province
             * @description Formal abbreviation. For Finnish elimaakunnat, use Finnish abbreviation.
             */
            biogeographicalProvince?: string[];
            /** Bird assocation area */
            birdAssociationArea?: string[];
            /** Collection */
            collectionID?: string;
            /**
             * Editors
             * @description Persons who have rights to see and use the named places in their documents
             */
            editors?: string[];
            geometry: components["schemas"]["geometry"];
            /** Images */
            images?: string[];
            /** Paikkatiedot */
            locality?: string;
            /**
             * Locality description
             * @description Informal description of the exact locality, e.g. '5 km NE of city X, under stone bridge'
             */
            localityDescription?: string;
            /** Municipality */
            municipality?: string[];
            /** Name */
            name: string;
            /** Notes */
            notes?: string;
            /**
             * Owners of the named place
             * @description Persons who have full use access and rights to edit the named place
             */
            owners?: string[];
            prepopulatedDocument?: components["schemas"]["document"];
            /**
             * Priority
             * @enum {string}
             */
            priority?: "" | "MNP.priority1" | "MNP.priority2" | "MNP.priority3" | "MNP.priority4" | "MNP.priority5";
            /** Private notes */
            privateNotes?: string;
            /**
             * Publicly available
             * @description Is the named place publicaly available. (Defaults to false)
             */
            public?: boolean;
            reserve?: components["schemas"]["reserve"];
            /** Tags */
            tags?: ("" | "MNP.tagAccessibilityEasy" | "MNP.tagAccessibilityModerate" | "MNP.tagAccessibilityDifficult" | "MNP.tagHabitatImportant" | "MNP.tagCensusRare" | "MNP.tagHabitatFarmland" | "MNP.tagHabitatMire" | "MNP.tagHabitatMountain" | "MNP.tagSuitable")[];
            /** Taxa */
            taxonIDs?: string[];
        };
        dateRange: {
            /** Context for the MNP.dateRange */
            "@context"?: string;
            /** Id for the MNP.dateRange */
            id?: string;
            /** Type for the MNP.dateRange */
            "@type"?: string;
            /**
             * End
             * Format: date
             */
            end?: string;
            /**
             * Start
             * Format: date
             */
            start?: string;
        };
        reserve: {
            /** Context for the MNP.reserveClass */
            "@context"?: string;
            /** Id for the MNP.reserveClass */
            id?: string;
            /** Type for the MNP.reserveClass */
            "@type"?: string;
            /** Reserver */
            reserver: string;
            /**
             * Until
             * Format: date
             */
            until: string;
        };
        area: {
            /** Context for the Area */
            "@context"?: string;
            /** Id for the Area */
            id?: string;
            /** Type for the Area */
            "@type"?: string;
            /**
             * Area type
             * @description Aluetyyppi
             * @enum {string}
             */
            areaType: "ML.country" | "ML.biogeographicalProvince" | "ML.municipality" | "ML.oldMunicipality" | "ML.elyCentre" | "ML.province" | "ML.continent" | "ML.iucnEvaluationArea" | "ML.birdAssociationArea";
            /**
             * Country code
             * @description Country code ISO alpha 2
             */
            countryCodeISOalpha2?: string;
            /**
             * country code
             * @description country code ISO alpha 3
             */
            countryCodeISOalpha3?: string;
            /** Part of */
            isPartOf?: string;
            /** Is part of bird assocation area */
            isPartOfBirdAssociationArea?: string;
            /** Is part of Environmental ELY */
            isPartOfEnvironmentalELY?: string;
            /** Is part of province */
            isPartOfProvince?: string;
            name: components["schemas"]["multiLang"];
            /** Previously used name */
            previouslyOfficialName?: string[];
            provinceCodeAlpha?: components["schemas"]["multiLang"];
            /** Province code numeric */
            provinceCodeNumeric?: string;
            /** ringingDepartmentBirdAssociationAreaCode */
            ringingDepartmentBirdAssociationAreaCode?: string;
            /** ringingDepartmentMunicipalityCode */
            ringingDepartmentMunicipalityCode?: string;
        };
        tag: {
            /** Context for the MMAN.tagClass */
            "@context"?: string;
            /** Id for the MMAN.tagClass */
            id?: string;
            /** Type for the MMAN.tagClass */
            "@type"?: string;
            description?: components["schemas"]["multiLang"];
            name?: components["schemas"]["multiLang"];
            /** Required role to add */
            requiredRolesAdd?: ("" | "MMAN.expert" | "MMAN.basic" | "MMAN.owner" | "MMAN.formAdmin" | "MMAN.ictAdmin")[];
            /** Required role to remove */
            requiredRolesRemove?: ("" | "MMAN.expert" | "MMAN.basic" | "MMAN.owner" | "MMAN.formAdmin" | "MMAN.ictAdmin")[];
            /**
             * Type
             * @enum {string}
             */
            type?: "" | "MMAN.typeCheck" | "MMAN.typeAdmin" | "MMAN.typeInfo" | "MMAN.typeInvasive" | "MMAN.typeCensus" | "MMAN.typeNegativeQuality" | "MMAN.typePositiveQuality";
        };
        checklist: {
            /** Context for the Checklist */
            "@context"?: string;
            /** Id for the Checklist */
            id?: string;
            /** Type for the Checklist */
            "@type"?: string;
            "dc:bibliographicCitation"?: components["schemas"]["multiLang"];
            /** isPublic */
            isPublic: boolean;
            /** owner */
            owner: string;
            /** rootTaxon */
            rootTaxon: string;
            /** Notes */
            "rdfs:comment"?: string;
        };
        SensitiveOrganization: {
            fullName: string;
            "@context": string;
            organizationLevel1: Record<string, never>;
            organizationLevel2?: Record<string, never>;
            organizationLevel3?: Record<string, never>;
            organizationLevel4?: Record<string, never>;
            abbreviation?: string;
        };
        informalTaxonGroup: {
            /** Context for the Informal Taxon Group */
            "@context"?: string;
            /** Id for the Informal Taxon Group */
            id?: string;
            /** Type for the Informal Taxon Group */
            "@type"?: string;
            /**
             * Explicitly defined root
             * @description If this is true, the group is considered a root even if it has parents. For example Fishes is part of Water animals but still is wanted to be a root by itself.
             */
            explicitlyDefinedRoot?: boolean;
            /** Has subgroup */
            hasSubGroup?: string[];
            name: components["schemas"]["multiLang"];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    FormsController_getPermissions: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormPermissionPersonDto"];
                };
            };
        };
    };
    FormsController_getPermissionsByCollectionID: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                collectionID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormPermissionDto"];
                };
            };
        };
    };
    FormsController_requestAccess: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                collectionID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormPermissionDto"];
                };
            };
        };
    };
    FormsController_acceptAccess: {
        parameters: {
            query: {
                /** @description Person token who is authorised to accept requests */
                personToken: string;
            };
            header?: never;
            path: {
                collectionID: string;
                personID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormPermissionDto"];
                };
            };
        };
    };
    FormsController_revokeAccess: {
        parameters: {
            query: {
                /** @description Person token who is authorised to accept requests */
                personToken: string;
            };
            header?: never;
            path: {
                collectionID: string;
                personID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FormPermissionDto"];
                };
            };
        };
    };
    FormsController_getPage: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                pageSize?: number;
                page?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["form"][];
                    };
                };
            };
        };
    };
    FormsController_create: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["form"];
                };
            };
        };
    };
    FormsController_getOne: {
        parameters: {
            query?: {
                format?: "schema" | "json";
                /** @description Language of fields that have multiple languages. If multi is selected fields that can have multiple languages will contain language objects. Defaults to 'en' */
                lang?: "fi" | "sv" | "en" | "multi";
                /** @description Expand response */
                expand?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["form"];
                };
            };
        };
    };
    FormsController_update: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["form"];
                };
            };
        };
    };
    FormsController_remove: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    FormsController_transform: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
                /** @description Language of fields that have multiple languages. If multi is selected fields that can have multiple languages will contain language objects. Defaults to 'en' */
                lang?: "fi" | "sv" | "en" | "multi";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["form"];
                };
            };
        };
    };
    PersonsController_findPersonByToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Person"];
                };
            };
        };
    };
    PersonsController_findProfileByPersonToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    PersonsController_updateProfile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Profile"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Profile"];
                };
            };
        };
    };
    PersonsController_createProfile: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Profile"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Profile"];
                };
            };
        };
    };
    PersonsController_findPersonByPersonId: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SensitivePerson"];
                };
            };
        };
    };
    PersonsController_getProfileByPersonId: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SensitiveProfile"];
                };
            };
        };
    };
    PersonsController_acceptFriendRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
                friendPersonID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PersonsController_addFriendRequest: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
                friendPersonID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    PersonsController_removeFriend: {
        parameters: {
            query: {
                block: boolean;
            };
            header?: never;
            path: {
                personToken: string;
                friendPersonID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    PersonTokenController_getInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    PersonTokenController_delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    NotificationsController_getAll: {
        parameters: {
            query?: {
                /** @description Return only notifications that have not been marked as seen. */
                onlyUnSeen?: boolean;
                page?: number;
                pageSize?: number;
            };
            header?: never;
            path: {
                personToken: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    NotificationsController_update: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["notification"];
                };
            };
        };
    };
    NotificationsController_delete: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreDeleteResponse"];
                };
            };
        };
    };
    CollectionsController_getPage: {
        parameters: {
            query?: {
                /** @description Comma separated ids */
                idIn?: string;
                page?: number;
                pageSize?: number;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["collection"][];
                    };
                };
            };
        };
    };
    CollectionsController_findRoots: {
        parameters: {
            query?: {
                page?: number;
                pageSize?: number;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["collection"][];
                    };
                };
            };
        };
    };
    CollectionsController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["collection"];
                };
            };
        };
    };
    CollectionsController_findChildren: {
        parameters: {
            query?: {
                page?: number;
                pageSize?: number;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["collection"][];
                    };
                };
            };
        };
    };
    ApiUsersController_getInfo: {
        parameters: {
            query?: {
                /** @description access token which to return information from */
                accessToken?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiUserEntity"];
                };
            };
        };
    };
    ApiUsersController_register: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ApiUserCreateDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ApiUsersController_renew: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ApiUserCreateDto"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagesController_upload: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileUploadResponse"];
                };
            };
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagesController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Image"];
                };
            };
        };
    };
    ImagesController_updateMetadata: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Image"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Image"];
                };
            };
        };
    };
    ImagesController_delete: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagesController_findLarge: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagesController_findSquare: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagesController_findThumbnail: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagesController_uploadMetadata: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                tempId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Image"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Image"];
                };
            };
        };
    };
    AudioController_upload: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileUploadResponse"];
                };
            };
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AudioController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Audio"];
                };
            };
        };
    };
    AudioController_updateMetadata: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Audio"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Audio"];
                };
            };
        };
    };
    AudioController_delete: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AudioController_getMp3: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AudioController_getThumbnail: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AudioController_getWav: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AudioController_findFlac: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AudioController_uploadMetadata: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                tempId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Audio"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Audio"];
                };
            };
        };
    };
    NamedPlacesController_reserve: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
                /** @description Id for the person (your own id will be used if you are not admin) */
                personID?: string;
                /** @description The date when the reservation expires */
                until?: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["namedPlace"];
                };
            };
        };
    };
    NamedPlacesController_cancelReservation: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["namedPlace"];
                };
            };
        };
    };
    NamedPlacesController_getPage: {
        parameters: {
            query: {
                /** @description Include only items with these ids. Multiple values are separated by a comma (,). */
                idIn?: string;
                /** @description alternative ID. Multiple values are separated by a comma (,). */
                alternativeIDs?: string;
                /** @description municipality area code. Multiple values are separated by a comma (,). */
                municipality?: string;
                /** @description bird association area code. Multiple values are separated by a comma (,). */
                birdAssociationArea?: string;
                /** @description Return only selected fields per place. Multiple values are separated by a comma (,). */
                selectedFields?: string;
                taxonIDs?: string;
                /** @description Filter by tags. Multiple values are separated by a comma (,). */
                tags?: string;
                /** @description Collection id. Child collections are also fetched. */
                collectionID: string;
                /** @description Include public named places (used only when personToken is given). Defaults to true. */
                includePublic?: boolean;
                /** @description Include units in prepopulated and accepted documents (only form forms with 'MHL.includeUnits' true). Defaults to false. */
                includeUnits?: boolean;
                /** @description Person's authentication token */
                personToken?: string;
                page?: number;
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    NamedPlacesController_create: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NamedPlace"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["namedPlace"];
                };
            };
        };
    };
    NamedPlacesController_get: {
        parameters: {
            query?: {
                /** @description Person's authentication token. Necessary for fetching non public places. */
                personToken?: string;
                /** @description Include units in prepopulated and accepted documents (only for forms with 'MHL.includeUnits' true). */
                includeUnits?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["namedPlace"];
                };
            };
        };
    };
    NamedPlacesController_update: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NamedPlace"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["namedPlace"];
                };
            };
        };
    };
    NamedPlacesController_delete: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreDeleteResponse"];
                };
            };
        };
    };
    AreaController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["area"];
                };
            };
        };
    };
    AreaController_getPage: {
        parameters: {
            query?: {
                /** @description Include only items with the given ids. Multiple values are separated by a comma (,). */
                idIn?: string;
                /** @description Area type */
                areaType?: "ML.country" | "ML.biogeographicalProvince" | "ML.municipality" | "ML.oldMunicipality" | "ML.birdAssociationArea" | "ML.iucnEvaluationArea";
                page?: number;
                pageSize?: number;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["area"][];
                    };
                };
            };
        };
    };
    DocumentsController_startBatchJob: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchJobValidationStatusResponse"];
                };
            };
        };
    };
    DocumentsController_getBatchJobStatus: {
        parameters: {
            query: {
                validationErrorFormat?: "remote" | "object" | "jsonPointer" | "jsonPath" | "dotNotation";
                publicityRestrictions?: "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
                dataOrigin?: "MY.dataOriginPaperForm" | "MY.dataOriginWebForm" | "MY.dataOriginSpreadsheetFile";
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                jobID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @enum {string} */
                        phase: "VALIDATING" | "READY_TO_COMPLETE" | "COMPLETING" | "COMPLETED";
                        /** @default [] */
                        errors: (components["schemas"]["ErrorsObj"] | null)[];
                        id: string;
                        documents?: components["schemas"]["document"][];
                        status: components["schemas"]["BatchJobValidationStatus"];
                        personID: string;
                    };
                };
            };
        };
    };
    DocumentsController_completeBatchJob: {
        parameters: {
            query: {
                validationErrorFormat?: "remote" | "object" | "jsonPointer" | "jsonPath" | "dotNotation";
                publicityRestrictions?: "MZ.publicityRestrictionsPublic" | "MZ.publicityRestrictionsProtected" | "MZ.publicityRestrictionsPrivate";
                dataOrigin?: "MY.dataOriginPaperForm" | "MY.dataOriginWebForm" | "MY.dataOriginSpreadsheetFile";
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                jobID: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BatchJobValidationStatusResponse"];
                };
            };
        };
    };
    DocumentsController_validate: {
        parameters: {
            query?: {
                /** @description Taxon belongs to informal taxon group only: Validate that taxon belongs to informal taxon group(s). Multiple values are separated by a comma (,). */
                informalTaxonGroup?: string;
                /** @description Json path of the field being validated (defaults to the whole document). */
                field?: string;
                /** @description Name of the validator to run (default all specified in the form). */
                validator?: "noExistingGatheringsInNamedPlace" | "wbcNamedPlaceExists" | "overlapWithNamedPlace" | "uniqueNamedPlaceAlternativeIDs" | "namedPlaceNotTooNearOtherPlaces" | "waterbirdPairCount" | "taxonBelongsToInformalTaxonGroup";
                /** @description Run validators of this type */
                type?: "error" | "warning";
                /** @description Format of validation error details */
                validationErrorFormat?: "remote" | "object" | "jsonPointer" | "jsonPath" | "dotNotation";
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    DocumentsController_getCountByYear: {
        parameters: {
            query: {
                /** @description Limit the list of documents to a certain collection */
                collectionID?: string;
                /** @description Limit the list of documents to a certain form */
                formID?: string;
                /** @description Limit the list of documents to a certain named place */
                namedPlace?: string;
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DocumentCountItemResponse"][];
                };
            };
        };
    };
    DocumentsController_getStatistics: {
        parameters: {
            query: {
                /** @description Limit the list of documents to a certain named place */
                namedPlace: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatisticsResponse"];
                };
            };
        };
    };
    DocumentsController_getPage: {
        parameters: {
            query: {
                /** @description Limit the list of documents to a certain named place */
                namedPlace?: string;
                /** @description Comma separated list of field names to include in the response */
                selectedFields?: string;
                /** @description Limit the list of documents to a certain observation year */
                observationYear?: number;
                /** @description Fetch only templates */
                templates?: boolean;
                /** @description Collection id. Child collections are also fetched. */
                collectionID?: string;
                /** @description Limit the list of documents to a certain source application. */
                sourceID?: string;
                /** @description Use this form's features for the request. */
                formID?: string;
                page?: number;
                pageSize?: number;
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    DocumentsController_create: {
        parameters: {
            query: {
                /** @description Format of validation error details */
                validationErrorFormat?: "remote" | "object" | "jsonPointer" | "jsonPath" | "dotNotation";
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["document"];
                };
            };
        };
    };
    DocumentsController_get: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["document"];
                };
            };
        };
    };
    DocumentsController_update: {
        parameters: {
            query: {
                /** @description Format of validation error details */
                validationErrorFormat?: "remote" | "object" | "jsonPointer" | "jsonPath" | "dotNotation";
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["document"];
                };
            };
        };
    };
    DocumentsController_delete: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StoreDeleteResponse"];
                };
            };
        };
    };
    AnnotationsController_getTags: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["tag"];
                };
            };
        };
    };
    AnnotationsController_getPage: {
        parameters: {
            query: {
                /** @description Filter by root ID */
                rootID: string;
                /** @description Person's authentication token */
                personToken: string;
                page?: number;
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    AnnotationsController_create: {
        parameters: {
            query?: {
                /** @description Person's authentication token */
                personToken?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["annotation"];
                };
            };
        };
    };
    AnnotationsController_delete: {
        parameters: {
            query: {
                /** @description Person's authentication token */
                personToken: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["annotation"];
                };
            };
        };
    };
    InformationController_getIndex: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": Record<string, never>;
                };
            };
        };
    };
    InformationController_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Information"];
                };
            };
        };
    };
    InformationController_getAll: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en";
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Information"];
                };
            };
        };
    };
    ChecklistController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["checklist"];
                };
            };
        };
    };
    ChecklistController_getPage: {
        parameters: {
            query?: {
                /** @description Include only items with the given ids. Multiple values are separated by a comma (,). */
                idIn?: string;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
                page?: number;
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["checklist"][];
                    };
                };
            };
        };
    };
    ChecklistVersionsController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["checklist"];
                };
            };
        };
    };
    ChecklistVersionsController_getPage: {
        parameters: {
            query?: {
                /** @description Include only items with the given ids. Multiple values are separated by a comma (,). */
                idIn?: string;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
                page?: number;
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["checklist"][];
                    };
                };
            };
        };
    };
    OrganizationsController_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SensitiveOrganization"];
                };
            };
        };
    };
    InformalTaxonGroupsController_getPage: {
        parameters: {
            query?: {
                /** @description Comma separated ids */
                idIn?: string;
                page?: number;
                pageSize?: number;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["informalTaxonGroup"][];
                    };
                };
            };
        };
    };
    InformalTaxonGroupsController_getTree: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    InformalTaxonGroupsController_getRoots: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    InformalTaxonGroupsController_get: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["informalTaxonGroup"];
                };
            };
        };
    };
    InformalTaxonGroupsController_getChildren: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        "@context"?: string;
                        results?: components["schemas"]["informalTaxonGroup"][];
                    };
                };
            };
        };
    };
    InformalTaxonGroupsController_getParents: {
        parameters: {
            query?: {
                page?: number;
                pageSize?: number;
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        page: number;
                        pageSize: number;
                        total: number;
                        lastPage: number;
                        prevPage?: number;
                        nextPage?: number;
                        results: components["schemas"]["informalTaxonGroup"][];
                    };
                };
            };
        };
    };
    InformalTaxonGroupsController_getParent: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["informalTaxonGroup"];
                };
            };
        };
    };
    InformalTaxonGroupsController_getSiblings: {
        parameters: {
            query?: {
                lang?: "fi" | "sv" | "en" | "multi";
                langFallback?: boolean;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        "@context"?: string;
                        results?: components["schemas"]["informalTaxonGroup"][];
                    };
                };
            };
        };
    };
}
